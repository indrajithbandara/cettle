<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1447968100506">{:repl-history {:ide [], :local [&quot;(defmethod cetl-copy-file :copy-file\n  [x]\n  (let [file (:file x)\n        in-path (:in-path x)\n        out-path (:out-path x)\n        full-in-path (str (:in-path x) \&quot;/\&quot; (:file x))]\n    (cond (not (file-exists? full-in-path))\n          (throw\n            (IllegalArgumentException.\n                   (str full-in-path \&quot; file does not exist\&quot;)))\n          (or (not (dir-exists? in-path)) (not (dir-exists? out-path)))\n          (throw\n            (IllegalArgumentException.\n                   (str in-path \&quot; is not a directory\&quot;)))\n          :else\n      (do\n        (io/copy\n          (io/file (str in-path \&quot;/\&quot; file))\n          (io/file (str out-path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str (:out-path x) \&quot;/\&quot; (:file x))))))))&quot; &quot;(defmethod cetl-copy-file :copy-file\n  [x]\n  (let [file (:file x)\n        in-path (:in-path x)\n        out-path (:out-path x)\n        full-in-path (str (:in-path x) \&quot;/\&quot; (:file x))]\n    (cond (not (file-exists? full-in-path))\n          (throw\n            (IllegalArgumentException.\n                   (str full-in-path \&quot; file does not exist\&quot;)))\n          (not (dir-exists? in-path))\n          (throw\n            (IllegalArgumentException.\n                   (str in-path \&quot; is not a directory\&quot;)))\n          (not (dir-exists? out-path))\n          (throw\n            (IllegalAccessException.\n                   (str out-path \&quot; is not a directory\&quot;)))\n          :else\n      (do\n        (io/copy\n          (io/file (str in-path \&quot;/\&quot; file))\n          (io/file (str out-path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str (:out-path x) \&quot;/\&quot; (:file x))))))))&quot; &quot;(defmethod cetl-copy-file :copy-file\n  [x]\n  (let [file (:file x)\n        in-path (:in-path x)\n        out-path (:out-path x)\n        full-in-path (str (:in-path x) \&quot;/\&quot; (:file x))]\n    (cond (not (file-exists? full-in-path))\n          (throw\n            (IllegalArgumentException.\n                   (str full-in-path \&quot; file does not exist\&quot;)))\n           (not (dir-exists? out-path))\n          (throw\n            (IllegalArgumentException.\n                   (str out-path \&quot; is not a directory\&quot;)))\n          :else\n      (do\n        (io/copy\n          (io/file (str in-path \&quot;/\&quot; file))\n          (io/file (str out-path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str (:out-path x) \&quot;/\&quot; (:file x))))))))&quot; &quot;(cetl-copy-file {:in-path \&quot;/Users/gregadebesin/Development\&quot;\n                 :out-path \&quot;/Users/gregdebesin\&quot;\n                 :file \&quot;foo.tmp\&quot;\n                 :exec :copy-file})&quot; &quot;(defrecord Person [fname lname age])&quot; &quot;(def greg (Person. \&quot;Greg\&quot; \&quot;Adebesin\&quot; \&quot;29\&quot;))&quot; &quot;(:fname greg)&quot; &quot;(defn cetl-delete-file [z])&quot; &quot;(defn delete-file\n  (cetl-delete-file. :delete-file))&quot; &quot;(defrecord cetl-delete-file [delete-file])&quot; &quot;(defrecord cetl-delete-file [dd])&quot; &quot;(defn delete-file (cetl-delete-file. \&quot;\&quot;))&quot; &quot;@cetl-delete-file&quot; &quot;(defrecord cdf [dd])&quot; &quot;(def d (cdf. \&quot;\&quot;))&quot; &quot;(defrecord cdf1 [df])&quot; &quot;(def d (cdf1. :exec))&quot; &quot;(:df d)&quot; &quot;(defmulti cetl-archive-file (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-archive-file :zip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        path (:path x)\n        file (:file x)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir (File. path) next-command\n           zip-command (str file file-ext)\n           rec-command file))\n    (assoc x :result\n             (vector\n               (str (:path x) \&quot;/\&quot; (:file x) file-ext)))))&quot; &quot;(defmethod cetl-archive-file :zip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (clojure.java.shell/sh\n        \&quot;sh\&quot; \&quot;-c\&quot;\n        (str move-to-dir (File. path) next-command\n             zip-command (str file file-ext)\n             rec-command file))\n      (assoc x :result\n               (vector\n                 (str file-path file-ext)))\n      (throw \n        (FileNotFoundException. \n          (str file-path) \&quot; is not a file (or a directory)\&quot;)))))&quot; &quot;(defmethod cetl-archive-file :zip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               zip-command (str file file-ext)\n               rec-command file))\n        (assoc x :result\n                 (vector\n                   (str file-path file-ext))))\n      (throw \n        (FileNotFoundException. \n          (str file-path) \&quot; is not a file (or a directory)\&quot;)))))&quot; &quot;(defmethod cetl-archive-file :zip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               zip-command (str file file-ext)\n               rec-command file))\n        (assoc x :result\n                 (vector\n                   (str file-path file-ext))))\n      (throw \n        (IllegalArgumentException. \n          (str file-path) \&quot; is not a file (or a directory)\&quot;)))))&quot; &quot;(defmethod cetl-archive-file :zip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               zip-command (str file file-ext)\n               rec-command file))\n        (assoc x :result\n                 (vector\n                   (str file-path file-ext))))\n      (throw \n        (FileNotFoundException\n          (str file-path) \&quot; is not a file (or a directory)\&quot;)))))&quot; &quot;(defmethod cetl-archive-file :zip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               zip-command (str file file-ext)\n               rec-command file))\n        (assoc x :result\n                 (vector\n                   (str file-path file-ext))))\n      (throw \n        (FileNotFoundException.\n          (str file-path) \&quot; is not a file (or a directory)\&quot;)))))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists?]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.io File FileNotFoundException)\n           (java.text SimpleDateFormat)))&quot; &quot;(defmethod cetl-archive-file :zip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               zip-command (str file file-ext)\n               rec-command file))\n        (assoc x :result\n                 (vector\n                   (str file-path file-ext))))\n      (throw \n        (java.io.FileNotFoundException.\n          (str file-path) \&quot; is not a file (or a directory)\&quot;)))))&quot; &quot;(defmethod cetl-archive-file :zip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               zip-command (str file file-ext)\n               rec-command file))\n        (assoc x :result\n                 (vector\n                   (str file-path file-ext))))\n      (throw \n        (FileNotFoundException.)))))&quot; &quot;(defmethod cetl-archive-file :zip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               zip-command (str file file-ext)\n               rec-command file))\n        (assoc x :result\n                 (vector\n                   (str file-path file-ext))))\n      (throw \n        (IllegalArgumentException.\n          (str file-path) \&quot; is not a file (or a directory)\&quot;)))))&quot; &quot;(defmethod cetl-archive-file :zip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (clojure.java.shell/sh\n        \&quot;sh\&quot; \&quot;-c\&quot;\n        (str move-to-dir (File. path) next-command\n             zip-command (str file file-ext)\n             rec-command file))\n      (assoc x :result\n               (vector\n                 (str file-path file-ext)))\n      (throw \n        (IllegalArgumentException.\n          (str file-path) \&quot; is not a file (or a directory)\&quot;)))))&quot; &quot;(defmethod cetl-archive-file :zip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               zip-command (str file file-ext)\n               rec-command file))\n        (assoc x :result\n                 (vector\n                   (str file-path file-ext))))\n      (throw \n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-archive-file :zip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (or (file-exists? file-path) (dir-exists? path))\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               zip-command (str file file-ext)\n               rec-command file))\n        (assoc x :result \n                 (vector\n                   (str file-path file-ext))))\n      (throw \n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(cetl-archive-file {:path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                    :file \&quot;foo\&quot;\n                    :exec :zip-file})&quot; &quot;(cetl-archive-file {:path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                    :file \&quot;archive\&quot;\n                    :exec :zip-file})&quot; &quot;(cetl-archive-file {:path \&quot;/Uers/gregadebesin/Development/Cetl\&quot;\n                    :file \&quot;foo\&quot;\n                    :exec :zip-file})&quot; &quot;(defmethod cetl-archive-file :gzip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        gzip-command \&quot; tar -cvzf \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.tar.gz\&quot;\n        path (:path x)\n        file (:file x)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir  (File. path) next-command\n           gzip-command (str file file-ext\&quot; \&quot;file)))\n    (assoc x :result\n             (vector (str (:path x) \&quot;/\&quot; (:file x) file-ext)))))&quot; &quot;(defmethod cetl-archive-file :gzip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        gzip-command \&quot; tar -cvzf \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.tar.gz\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (or (file-exists? file-path)  (dir-exists? path))\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               gzip-command (str file file-ext \&quot; \&quot; file)))\n        (assoc x :result\n                 (vector (str file-path file-ext))))\n      (throw \n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(cetl-archive-file {:path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                    :file \&quot;archive\&quot;\n                    :exec :gzip-file})&quot; &quot;(cetl-archive-file {:path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                    :file \&quot;foo\&quot;\n                    :exec :gzip-file})&quot; &quot;(cetl-archive-file {:path \&quot;/sers/gregadebesin/Development/Cetl\&quot;\n                    :file \&quot;foo\&quot;\n                    :exec :gzip-file})&quot; &quot;(defmulti cetl-encode-file (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-encode-file :encode-file-ISO-8859-1\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (FileUtils/write\n          (File. file-path)\n          (FileUtils/readFileToString\n            (File. file-path) \&quot;UTF-8\&quot;) \&quot;ISO-8859-1\&quot;)\n        (assoc x :result\n                 (vector (str (:path x) \&quot;/\&quot; (:file x)))))\n      (throw \n        (IllegalArgumentException. \n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-encode-file :ISO-8859-1\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (FileUtils/write\n          (File. file-path)\n          (FileUtils/readFileToString\n            (File. file-path) \&quot;UTF-8\&quot;) \&quot;ISO-8859-1\&quot;)\n        (assoc x :result\n                 (vector (str (:path x) \&quot;/\&quot; (:file x)))))\n      (throw \n        (IllegalArgumentException. \n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(cetl-encode-file {:path \&quot;/Users/greadebesin/Development/datomic-code.txt\&quot;\n                   :exec :ISO-8859-1})&quot; &quot;(defmethod cetl-encode-file :UTF-8\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (FileUtils/write\n          (File. file-path)\n          (FileUtils/readFileToString\n            (File. file-path) \&quot;ISO-8859-1\&quot;) \&quot;UTF-8\&quot;)\n        (assoc x :result\n                 (vector (str (:path x) \&quot;/\&quot; (:file x)))))\n      (throw \n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(cetl-encode-file {:path \&quot;/Uses/greadebesin/Development/datomic-code.txt\&quot;\n                   :exec :UTF-8})&quot; &quot;(cetl-encode-file {:path \&quot;/Users/gregadebesin/Development/untitled.txt\&quot;\n                   :exec :UTF-8})&quot; &quot;(cetl-encode-file {:path \&quot;/Users/gregadebesin/Development/untitled.txt\&quot;\n                   :exec :ISO-8859-})&quot; &quot;(defmulti cetl-delete-file (:exec))&quot; &quot;(defmulti cetl-delete-file (fn [x] (:exec x?)))&quot; &quot;(defmulti cetl-delete-file (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-delete-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:exec x)]\n    (if (= exec :delete-file)\n      (do\n        (io/delete-file\n          (io/file\n            (str path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x))))))))&quot; &quot;(defmethod cetl-delete-file :delete-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:exec x)]\n    (if (= exec :delete-file)\n      (do\n        (io/delete-file\n          (io/file\n            (str path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x))))))))&quot; &quot;(defmethod cetl-delete-file :delete-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (io/delete-file\n          (io/file\n            (str path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x)))))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(cetl-delete-file {:path \&quot;/Users/gregdebesin/Development\&quot;\n                   :file \&quot;untitled.txt\&quot;\n                   :exec :delete-file})&quot; &quot;(cetl-delete-file {:path \&quot;/Users/gregadebesin/Development\&quot;\n                   :file \&quot;untitled.txt\&quot;\n                   :exec :delete-file})&quot; &quot;2&quot; &quot;(defmulti cetl-properties-file (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-properties-file\n  [x]\n  (let [file (File. (:path x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (= exec :file-properties)\n      (do (assoc x :result (vector abs-file-path\n                                   parent-dir\n                                   file-name\n                                   read-permissions\n                                   write-permissions\n                                   execute-permissions\n                                   file-size\n                                   modified-time-millis\n                                   modified-time-str))))))&quot; &quot;(doc cetl-properties-file)&quot; &quot;(defmulti cetl-properties-file \&quot;Foo Bar\&quot; (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-properties-file {:arglists '([x])} :properties-file\n  [x]\n  (let [file (File. (:path x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (= exec :file-properties)\n      (do (assoc x :result (vector abs-file-path\n                                   parent-dir\n                                   file-name\n                                   read-permissions\n                                   write-permissions\n                                   execute-permissions\n                                   file-size\n                                   modified-time-millis\n                                   modified-time-str))))))&quot; &quot;(clojure.repl/doc assoc)&quot; &quot;(ns-unmap *ns* cetl-properties-file)&quot; &quot;(ns-unmap *ns* 'cetl-properties-file)&quot; &quot;(defmulti cetl-properties-file\n          \&quot;Foo Bar\&quot;\n          {:arglists '(map)}\n          (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-properties-file :properties-file\n  [x]\n  (let [file (File. (:path x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (= exec :file-properties)\n      (do (assoc x :result (vector abs-file-path\n                                   parent-dir\n                                   file-name\n                                   read-permissions\n                                   write-permissions\n                                   execute-permissions\n                                   file-size\n                                   modified-time-millis\n                                   modified-time-str))))))&quot; &quot;(clojure.repl/doc cetl-properties-file)&quot; &quot;(defmulti cetl-properties-file\n          \&quot;Foo Bar\&quot;\n          {:arglists '([map])}\n          (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-properties-file :properties-file\n  [x]\n  (let [file (File. (:path x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (do (assoc x :result (vector abs-file-path\n                                 parent-dir\n                                 file-name\n                                 read-permissions\n                                 write-permissions\n                                 execute-permissions\n                                 file-size\n                                 modified-time-millis\n                                 modified-time-str)))))&quot; &quot;(defmethod cetl-properties-file :properties-file\n  [x]\n  (let [path (File. (str (:path x) (:file x)))\n        abs-file-path (.getAbsolutePath path)\n        parent-dir (.getParent path)\n        file-name (.getName path)\n        read-permissions (.canRead path)\n        write-permissions (.canWrite path)\n        execute-permissions (.canExecute path)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length path) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified path)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)]\n    (if (file-exists? path)\n      (do (assoc x :result (vector abs-file-path\n                                   parent-dir\n                                   file-name\n                                   read-permissions\n                                   write-permissions\n                                   execute-permissions\n                                   file-size\n                                   modified-time-millis\n                                   modified-time-str)))\n      (throw \n        (IllegalArgumentException.\n          (str path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists?]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.io File)\n           (java.text SimpleDateFormat)))&quot; &quot;(use '[clojure.java.shell :only [sh]])&quot; &quot;(defmethod cetl-properties-file :properties-file\n  [x]\n  (let [path (File. (str (:path x) \&quot;/\&quot; (:file x)))\n        abs-file-path (.getAbsolutePath path)\n        parent-dir (.getParent path)\n        file-name (.getName path)\n        read-permissions (.canRead path)\n        write-permissions (.canWrite path)\n        execute-permissions (.canExecute path)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length path) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified path)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)]\n    (if (file-exists? path)\n      (do (assoc x :result (vector abs-file-path\n                                   parent-dir\n                                   file-name\n                                   read-permissions\n                                   write-permissions\n                                   execute-permissions\n                                   file-size\n                                   modified-time-millis\n                                   modified-time-str)))\n      (throw\n        (IllegalArgumentException.\n          (str path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(ns cetl.core-test\n  (:require [clojure.test :refer :all]\n            [cetl.core :refer :all]\n            [cetl.file.management :refer :all]))&quot; &quot;(ns cetl.core-test\n  (:require [clojure.test :refer :all]\n            [cetl.core :refer :all]\n            [cetl.file.management :refer :all]\n            (:import (java.io File))))&quot; &quot;(ns cetl.core-test\n  (:require [clojure.test :refer :all]\n            [cetl.core :refer :all]\n            [cetl.file.management :refer :all])\n  (:import (java.io File)))&quot; &quot;(defn dir-exists?\n  [path]\n (let [file (File. path)]\n   (if (.isDirectory file) path)))&quot; &quot;(defn file-exists?\n  [path]\n  (let [file (File. path)]\n    (if (or (and (.exists file)\n                 (not (.isDirectory file))))\n      path)))&quot; &quot;(defmulti cetl-properties-file :properties-file\n  [x]\n  (let [file (File. (st (:path x) \&quot;/\&quot;) (:file x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (file-exists? file)\n      (do (assoc x :result (vector abs-file-path\n                                   parent-dir\n                                   file-name\n                                   read-permissions\n                                   write-permissions\n                                   execute-permissions\n                                   file-size\n                                   modified-time-millis\n                                   modified-time-str))))))&quot; &quot;(defmethod cetl-properties-file :properties-file\n  [x]\n  (let [file (File. (st (:path x) \&quot;/\&quot;) (:file x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (file-exists? file)\n      (do (assoc x :result (vector abs-file-path\n                                   parent-dir\n                                   file-name\n                                   read-permissions\n                                   write-permissions\n                                   execute-permissions\n                                   file-size\n                                   modified-time-millis\n                                   modified-time-str))))))&quot; &quot;(defmethod cetl-properties-file :properties-file\n  [x]\n  (let [file (File. (st (:path x) \&quot;/\&quot;) (:file x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)]\n    (if (file-exists? file)\n      (do (assoc x :result (vector abs-file-path\n                                   parent-dir\n                                   file-name\n                                   read-permissions\n                                   write-permissions\n                                   execute-permissions\n                                   file-size\n                                   modified-time-millis\n                                   modified-time-str))))))&quot; &quot;(defmethod cetl-properties-file :properties-file\n  [x]\n  (let [file (File. (str (:path x) \&quot;/\&quot;) (:file x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)]\n    (if (file-exists? file)\n      (do (assoc x :result (vector abs-file-path\n                                   parent-dir\n                                   file-name\n                                   read-permissions\n                                   write-permissions\n                                   execute-permissions\n                                   file-size\n                                   modified-time-millis\n                                   modified-time-str))))))&quot; &quot;(defmethod cetl-properties-file :properties-file\n  [x]\n  (let [file (File. (str (:path x) \&quot;/\&quot; (:file x)))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)]\n    (if (file-exists? file)\n      (do (assoc x :result (vector abs-file-path\n                                   parent-dir\n                                   file-name\n                                   read-permissions\n                                   write-permissions\n                                   execute-permissions\n                                   file-size\n                                   modified-time-millis\n                                   modified-time-str))))))&quot; &quot;(cetl-properties-file {:path \&quot;/Users/gregadebesin/Developmet\&quot;\n                       :file \&quot;foo.tmp\&quot;\n                       :exec :properties-file})&quot; &quot;(cetl-properties-file {:path \&quot;/Users/gregadebesin/Development\&quot;\n                       :file \&quot;foo.tmp\&quot;\n                       :exec :properties-file})&quot; &quot;(defn cetl-properties-file\n  [x]\n  (let [file (File. (:path x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (= exec :file-properties)\n      (do (assoc x :result (vector abs-file-path\n                                   parent-dir\n                                   file-name\n                                   read-permissions\n                                   write-permissions\n                                   execute-permissions\n                                   file-size\n                                   modified-time-millis\n                                   modified-time-str))))))&quot; &quot;(cetl-properties-file {:path \&quot;/Users/gregadebesin/Development/foo.tmp\&quot;\n                       :exec :file-properties})&quot; &quot;(defn cetl-properties-file\n  [x]\n  (let [file (File. (str (:path x) \&quot;/\&quot; (:file x)))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (= exec :file-properties)\n      (do (assoc x :result (vector abs-file-path\n                                   parent-dir\n                                   file-name\n                                   read-permissions\n                                   write-permissions\n                                   execute-permissions\n                                   file-size\n                                   modified-time-millis\n                                   modified-time-str))))))&quot; &quot;(defn cetl-properties-file\n  [x]\n  (let [file (File. (str (:path x) \&quot;/\&quot; (:file x)))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (do (assoc x :result (vector abs-file-path\n                                 parent-dir\n                                 file-name\n                                 read-permissions\n                                 write-permissions\n                                 execute-permissions\n                                 file-size\n                                 modified-time-millis\n                                 modified-time-str)))))&quot; &quot;(defmulti cetl-properties-file {:arglists '([map])} (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-properties-file :properties-file\n  [x]\n  (let [file (File. (str (:path x) \&quot;/\&quot; (:file x)))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (do (assoc x :result (vector abs-file-path\n                                 parent-dir\n                                 file-name\n                                 read-permissions\n                                 write-permissions\n                                 execute-permissions\n                                 file-size\n                                 modified-time-millis\n                                 modified-time-str)))))&quot; &quot;(defmethod cetl-properties-file :file-properties\n  [x]\n  (let [file (File. (str (:path x) \&quot;/\&quot; (:file x)))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (do (assoc x :result (vector abs-file-path\n                                 parent-dir\n                                 file-name\n                                 read-permissions\n                                 write-permissions\n                                 execute-permissions\n                                 file-size\n                                 modified-time-millis\n                                 modified-time-str)))))&quot; &quot;(cetl-copy-file {:in-path \&quot;/Users/gregaebesin/Development\&quot;\n                 :out-path \&quot;/Users/gregadebesin\&quot;\n                 :file \&quot;foo.tmp\&quot;\n                 :exec :copy-file})&quot; &quot;(cetl-copy-file {:in-path \&quot;/Users/gregadebesin/Development\&quot;\n                 :out-path \&quot;/Users/gregadebesin\&quot;\n                 :file \&quot;foo.tmp\&quot;\n                 :exec :copy-file})&quot; &quot;(cetl-encode-file {:path \&quot;/Users/gregadebesin/Development/untitled.txt\&quot;\n                   :exec :ISO-8859-1})&quot; &quot;(defmethod cetl-properties-file :file-properties\n  [x]\n  (let [file (File. (str (:path x) \&quot;/\&quot; (:file x)))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (file-exists? file)\n      (do (assoc x :result (vector abs-file-path\n                                   parent-dir\n                                   file-name\n                                   read-permissions\n                                   write-permissions\n                                   execute-permissions\n                                   file-size\n                                   modified-time-millis\n                                   modified-time-str))))))&quot; &quot;(defmethod cetl-properties-file :file-properties\n  [x]\n  (let [file (File. (str (:path x) \&quot;/\&quot; (:file x)))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (.isFile file)\n      (do (assoc x :result (vector abs-file-path\n                                   parent-dir\n                                   file-name\n                                   read-permissions\n                                   write-permissions\n                                   execute-permissions\n                                   file-size\n                                   modified-time-millis\n                                   modified-time-str))))))&quot; &quot;(defmethod cetl-properties-file :file-properties\n  [x]\n  (let [file (File. (str (:path x) \&quot;/\&quot; (:file x)))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (.isFile file)\n      (do (assoc x :result (vector abs-file-path\n                                   parent-dir\n                                   file-name\n                                   read-permissions\n                                   write-permissions\n                                   execute-permissions\n                                   file-size\n                                   modified-time-millis\n                                   modified-time-str)))\n      (throw \n        (IllegalArgumentException.\n          (str file \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(cetl-properties-file {:path \&quot;/Users/gregadebesin/Development\&quot;\n                       :file \&quot;foo.tmp\&quot;\n                       :exec :file-properties})&quot; &quot;(cetl-properties-file {:path \&quot;/Users/grgadebesin/Development\&quot;\n                       :file \&quot;foo.tmp\&quot;\n                       :exec :file-properties})&quot;], :remote []}}</component>
</project>