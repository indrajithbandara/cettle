<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1445074816285">{:repl-history {:ide [], :local [&quot;(-&gt;&gt; (reduce #(/ %1 %2) [61734215 1048576])\n     double\n     (format \&quot;%.3f\&quot;)\n     read-string)&quot; &quot;(-&gt;&gt; (reduce #(/ %1 %2) [61734215 1048576])\n     long\n     (format \&quot;%.3f\&quot;)\n     read-string)&quot; &quot;(-&gt;&gt; (reduce #(/ %1 %2) [61734215 1048576])\n     long\n     )&quot; &quot;(-&gt;&gt; (reduce #(/ %1 %2) [61734215 1048576])\n     float\n     (format \&quot;%.3f\&quot;)\n     read-string)&quot; &quot;(-&gt;&gt; (reduce #(/ %1 %2) [6.17e+7 1048576])\n     float\n     (format \&quot;%.3f\&quot;)\n     read-string)&quot; &quot;(-&gt;&gt; (reduce #(/ %1 %2) [6.17e+7 1048576])\n     float\n     (format \&quot;%.3f\&quot;)\n     read-string)2&quot; &quot;(defn cetl-file-properties\n  [x]\n  (let [file (File. (:path x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)]\n    file-size))&quot; &quot;(.length (File. \&quot;/Users/gregadebesin/Development/Cetl/TestFiles.zip\&quot;))&quot; &quot;(defn cetl-file-properties\n  [x]\n  (let [file (File. (:path x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time (.lastModified file)]\n    modified-time))&quot; &quot;(defmethod cetl-file-list :dirs\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command  \&quot; find `pwd` -type d -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (clojure.set/rename-keys\n      (assoc path :value\n                  (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str move-to-dir (:path path)\n                                next-command\n                                command))\n                         :out) #\&quot;\\n\&quot;))\n      {:list :exec})))&quot; &quot;(defn cetl-file-properties\n  [x]\n  (let [file (File. (:path x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time (.lastModified file)\n        modified-str (.SimpleDateFormat \&quot;MM/dd/yyyy HH:mm:ss\&quot;)]))&quot; &quot;(defn cetl-file-properties\n  [x]\n  (let [file (File. (:path x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time (.lastModified file)\n        modified-str (.format SimpleDateFormat. \&quot;MM/dd/yyyy HH:mm:ss\&quot;)]))&quot; &quot;(defn cetl-file-properties\n  [x]\n  (let [file (File. (:path x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time (.lastModified file)\n        modified-str (.format (SimpleDateFormat. \&quot;MM/dd/yyyy HH:mm:ss\&quot;))]))&quot; &quot;(defn cetl-file-properties\n  [x]\n  (let [file (File. (:path x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time (.lastModified file)\n        modified-str ((.format modified-time) (SimpleDateFormat. \&quot;MM/dd/yyyy HH:mm:ss\&quot;))]\n    modified-str))&quot; &quot;(defn cetl-file-properties\n  [x]\n  (let [file (File. (:path x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time (.lastModified file)\n        modified-str (.format (SimpleDateFormat. \&quot;MM/dd/yyyy HH:mm:ss\&quot;) modified-time)]\n    modified-str))&quot; &quot;(defn cetl-file-properties\n  [x]\n  (let [file (File. (:path x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time (.lastModified file)\n        modified-str (.format (SimpleDateFormat. \&quot;MM/dd/yyyy HH:mm:ss.SSS\&quot;) modified-time)]\n    modified-str))&quot; &quot;(defn cetl-file-properties\n  [x]\n  (let [file (File. (:path x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time (.lastModified file)\n        modified-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time)]\n    modified-str))&quot; &quot;(cetl-file-properties {:path \&quot;/Users/gregadebesin/Development/Cetl/archive.zip\&quot;})&quot; &quot;(defn cetl-file-properties\n  [x]\n  (let [file (File. (:path x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)]\n    modified-str))&quot; &quot;(cetl-file-encode {:path \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file.txt\&quot;\n                   :encode :UTF-8})&quot; &quot;(defmethod cetl-file-archive :zip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        get-path (:path path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir (.getParent (File. get-path)) next-command\n           zip-command (-&gt; (s/split get-path #\&quot;/\&quot;) last) file-ext\n           rec-command (-&gt; (s/split get-path #\&quot;/\&quot;) last)))\n    (clojure.set/rename-keys (assoc path :path (str (:path path) file-ext)))))&quot; &quot;(cetl-file-list {:path \&quot;/Users/gregadebesin/Development\&quot;\n                 :list :dirs-and-files})&quot; &quot;(defmethod cetl-file-archive :zip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        get-path (:path path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir (.getParent (File. get-path)) next-command\n           zip-command (-&gt; (s/split get-path #\&quot;/\&quot;) last) file-ext\n           rec-command (-&gt; (s/split get-path #\&quot;/\&quot;) last)))\n    (assoc path :path (str (:path path) file-ext))))&quot; &quot;(defmethod cetl-file-archive :zip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        get-path (:path path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir (.getParent (File. get-path)) next-command\n           zip-command (-&gt; (s/split get-path #\&quot;/\&quot;) last) file-ext\n           rec-command (-&gt; (s/split get-path #\&quot;/\&quot;) last)))\n    (clojure.set/rename-keys\n      (assoc path :path (str (:path path) file-ext))\n      {:archive :exec})\n    ))&quot; &quot;(defmethod cetl-file-archive :zip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        get-path (:path path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir (.getParent (File. get-path)) next-command\n           zip-command (-&gt; (s/split get-path #\&quot;/\&quot;) last) file-ext\n           rec-command (-&gt; (s/split get-path #\&quot;/\&quot;) last)))\n    (clojure.set/rename-keys\n      (assoc path :value (into [] (str (:path path) file-ext)))\n      {:archive :exec})))&quot; &quot;(defmethod cetl-file-archive :zip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        get-path (:path path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir (.getParent (File. get-path)) next-command\n           zip-command (-&gt; (s/split get-path #\&quot;/\&quot;) last) file-ext\n           rec-command (-&gt; (s/split get-path #\&quot;/\&quot;) last)))\n    (clojure.set/rename-keys\n      (assoc path :value (vec (str (:path path) file-ext)))\n      {:archive :exec})))&quot; &quot;(defmethod cetl-file-archive :zip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        get-path (:path path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir (.getParent (File. get-path)) next-command\n           zip-command (-&gt; (s/split get-path #\&quot;/\&quot;) last) file-ext\n           rec-command (-&gt; (s/split get-path #\&quot;/\&quot;) last)))\n    (clojure.set/rename-keys\n      (assoc path :value (str (:path path) file-ext))\n      {:archive :exec})))&quot; &quot;(vec \&quot;cdcascascs\&quot;)&quot; &quot;(vector \&quot;cdcascascs\&quot;)&quot; &quot;(defmethod cetl-file-archive :zip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        get-path (:path path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir (.getParent (File. get-path)) next-command\n           zip-command (-&gt; (s/split get-path #\&quot;/\&quot;) last) file-ext\n           rec-command (-&gt; (s/split get-path #\&quot;/\&quot;) last)))\n    (clojure.set/rename-keys\n      (assoc path :value (vector (str (:path path) file-ext)))\n      {:archive :exec})))&quot; &quot;(defmethod cetl-file-archive :gzip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        gzip-command \&quot; tar -cvzf \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.tar.gz \&quot;\n        get-path (:path path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir (.getParent (File. get-path)) next-command\n           gzip-command (-&gt; (s/split get-path #\&quot;/\&quot;) last) file-ext\n           (-&gt; (s/split get-path #\&quot;/\&quot;) last)))\n    (clojure.set/rename-keys\n      (assoc path :path (vector (str (:path path) file-ext)))\n      {:archive :exec})))&quot; &quot;(defmethod cetl-file-archive :gzip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        gzip-command \&quot; tar -cvzf \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.tar.gz \&quot;\n        get-path (:path path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir (.getParent (File. get-path)) next-command\n           gzip-command (-&gt; (s/split get-path #\&quot;/\&quot;) last) file-ext\n           (-&gt; (s/split get-path #\&quot;/\&quot;) last)))\n    (clojure.set/rename-keys\n      (assoc path :value (vector (str (:path path) file-ext)))\n      {:archive :exec})))&quot; &quot;(defmethod cetl-file-archive :zip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        get-path (:path path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir (.getParent (File. get-path)) next-command\n           zip-command (-&gt; (s/split get-path #\&quot;/\&quot;) last) file-ext\n           rec-command (-&gt; (s/split get-path #\&quot;/\&quot;) last)))\n    (clojure.set/rename-keys\n      (assoc path :value\n                  (vector (str (:path path) file-ext)))\n      {:archive :exec})))&quot; &quot;(cetl-file-archive {:path \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file.txt\&quot;\n                    :archive :gzip})&quot; &quot;(cetl-file-archive {:path \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file.txt\&quot;\n                    :archive :zip})&quot; &quot;(defmethod cetl-file-archive :zip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        get-path (:path path)\n        file-name (:file path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir (.getParent (File. get-path)) next-command\n           zip-command file-name file-ext\n           rec-command file-name))\n    (clojure.set/rename-keys\n      (assoc path :value\n                  (vector (str (:path path) file-ext)))\n      {:archive :exec})))&quot; &quot;(cetl-file-archive {:path \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/\&quot;\n                    :archive :zip\n                    :file \&quot;test-files.txt\&quot;})&quot; &quot;(defmethod cetl-file-archive :zip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        get-path (:path path)\n        file-name (:file path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir (.getParent (File. get-path)) next-command\n           zip-command file-name file-ext\n           rec-command file-name))\n    (clojure.set/rename-keys\n      (assoc path :value\n                  (vector (str (:path path) \&quot;/\&quot; (:file path) file-ext)))\n      {:archive :exec})))&quot; &quot;(cetl-file-archive {:path \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources\&quot;\n                    :archive :zip\n                    :file \&quot;test-files.txt\&quot;})&quot; &quot;(cetl-file-archive {:path \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/\&quot;\n                    :archive :zip\n                    :file \&quot;test-file.txt\&quot;})&quot; &quot;(defmethod cetl-file-archive :zip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        get-path (:path path)\n        file-name (:file path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir (.getParent (File. get-path)) next-command\n           zip-command (str file-name file-ext)\n           rec-command file-name))\n    (clojure.set/rename-keys\n      (assoc path :value\n                  (vector (str (:path path) \&quot;/\&quot; (:file path) file-ext)))\n      {:archive :exec})))&quot; &quot;(.getParent (File. \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources\&quot;)&quot; &quot;(.getParent (File. \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources\&quot;))&quot; &quot;(cetl-file-archive {:path \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources\&quot;\n                    :archive :zip\n                    :file \&quot;test-file.txt\&quot;})&quot; &quot;(defmethod cetl-file-archive :zip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        get-path (:path path)\n        file-name (:file path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir (File. get-path) next-command\n           zip-command (str file-name file-ext)\n           rec-command file-name))\n    (clojure.set/rename-keys\n      (assoc path :value\n                  (vector (str (:path path) \&quot;/\&quot; (:file path) file-ext)))\n      {:archive :exec})))&quot; &quot;(defmethod cetl-file-archive :gzip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        gzip-command \&quot; tar -cvzf \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.tar.gz\&quot;\n        get-path (:path path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir (.getParent (File. get-path)) next-command\n           gzip-command (-&gt; (s/split get-path #\&quot;/\&quot;) last) file-ext\n           (-&gt; (s/split get-path #\&quot;/\&quot;) last)))\n    (clojure.set/rename-keys\n      (assoc path :value (vector (str (:path path) file-ext)))\n      {:archive :exec})))&quot; &quot;(defmethod cetl-file-archive :gzip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        gzip-command \&quot; tar -cvzf \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.tar.gz\&quot;\n        get-path (:path path)\n        file-name (:file path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir  (File. get-path) next-command\n           gzip-command (str file-name file-ext)\n           (-&gt; (s/split get-path #\&quot;/\&quot;) last)))\n    (clojure.set/rename-keys\n      (assoc path :value (vector (str (:path path) \&quot;/\&quot; (:file path) file-ext)))\n      {:archive :exec})))&quot; &quot;(defmethod cetl-file-archive :gzip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        gzip-command \&quot; tar -cvzf \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.tar.gz\&quot;\n        get-path (:path path)\n        file-name (:file path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir  (File. get-path) next-command\n           gzip-command (str file-name file-ext)\n           file-name))\n    (clojure.set/rename-keys\n      (assoc path :value \n                  (vector (str (:path path) \&quot;/\&quot; (:file path) file-ext)))\n      {:archive :exec})))&quot; &quot;(defmethod cetl-file-archive :gzip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        gzip-command \&quot; tar -cvzf \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.tar.gz\&quot;\n        get-path (:path path)\n        file-name (:file path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir  (File. get-path) next-command\n           gzip-command (str file-name file-ext)\n           \&quot; \&quot; file-name))\n    (clojure.set/rename-keys\n      (assoc path :value \n                  (vector (str (:path path) \&quot;/\&quot; (:file path) file-ext)))\n      {:archive :exec})))&quot; &quot;(defmethod cetl-file-archive :gzip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        gzip-command \&quot; tar -cvzf \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.tar.gz\&quot;\n        get-path (:path path)\n        file-name (:file path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir  (File. get-path) next-command\n           gzip-command (str file-name file-ext file-name)))\n    (clojure.set/rename-keys\n      (assoc path :value \n                  (vector (str (:path path) \&quot;/\&quot; (:file path) file-ext)))\n      {:archive :exec})))&quot; &quot;(defmethod cetl-file-archive :gzip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        gzip-command \&quot; tar -cvzf \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.tar.gz\&quot;\n        get-path (:path path)\n        file-name (:file path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir  (File. get-path) next-command\n           gzip-command (str file-name file-ext\&quot; \&quot;file-name)))\n    (clojure.set/rename-keys\n      (assoc path :value \n                  (vector (str (:path path) \&quot;/\&quot; (:file path) file-ext)))\n      {:archive :exec})))&quot; &quot;(cetl-file-archive {:path \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources\&quot;\n                    :archive :gzip\n                    :file \&quot;test-file.txt\&quot;})&quot; &quot;(+ 22)&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io])\n  (:import (org.apache.commons.io FileUtils)\n           (java.io File)\n           (java.text SimpleDateFormat)))&quot; &quot;(defmulti cetl-file-list (fn [x] (:list x)))&quot; &quot;(defmethod cetl-file-list :dirs-and-files\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command \&quot; find `pwd` -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (clojure.set/rename-keys\n      (assoc path :value\n                  (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str move-to-dir (:path path)\n                                next-command\n                                command))\n                         :out) #\&quot;\\n\&quot;))\n      {:list :exec})))&quot; &quot;(cetl-file-list {:path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                 :list :dirs-and-files})&quot; &quot;(defmethod cetl-file-archive :zip\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        get-path (:path path)\n        file-name (:file path)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir (File. get-path) next-command\n           zip-command (str file-name file-ext)\n           rec-command file-name))\n    (clojure.set/rename-keys\n      (assoc path :value\n                  (vector\n                    (str (:path path) \&quot;/\&quot; (:file path) file-ext)))\n      {:archive :exec})))&quot; &quot;(cetl-file-archive {:path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                    :file \&quot;archive\&quot;\n                    :archive :zip})&quot; &quot;(defmulti cetl-file-encode (fn [x] (:encode x)))&quot; &quot;(defmethod cetl-file-encode :UTF-8\n  [x]\n  (FileUtils/write\n     (File. (:path x))\n     (FileUtils/readFileToString\n       (File.\n         (:path x)) \&quot;ISO-8859-1\&quot;)\n     (name (:encode x))) x)&quot; &quot;2&quot; &quot;(map inc [])&quot; &quot;1&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.io File)\n           (java.text SimpleDateFormat)))&quot; &quot;(use '[clojure.java.shell :only [sh]])&quot; &quot;(defn cetl-file-temp-create\n  [x]\n  (io/writer\n    (io/file\n      (str (:path x) \&quot;/\&quot; (:file-name x)))))&quot; &quot;(cetl-file-temp-create {:path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                        :file-name \&quot;foo.temp\&quot;})&quot; &quot;(defn cetl-file-temp-create\n  ([x &amp; {:keys [temp-create]}]\n   (let [file (:file x)\n         path (:path x)]\n     (io/writer\n       (io/file\n         (str path \&quot;/\&quot; file))))))&quot; &quot;(defn cetl-file-temp-create\n  [x]\n  (let [file (:file x)\n        path (:path x)]\n    (io/writer\n      (io/file\n        (str path \&quot;/\&quot; file)))))&quot; &quot;(cetl-file-temp-create {:path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                        :file-name \&quot;foo1.temp\&quot;\n                        :temp-create :temp-file})&quot; &quot;(cetl-file-temp-create {:path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                        :file-name \&quot;foo1.tmp\&quot;})&quot; &quot;(cetl-file-temp-create {:path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                        :file\&quot;foo.temp\&quot;})&quot; &quot;(defn cetl-file-temp-create\n  ([x &amp; {:keys [temp-create]}]\n   (let [file (:file x)\n         path (:path x)]\n     (if (= temp-create :temp-file)\n       (io/writer\n         (io/file\n           (str path \&quot;/\&quot; file)))))))&quot; &quot;(defn cetl-file-temp-create\n  ([x &amp; {:keys [temp-create]}]\n   (let [file (:file x)\n         path (:path x)]\n     (if (= temp-create :temp-file)\n       (io/writer\n         (io/file\n           (str path \&quot;/\&quot; file)))))\n    temp-create))&quot; &quot;(defn cetl-file-temp-create\n  [x &amp; {:keys [temp-create]}]\n  (let [file (:file x)\n        path (:path x)]\n    (println temp-create)\n    (io/writer\n      (io/file\n        (str path \&quot;/\&quot; file)))))&quot; &quot;(cetl-file-temp-create {:path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                        :file\&quot;foo.temp\&quot;\n                        :temp-create nil})&quot; &quot;(defn cetl-file-temp-create\n  [x &amp; {:keys [temp-create]}]\n  (let [file (:file x)\n        path (:path x)]\n    (if (= temp-create true)\n      (io/writer\n        (io/file\n          (str path \&quot;/\&quot; file))))))&quot; &quot;(cetl-file-temp-create {:path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                        :file\&quot;foo.temp\&quot;\n                        :temp-create true})&quot; &quot;(defn foo \n  [x &amp; {:keys [tester]}]\n  )&quot; &quot;(defn cetl-file-temp-create\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:temp-create x)]\n    (if (= :temp-create exec)\n      (io/writer\n        (io/file\n          (str path \&quot;/\&quot; file))))))&quot; &quot;(cetl-file-temp-create {:path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                        :file\&quot;foo.temp\&quot;\n                        :temp-create :temp-file})&quot; &quot;(defn cetl-file-temp-create\n  [x &amp; {:keys [temp-create]}]\n  (let [file (:file x)\n        path (:path x)]\n    (if (= temp-create :temp-file)\n      (io/writer\n        (io/file\n          (str path \&quot;/\&quot; file))))))&quot; &quot;(cetl-file-temp-create {:path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                        :file\&quot;foo2.temp\&quot;\n                        :temp-create :temp-file})&quot; &quot;(defn cetl-file-temp-create\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:temp-create x)]\n    (if (= :temp-file exec)\n      (io/writer\n        (io/file\n          (str path \&quot;/\&quot; file))))))&quot; &quot;(defn cetl-file-copy\n  [x]\n  (io/copy\n    (io/file (:in-file-path x))\n    (io/file (:out-file-path x))))&quot; &quot;(defn cetl-file-temp-create\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:temp-create x)]\n    (if (= exec :temp-file)\n      (io/writer\n        (io/file\n          (str path \&quot;/\&quot; file))))))&quot; &quot;(defn cetl-file-copy\n  [x]\n  (let [file (:file x)\n        in-path (:in-file-path x)\n        out-path (:out-file-path x)\n        exec (:file-copy x)]\n    (if (= exec :copy-file)\n      (io/copy\n        (io/file (str in-path \&quot;/\&quot; file))\n        (io/file (str out-path \&quot;/\&quot;file))))))&quot; &quot;(defn cetl-file-copy\n  [x]\n  (let [file (:file x)\n        in-path (:in-path x)\n        out-path (:out-path x)\n        exec (:file-copy x)]\n    (if (= exec :copy-file)\n      (io/copy\n        (io/file (str in-path \&quot;/\&quot; file))\n        (io/file (str out-path \&quot;/\&quot;file))))))&quot; &quot;(cetl-file-copy {:file \&quot;foo.temp\&quot;\n                 :in-path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                 :out-path \&quot;/Users/gregadebesin/Development\&quot;\n                 :file-copy :copy-file})&quot; &quot;(defn cetl-file-copy\n  [x]\n  (let [file (:file x)\n        in-path (:in-path x)\n        out-path (:out-path x)\n        exec (:copy x)]\n    (if (= exec :copy-file)\n      (io/copy\n        (io/file (str in-path \&quot;/\&quot; file))\n        (io/file (str out-path \&quot;/\&quot;file))))))&quot; &quot;(defn cetl-file-delete\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:file-delete x)]\n    (if (= exec :delete-file))\n    (io/delete-file\n      (io/file\n        (str (:path x) \&quot;/\&quot; (:file-name x))))))&quot; &quot;(defn cetl-file-temp-create\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:create x)]\n    (if (= exec :file)\n      (io/writer\n        (io/file\n          (str path \&quot;/\&quot; file))))))&quot; &quot;(defn cetl-file-temp-create\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:create x)]\n    (if (= exec :temp-file)\n      (io/writer\n        (io/file\n          (str path \&quot;/\&quot; file))))))&quot; &quot;(defn cetl-file-delete\n  [x]\n  (io/delete-file\n    (io/file\n      (str (:path x) \&quot;/\&quot; (:file-name x)))))&quot; &quot;(defn cetl-file-copy\n  [x]\n  (let [file (:file x)\n        in-path (:in-path x)\n        out-path (:out-path x)\n        exec (:copy x)]\n    (if (= exec :file)\n      (io/copy\n        (io/file (str in-path \&quot;/\&quot; file))\n        (io/file (str out-path \&quot;/\&quot;file))))))&quot; &quot;(cetl-file-copy {:file \&quot;foo22.temp\&quot;\n                 :in-path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                 :out-path \&quot;/Users/gregadebesin/Development\&quot;\n                 :copy :file})&quot; &quot;(cetl-file-copy {:file \&quot;foo.temp\&quot;\n                 :in-path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                 :out-path \&quot;/Users/gregadebesin/Development\&quot;\n                 :copy :file})&quot; &quot;(defn cetl-file-delete\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:delete x)]\n    (if (= exec :file)\n      (io/delete-file\n        (io/file\n          (str path \&quot;/\&quot; file))))))&quot; &quot;(cetl-file-delete{:file \&quot;archive.zip\&quot;\n                 :path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                 :delete :file})&quot; &quot;(cetl-file-delete{:file \&quot;foo.temp\&quot;\n                 :path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                 :delete :file})&quot;], :remote []}}</component>
</project>