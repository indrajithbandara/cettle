<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1451260016436">{:repl-history {:ide [], :local [&quot;(file-exists? [2])&quot; &quot;(file-exists? 2)&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (fileName [^File file] (.getName file))\n  (parentPath [^File file] (.getParent file))\n  (isFile? [^File file] (.isFile file))\n  (isDir? [^File file] (.isDirectory file))\n  (absFilePath [^File file] (.getAbsolutePath file))\n  (absFile [^File file] (.getAbsoluteFile file))\n  (fileExists? [^File file] (.exists file))\n  (canonicalPath [^File file] (.getCanonicalPath file))\n  String\n  (fileExists? [^String file p] (.toUpperCase file)))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (fileName [^File file] (.getName file))\n  (parentPath [^File file] (.getParent file))\n  (isFile? [^File file] (.isFile file))\n  (isDir? [^File file] (.isDirectory file))\n  (absFilePath [^File file] (.getAbsolutePath file))\n  (absFile [^File file] (.getAbsoluteFile file))\n  (fileExists? [^File file] (.exists file))\n  (canonicalPath [^File file p] (.getCanonicalPath file))\n  String\n  (fileExists? [^String file p] (.toUpperCase file)))&quot; &quot;(file-exists? (String.) \&quot;dddd\&quot;)&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (fileName [^File file] (.getName file))\n  (parentPath [^File file] (.getParent file))\n  (isFile? [^File file] (.isFile file))\n  (isDir? [^File file] (.isDirectory file))\n  (absFilePath [^File file] (.getAbsolutePath file))\n  (absFile [^File file] (.getAbsoluteFile file))\n  (fileExists? [^File file] (.exists file))\n  (canonicalPath [^File file] (.getCanonicalPath file))\n  String\n  (fileExists? [^String] (.toUpperCase file)))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (fileName [^File file] (.getName file))\n  (parentPath [^File file] (.getParent file))\n  (isFile? [^File file] (.isFile file))\n  (isDir? [^File file] (.isDirectory file))\n  (absFilePath [^File file] (.getAbsolutePath file))\n  (absFile [^File file] (.getAbsoluteFile file))\n  (fileExists? [^File file] (.exists file))\n  (canonicalPath [^File file] (.getCanonicalPath file))\n  String\n  (fileExists? [^String file] (.toUpperCase file)))&quot; &quot;(file-exists? String. \&quot;dddd\&quot;)&quot; &quot;(file-exists? (String. \&quot;dddd\&quot;))&quot; &quot;(file-exists? (File. \&quot;dddd\&quot;))&quot; &quot;(defn file-exists?\n  ([] nil)\n  ([x] (fnil (fileExists? x) \&quot;fds\&quot;)))&quot; &quot;(fnil (fn [] nil) \&quot;\&quot;)&quot; &quot;(file-exists? nil)&quot; &quot;(defn file-exists?\n  ([] nil)\n  ([x] (fileExists? x)))&quot; &quot;(defn file-exists?\n  ([] nil)\n  ([x] (fileExists? (io/file x))))&quot; &quot;(defn file-exists-itr\n  [x]\n  (map (fn [y]\n      (fileExists? y)) x))&quot; &quot;(defn parent-path\n  ([] nil)\n  ([x] (parentPath (io/file x))))&quot; &quot;(defn file-name\n  ([] nil)\n  ([x] (fileName (io/file x))))&quot; &quot;(defn cetl-zip-file [x]\n  [x]\n  (cond (nil? x) nil\n        (nil? (some false?\n                    (map #(file-exists? %) (path-from-map x))))\n        (let [path (path-from-map x)]\n          (map (fn [y] (clojure.java.shell/sh\n                         \&quot;sh\&quot; \&quot;-c\&quot;\n                         (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                              \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                              \&quot; -r \&quot; (file-name y)))) path))\n        :else \&quot;poo\&quot;))&quot; &quot;(defn cetl-zip-file [x]\n  [x]\n  (cond (nil? x) nil\n        (nil? (some false? (map #(file-exists? %) (path-from-map x))))\n        (let [path (path-from-map x)]\n          (map (fn [y] (clojure.java.shell/sh\n                         \&quot;sh\&quot; \&quot;-c\&quot;\n                         y))\n               (map (fn [z]\n                      (str \&quot; cd \&quot; (parent-path z) \&quot;;\&quot;\n                           \&quot; zip \&quot; (file-name z) \&quot;.zip\&quot;\n                           \&quot; -r \&quot; (file-name z))) path)))\n        :else \&quot;poo\&quot;))&quot; &quot;(defn cetl-zip-file [x]\n  [x]\n  (cond (nil? x) nil\n        (nil? (some false?\n                    (map #(file-exists? %) (path-from-map x))))\n        (map (fn [y] (clojure.java.shell/sh\n                       \&quot;sh\&quot; \&quot;-c\&quot;\n                       (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                            \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                            \&quot; -r \&quot; (file-name y)))) (path-from-map x))\n        :else \&quot;poo\&quot;))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (nil? (some false?\n                     (map #(file-exists? %) (path-from-map x))))\n         (map (fn [y] (clojure.java.shell/sh\n                        \&quot;sh\&quot; \&quot;-c\&quot;\n                        (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                             \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                             \&quot; -r \&quot; (file-name y))))\n              (path-from-map x))\n         :else \&quot;poo\&quot;)))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (nil? (some false?\n                     (map #(file-exists? %) (path-from-map x))))\n         (map (fn [y] (clojure.java.shell/sh\n                        \&quot;sh\&quot; \&quot;-c\&quot;\n                        (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                             \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                             \&quot; -r \&quot; (file-name y))))\n              (path-from-map x)))))&quot; &quot;(cetl-zip-file)&quot; &quot;(cetl-zip-file nil)&quot; &quot;(cetl-zip-file {:path [2]})&quot; &quot;(cetl-zip-file {:path [\&quot;/Users/gra11/Development/ile.txt\&quot; \&quot;/Users/gra11/Development/file2.txt\&quot;]})&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exists? x)\n         (map (fn [y] (clojure.java.shell/sh\n                        \&quot;sh\&quot; \&quot;-c\&quot;\n                        (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                             \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                             \&quot; -r \&quot; (file-name y))))\n              (path-from-map x)))))&quot; &quot;(defn check-files-exist\n  ([] nil)\n  ([x] (nil? (some false?\n                    (map #(file-exists? %) (path-from-map x))))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exists x)\n         (map (fn [y] (clojure.java.shell/sh\n                        \&quot;sh\&quot; \&quot;-c\&quot;\n                        (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                             \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                             \&quot; -r \&quot; (file-name y))))\n              (path-from-map x)))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (map (fn [y] (clojure.java.shell/sh\n                        \&quot;sh\&quot; \&quot;-c\&quot;\n                        (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                             \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                             \&quot; -r \&quot; (file-name y))))\n              (path-from-map x)))))&quot; &quot;(check-files-exist)&quot; &quot;(check-files-exist {:path [\&quot;/Users/gra11\&quot;]})&quot; &quot;(check-files-exist {:path [\&quot;/Users/gra1\&quot;]})&quot; &quot;(check-files-exist {:path [\&quot;/Users/gra11\&quot; \&quot;/Users\&quot;]})&quot; &quot;(cetl-zip-file {:path [\&quot;/Users/gra11/Development/file.txt\&quot; \&quot;/Users/gra11/Development/file2.tt\&quot;]})&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (let [path (path-from-map x)]\n           (do\n             (map (fn [y] (clojure.java.shell/sh\n                            \&quot;sh\&quot; \&quot;-c\&quot;\n                            (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                                 \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                                 \&quot; -r \&quot; (file-name y)))) path)\n             {:path (map #(str % \&quot;.zip\&quot;) path)})))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (let [path (path-from-map x)]\n           (map (fn [y] (clojure.java.shell/sh\n                          \&quot;sh\&quot; \&quot;-c\&quot;\n                          (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                               \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                               \&quot; -r \&quot; (file-name y)))) path)\n           {:path (map #(str % \&quot;.zip\&quot;) path)}\n           ))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (map (fn [y] (clojure.java.shell/sh\n                        \&quot;sh\&quot; \&quot;-c\&quot;\n                        (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                             \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                             \&quot; -r \&quot; (file-name y)))) (path-from-map x))\n         )))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (map (fn [y] (clojure.java.shell/sh\n                        \&quot;sh\&quot; \&quot;-c\&quot;\n                        (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                             \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                             \&quot; -r \&quot; (file-name y)))) (path-from-map x)) {})))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (if (nil? x) nil\n         (check-files-exist x)\n         (map (fn [y] (clojure.java.shell/sh\n                        \&quot;sh\&quot; \&quot;-c\&quot;\n                        (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                             \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                             \&quot; -r \&quot; (file-name y)))) (path-from-map x)))))&quot; &quot;(check-files-exist {:path [\&quot;/Users\&quot;]})&quot; &quot;(check-files-exist {:path [\&quot;/User\&quot;]})&quot; &quot;(check-files-exist {:path [\&quot;/User\&quot; \&quot;\&quot;]})&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (if (false? (check-file-exists x)) nil\n         (map (fn [y] (clojure.java.shell/sh\n                        \&quot;sh\&quot; \&quot;-c\&quot;\n                        (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                             \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                             \&quot; -r \&quot; (file-name y)))) (path-from-map x)))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (if (false? (check-files-exist x)) nil\n         (map (fn [y] (clojure.java.shell/sh\n                        \&quot;sh\&quot; \&quot;-c\&quot;\n                        (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                             \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                             \&quot; -r \&quot; (file-name y)))) (path-from-map x)))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (if (false? (check-files-exist x)) \n     nil \n     (do \n       (map (fn [y] (clojure.java.shell/sh \n                      \&quot;sh\&quot; \&quot;-c\&quot; \n                      (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot; \n                           \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot; \n                           \&quot; -r \&quot; (file-name y)))) (path-from-map x))))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (if (false? (check-files-exist x))\n     nil\n     (do\n       (map (fn [y] (clojure.java.shell/sh\n                      \&quot;sh\&quot; \&quot;-c\&quot;\n                      (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                           \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                           \&quot; -r \&quot; (file-name y)))) (path-from-map x))\n       {}))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (if (false? (check-files-exist x))\n     nil\n     (do\n       (map (fn [y] (clojure.java.shell/sh\n                      \&quot;sh\&quot; \&quot;-c\&quot;\n                      (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                           \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                           \&quot; -r \&quot; (file-name y)))) (path-from-map x))\n       (into [] \&quot;\&quot;)))))&quot; &quot;()&quot; &quot;(cetl-zip-file {:path [\&quot;/Users/gra11/Development/file.txt\&quot; \&quot;/Users/gra11/Development/file2.txt\&quot;]})&quot; &quot;(defn cetl-gzip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (file-exists? (path-from-map x))\n         (let [path (path-from-map x)\n               file-path (parent-path path)\n               file-name (file-name path)]\n           (do\n             (clojure.java.shell/sh\n               \&quot;sh\&quot; \&quot;-c\&quot;\n               (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                    \&quot; tar -cvzf \&quot; (str file-name \&quot;.tar.gz \&quot; file-name)))\n             (assoc x\n               :path [(str path \&quot;.tar.gz\&quot;)]\n               :exec :cetl-gzip-file))))))&quot; &quot;(ns cetl.utils.file\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io])\n  (import [java.io File]))&quot; &quot;(defprotocol FileLike\n  (fileName [x] \&quot;Returns file name of a given input\&quot;)\n  (parentPath [x] \&quot;Returns the directory name of a given input\&quot;)\n  (isFile? [x] \&quot;Returns file name of a given input\&quot;)\n  (fileExists? [f] \&quot;Returns file name of a given input\&quot;)\n  (isDir? [x] \&quot;Returns file name of a given input\&quot;)\n  (canonicalPath [x] \&quot;Returns the file path of a given input\&quot;)\n  (absFilePath [x] \&quot;Returns the absolute file path of a given input\&quot;)\n  (absFile [x] \&quot;Returns the absolute file of a given input\&quot;))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (fileName [^File file] (.getName file))\n  (parentPath [^File file] (.getParent file))\n  (isFile? [^File file] (.isFile file))\n  (isDir? [^File file] (.isDirectory file))\n  (absFilePath [^File file] (.getAbsolutePath file))\n  (absFile [^File file] (.getAbsoluteFile file))\n  (fileExists? [^File file] (.exists file))\n  (canonicalPath [^File file] (.getCanonicalPath file)))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.file :refer [file-exists? file-name path-from-map parent-path is-dir?]])\n  (:import (java.io File LineNumberReader)\n           (java.text SimpleDateFormat)))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.file :refer [file-exists? file-name path-from-map parent-path]])\n  (:import (java.io File LineNumberReader)\n           (java.text SimpleDateFormat)))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.file :refer [file-exists? file-name path-from-map is-dir? parent-path]])\n  (:import (java.io File LineNumberReader)\n           (java.text SimpleDateFormat)))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.file :refer [file-exists? file-name path-from-map isDir? parent-path]])\n  (:import (java.io File LineNumberReader)\n           (java.text SimpleDateFormat)))&quot; &quot;(defn check-files-exist\n  ([] nil)\n  ([x] (nil? (some false?\n                   (map #(file-exists? %) (path-from-map x))))))&quot; &quot;(doall (map inc (range 1 20)) {})&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (doall\n           (map (fn [y] (clojure.java.shell/sh\n                          \&quot;sh\&quot; \&quot;-c\&quot;\n                          (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                               \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                               \&quot; -r \&quot; (file-name y)))) (path-from-map x))\n           {:path [x]}))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (doall\n           (map (fn [y] (clojure.java.shell/sh\n                          \&quot;sh\&quot; \&quot;-c\&quot;\n                          (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                               \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                               \&quot; -r \&quot; (file-name y)))) (path-from-map x) {:path [x]})))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (doall\n           (map (fn [y] (clojure.java.shell/sh\n                          \&quot;sh\&quot; \&quot;-c\&quot;\n                          (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                               \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                               \&quot; -r \&quot; (file-name y)))) (path-from-map x)) {:path [x]}))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (doall\n           (map (fn [y] (clojure.java.shell/sh\n                          \&quot;sh\&quot; \&quot;-c\&quot;\n                          (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                               \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                               \&quot; -r \&quot; (file-name y)))) (path-from-map x)) {:path 2}))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (map (fn [y] (clojure.java.shell/sh\n                        \&quot;sh\&quot; \&quot;-c\&quot;\n                        (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                             \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                             \&quot; -r \&quot; (file-name y)))) (path-from-map x))\n         {})))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (\n           (map (fn [y] (clojure.java.shell/sh\n                          \&quot;sh\&quot; \&quot;-c\&quot;\n                          (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                               \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                               \&quot; -r \&quot; (file-name y)))) (path-from-map x)) {}))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (map (fn [y] (clojure.java.shell/sh\n                        \&quot;sh\&quot; \&quot;-c\&quot;\n                        (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                             \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                             \&quot; -r \&quot; (file-name y)))) (path-from-map x)))))&quot; &quot;(do (map inc [1]) {})&quot; &quot;(do (print 2) {})&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (do\n           (map (fn [y] (clojure.java.shell/sh\n                          \&quot;sh\&quot; \&quot;-c\&quot;\n                          (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                               \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                               \&quot; -r \&quot; (file-name y)))) (path-from-map x)) {}))))&quot; &quot;(cetl-zip-file {:path [\&quot;/Users/gra11/Development/file.txt\&quot;]})&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.file :refer [file-exists? file-name path-from-map isDir? parent-path]])\n  (:import (java.io File LineNumberReader)\n           (org.apache.commons.compress.archivers.zip ZipArchiveEntry)\n           (java.text SimpleDateFormat)))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.file :refer [file-exists? file-name path-from-map isDir? parent-path]])\n  (:import (java.io File LineNumberReader)\n           (org.apache.commons.compress.archivers.zip ZipArchiveEntry)\n           (org.apache.commons.compress.archivers.zip ZipArchiveOutputStream)\n           (java.text SimpleDateFormat)))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.file :refer [file-exists? file-name path-from-map isDir? parent-path]])\n  (:import (java.io File LineNumberReader FileOutputStream)\n           (org.apache.commons.compress.archivers.zip ZipArchiveEntry)\n           (org.apache.commons.compress.archivers.zip ZipArchiveOutputStream)\n           (java.text SimpleDateFormat)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [fos (FileOutputStream. (File. \&quot;/Users/gra11/Development/file.txt\&quot;))\n        zos (ZipArchiveOutputStream. fos)]))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [fos (FileOutputStream. (File. \&quot;/Users/gra11/Development/file.txt\&quot;))\n        zos (ZipArchiveOutputStream. fos)]\n    (.putArchiveEntry zos ZipArchiveOutputStream)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [file (File.\&quot;/Users/gra11/Development/file.txt\&quot;)\n        fos (FileOutputStream. (File. file))\n        zos (ZipArchiveOutputStream. fos)]\n    (.putArchiveEntry (ZipArchiveEntry. (.getName file) (.getCanonicalPath file)) ZipArchiveOutputStream)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [file (File.\&quot;/Users/gra11/Development/file.txt\&quot;)\n        fos (FileOutputStream. (File. file))\n        zos (ZipArchiveOutputStream. fos)]\n    (.putArchiveEntry (ZipArchiveEntry. \n                        (.getName file) \n                        (.getCanonicalPath file)) ZipArchiveOutputStream)))&quot; &quot;(.getCanonicalPath (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [file (File.\&quot;/Users/gra11/Development/file.txt\&quot;)\n        fos (FileOutputStream. (File. file))\n        zos (ZipArchiveOutputStream. fos)]\n    (.putArchiveEntry (ZipArchiveEntry. \n                        file\n                        (.getCanonicalPath file)) ZipArchiveOutputStream)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [file (File.\&quot;/Users/gra11/Development/file.txt\&quot;)\n        fos (FileOutputStream. (File. file))\n        zos (ZipArchiveOutputStream. fos)]\n    (.putArchiveEntry (ZipArchiveEntry. \n                        file\n                        (.getCanonicalPath file)) zos)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [file (File.\&quot;/Users/gra11/Development/file.txt\&quot;)\n        fos (FileOutputStream. file)\n        zos (ZipArchiveOutputStream. fos)]\n    (.putArchiveEntry (ZipArchiveEntry. \n                        file\n                        (.getCanonicalPath file)) zos)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [file (File.\&quot;/Users/gra11/Development/file.txt\&quot;)\n        fos (FileOutputStream. (File. file))\n        zos (ZipArchiveOutputStream. fos)]\n    (.putArchiveEntry (ZipArchiveEntry. file (.getCanonicalPath file)) zos)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [file (File.\&quot;/Users/gra11/Development/file.txt\&quot;)\n        fos (FileOutputStream. file)\n        zos (ZipArchiveOutputStream. fos)]\n    (.putArchiveEntry (ZipArchiveEntry. file (.getCanonicalPath file)) zos)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [file (File.\&quot;/Users/gra11/Development/file.txt\&quot;)\n        fos (FileOutputStream. file)\n        zos (ZipArchiveOutputStream. fos)]\n    (.putArchiveEntry zos (ZipArchiveEntry. file (.getCanonicalPath file)))))&quot; &quot;(cetl-zip-file 3)&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [destination (File.\&quot;/Users/gra11/Development\&quot;)\n        source (File. \&quot;/Users/gra11/Development/file.txt\&quot;)\n        archive-stream (FileOutputStream. destination)]\n    (.createArchiveOutputStream ArchiveStreamFactory/ZIP archive-stream  ArchiveStreamFactory.)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [destination (File.\&quot;/Users/gra11/Development\&quot;)\n        source (File. \&quot;/Users/gra11/Development/file.txt\&quot;)\n        archive-stream (FileOutputStream. destination)]\n    (ArchiveStreamFactory/ZIP archive-stream (.createArchiveOutputStream ArchiveStreamFactory.))))&quot; &quot;.createArchiveOutputStream&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [destination (File.\&quot;/Users/gra11/Development\&quot;)\n        source (File. \&quot;/Users/gra11/Development/file.txt\&quot;)\n        archive-stream (FileOutputStream. destination)]\n    (.createArchiveOutputStream ArchiveStreamFactory/ZIP archive-stream ArchiveStreamFactory.)))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.file :refer [file-exists? file-name path-from-map isDir? parent-path]])\n  (:import (java.io File LineNumberReader FileOutputStream)\n           (org.apache.commons.compress.archivers.zip ZipArchiveEntry)\n           (org.apache.commons.compress.archivers.zip ZipArchiveOutputStream)\n           (org.apache.commons.compress.archivers ArchiveStreamFactory)\n           (java.text SimpleDateFormat)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [destination (File.\&quot;/Users/gra11/Development\&quot;)\n        source (File. \&quot;/Users/gra11/Development/file.txt\&quot;)\n        archive-stream (FileOutputStream. destination)]\n    ((.createArchiveOutputStream ArchiveStreamFactory/ZIP archive-stream) ArchiveStreamFactory.)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [destination (File.\&quot;/Users/gra11/Development\&quot;)\n        source (File. \&quot;/Users/gra11/Development/file.txt\&quot;)\n        archive-stream (FileOutputStream. destination)]\n    (doto (ArchiveStreamFactory.)\n      (.createArchiveOutputStream ArchiveStreamFactory/ZIP archive-stream))))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [destination (File.\&quot;/Users/gra11/Development\&quot;)\n        source (File. \&quot;/Users/gra11/Development/file.txt\&quot;)\n        archive-stream (FileOutputStream. destination)]\n    (.createArchiveOutputStream ArchiveStreamFactory. ArchiveStreamFactory/ZIP archive-stream)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [destination (File.\&quot;/Users/gra11/Development\&quot;)\n        source (File. \&quot;/Users/gra11/Development/file.txt\&quot;)\n        archive-stream (FileOutputStream. destination)]\n    (.createArchiveOutputStream ArchiveStreamFactory/ZIP archive-stream (ArchiveStreamFactory.))))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [destination (File.\&quot;/Users/gra11/Development\&quot;)\n        source (File. \&quot;/Users/gra11/Development/file.txt\&quot;)\n        archive-stream (FileOutputStream. destination)]\n    (.createArchiveOutputStream (ArchiveStreamFactory.) ArchiveStreamFactory/ZIP archive-stream)))&quot; &quot;(.getCanonicalFile (File. \&quot;\&quot;))&quot; &quot;(.indexOf (String.) \&quot;fee bar\&quot; \&quot;bar\&quot;)&quot; &quot;(.toUpperCase (String.) \&quot;fee bar\&quot;)&quot; &quot;(.toUpperCase String. \&quot;fee bar\&quot;)&quot;], :remote []}}</component>
</project>