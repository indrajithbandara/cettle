<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1449968865068">{:repl-history {:ide [], :local [&quot;\n(.getFileName File. \&quot;/Users/gra11/Development/file.txt\&quot;)&quot; &quot;\n(.getFileName (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(.getAbsoluteFile (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(.getName (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(defprotocol FileLike\n  [x]\n  (^String protocol-of [x]))&quot; &quot;(defprotocol FileLike\n  [x]\n  (protocol-of [x]))&quot; &quot;(defprotocol FileLike\n  (protocol-of [x]))&quot; &quot;(defprotocol FileLike\n  (^String  protocol-of [x]))&quot; &quot;(defprotocol FileLike\n  (^String  protocol-of [x] \&quot;Returns protocol of a given input\&quot;)\n  (^String  file-name-of [x] \&quot;Returns file name of a given input\&quot;))&quot; &quot;(extend-protocol\n  FileLike\n  File)&quot; &quot;(defprotocol FileLike\n  (^String  file-name-of [x] \&quot;Returns file name of a given input\&quot;))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  ())&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name-of [^File file]\n    (.getName file)))&quot; &quot;(defprotocol FileLike\n  (^String  file-name [x] \&quot;Returns file name of a given input\&quot;))&quot; &quot;(defprotocol FileLike\n  (^String  file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  is-dir? [x] \&quot;Returns file name of a given input\&quot;))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (is-file? [^File file] (.getName file)))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file?? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file)))&quot; &quot;(file-name-of (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(defprotocol FileLike\n  (^File  file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (^String  abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;))&quot; &quot;(file-name (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(defprotocol FileLike\n  (^String file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (^String  abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^String file] (.getName file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file?? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file)))&quot; &quot;(defprotocol FileLike\n  (^String  file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (^File  is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (^String  abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file?? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file)))&quot; &quot;(defprotocol FileLike\n  (^String  file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (^String  abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;))&quot; &quot;(ns cetl.utils.component-utils\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io])\n  (import [java.io File]))&quot; &quot;(defprotocol FileLike\n  (^String  file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (^Boolean  is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (^String  abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (is-file? [^Boolean file] (.isFile file))\n  (exists-file? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file)))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file)))&quot; &quot;(is-file? (File. \&quot;/Users/gra11/Development/file.tx\&quot;))&quot; &quot;(is-file? (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(defprotocol FileLike\n  (^String  file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (^Boolean is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^Boolean  is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (^String  abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;))&quot; &quot;(defprotocol FileLike\n  (^String  file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (^Boolean is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^Boolean is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (^String  abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;))&quot; &quot;(defprotocol FileLike\n  (^String  file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (^Boolean is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^Boolean is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (^String  abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;)\n  (^String  abs-file [x] \&quot;Returns the absolute file of a given input\&quot;))&quot; &quot;(defprotocol FileLike\n  (^String  file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (^Boolean is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^Boolean is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (^String  abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;)\n  (^File  abs-file [x] \&quot;Returns the absolute file of a given input\&quot;))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file))\n  (abs-file [^File file] (.getAbsolutePath file)))&quot; &quot;(abs-file (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file))\n  (abs-file [^String file] (.getAbsoluteFile file)))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file))\n  (abs-file [^File file] (.getAbsoluteFile file)))&quot; &quot;(defprotocol FileLike\n  (file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;)\n  (^String abs-file [x] \&quot;Returns the absolute file of a given input\&quot;))&quot; &quot;(abs-file  \&quot;/Users/gra11/Development/file.txt\&quot;)&quot; &quot;(defprotocol FileLike\n  (file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;)\n  (abs-file [x] \&quot;Returns the absolute file of a given input\&quot;))&quot; &quot;(io/file \&quot;Users/gra11\&quot;)&quot; &quot;(defn dir-exists?\n  [path]\n  (cond\n    (map? path)\n    (let [file (io/file (:path path))]\n      (if (and (exists-file? file) (is-dir? file))\n        path\n        (throw\n          (IllegalArgumentException.\n            (str path \&quot; is not a directory\&quot;)))))\n    (string? path)\n    (let [file (io/file path)]\n      (if (and (exists-file? file) (is-dir? file))\n        path\n        (throw\n          (IllegalArgumentException.\n            (str path \&quot; is not a directory\&quot;)))))))&quot; &quot;(defprotocol FileLike\n  (file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (dir-name [x] \&quot;Returns the directory name of a given input\&quot;)\n  (is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;)\n  (abs-file [x] \&quot;Returns the absolute file of a given input\&quot;))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (dir-name [^File file] (.getParent file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file))\n  (abs-file [^File file] (.getAbsoluteFile file)))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (dir-name [^File file] (.getParentFile file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file))\n  (abs-file [^File file] (.getAbsoluteFile file)))&quot; &quot;(dir-name (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(file-name (File. \&quot;/Users/gra11/Development\&quot;))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists?]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.util Date)\n           (java.io File LineNumberReader)\n           (java.text SimpleDateFormat)))&quot; &quot;(defn cetl-zip-file [x]\n    [x]\n    (if (file-exists? x)\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (parent-path [^File file] (.getParentFile file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file))\n  (abs-file [^File file] (.getAbsoluteFile file)))&quot; &quot;(defprotocol FileLike\n  (file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (parent-path [x] \&quot;Returns the directory name of a given input\&quot;)\n  (is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;)\n  (abs-file [x] \&quot;Returns the absolute file of a given input\&quot;))&quot; &quot;(cetl-zip-file {:path (File. \&quot;/Users/gra11/Development/file.txt\&quot;)})&quot; &quot;(defn cetl-zip-file [x]\n    [x]\n    (if (file-exists? x)\n      (let [path (:path x)\n            file-name (file-name path)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file-name \&quot;.zip\&quot; \&quot; -r \&quot; file-name))\n          (assoc x\n            :result (str path \&quot;.zip\&quot;)\n            :exec :zip-file)))))&quot; &quot;(defn cetl-zip-file [x]\n    [x]\n    (if (file-exists? x)\n      (let [path (File. (:path x))\n            file-name (file-name path)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file-name \&quot;.zip\&quot; \&quot; -r \&quot; file-name))\n          (assoc x\n            :result (str path \&quot;.zip\&quot;)\n            :exec :zip-file)))))&quot; &quot;(defn cetl-gzip-file\n    [x]\n    (if (file-exists? x)\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))))&quot; &quot;(defn cetl-gzip-file\n    [x]\n    (if (file-exists? (io/file x))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))))&quot; &quot;(defn file-exists\n  [path]\n  (cond (map? path)\n    (let [file (io/file (str (:path path) \&quot;/\&quot; (:file path)))]\n      (if (and (exists-file? file) (is-file? file))\n        path\n        (throw\n          (IllegalArgumentException.\n            (str file \&quot; is not a file\&quot;)))))\n        (string? path)\n        (let [file (io/file path)]\n          (if (and (exists-file? file) (is-file? file))\n            path\n            (throw\n              (IllegalArgumentException.\n                (str path \&quot; is not a file\&quot;)))))\n        :else nil))&quot; &quot;(defprotocol FileLike\n  (file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (parent-path [x] \&quot;Returns the directory name of a given input\&quot;)\n  (is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;)\n  (abs-file [x] \&quot;Returns the absolute file of a given input\&quot;)\n  (file-exists [x] \&quot;Returns true or false if a file exists\&quot;))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [dir-exists? file-name]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.util Date)\n           (java.io File LineNumberReader)\n           (java.text SimpleDateFormat)))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists? file-name]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.util Date)\n           (java.io File LineNumberReader)\n           (java.text SimpleDateFormat)))&quot; &quot;(use '[clojure.java.shell :only [sh]])&quot; &quot;(defn cetl-zip-file [x]\n    [x]\n    (if (file-exists? x)\n      (let [path (io/file (:path x))\n            file-name (file-name path)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file-name \&quot;.zip\&quot; \&quot; -r \&quot; file-name))\n          (assoc x\n            :result (str path \&quot;.zip\&quot;)\n            :exec :zip-file)))))&quot; &quot;(defprotocol FileLike\n  (file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (parent-path [x] \&quot;Returns the directory name of a given input\&quot;)\n  (is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;)\n  (abs-file [x] \&quot;Returns the absolute file of a given input\&quot;)\n  (file-exists? [x] \&quot;Returns true or false if a file exists\&quot;))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (parent-path [^File file] (.getParentFile file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file))\n  (abs-file [^File file] (.getAbsoluteFile file))\n  (file-exists? [^File file] (.exists file)))&quot; &quot;(defn cetl-zip-file [x]\n    [x]\n    (if (file-exists? (:file x))\n      (let [path (io/file (:path x))\n            file-name (file-name path)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file-name \&quot;.zip\&quot; \&quot; -r \&quot; file-name))\n          (assoc x\n            :result (str path \&quot;.zip\&quot;)\n            :exec :zip-file)))))&quot; &quot;(defn cetl-zip-file [x]\n    [x]\n    (if (file-exists? (:path x))\n      (let [path (io/file (:path x))\n            file-name (file-name path)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file-name \&quot;.zip\&quot; \&quot; -r \&quot; file-name))\n          (assoc x\n            :result (str path \&quot;.zip\&quot;)\n            :exec :zip-file)))))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists? file-name\n                                                path-from-map]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.util Date)\n           (java.io File LineNumberReader)\n           (java.text SimpleDateFormat)))&quot; &quot;(defn cetl-zip-file [x]\n    [x]\n    (if (file-exists? (path-from-map x))\n      (let [path (io/file (:path x))\n            file-name (file-name path)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file-name \&quot;.zip\&quot; \&quot; -r \&quot; file-name))\n          (assoc x\n            :result (str path \&quot;.zip\&quot;)\n            :exec :zip-file)))))&quot; &quot;3&quot; &quot;(defn cetl-zip-file [x]\n    [x]\n    (if (file-exists? (path-from-map x))\n      (let [path (path-from-map x)\n            file-name (file-name path)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file-name \&quot;.zip\&quot; \&quot; -r \&quot; file-name))\n          (assoc x\n            :result (str path \&quot;.zip\&quot;)\n            :exec :zip-file)))))&quot; &quot;(defn cetl-zip-file [x]\n    [x]\n    (if (file-exists? (path-from-map x))\n      (let [path (path-from-map x)\n            file-name (file-name path)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file-name \&quot;.zip\&quot; \&quot; -r \&quot; file-name))\n          (assoc x\n            :exec :zip-file)))))&quot; &quot;(cetl-zip-file {:path \&quot;/Users/gra11/Development/filetxt\&quot;})&quot; &quot;(defn cetl-zip-file [x]\n    [x]\n    (if (file-exists? (path-from-map x))\n      (let [path (path-from-map x)\n            file-name (file-name path)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file-name \&quot;.zip\&quot; \&quot; -r \&quot; file-name))\n          (assoc x\n            :path (str path \&quot;.zip\&quot;)\n            :exec :zip-file)))))&quot; &quot;(defn cetl-gzip-file\n    [x]\n    (if (file-exists? (path-from-map x))\n      (let [path (path-from-map x)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))))&quot; &quot;(defn cetl-gzip-file\n    [x]\n    (if (file-exists? (path-from-map x))\n      (let [path (path-from-map x)\n            file-name (file-name x)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file-name \&quot;.tar.gz \&quot; file-name)))\n          (assoc x\n            :result (str path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))))&quot; &quot;(defn cetl-gzip-file\n    [x]\n    (if (file-exists? (path-from-map x))\n      (let [path (path-from-map x)\n            file-name (file-name x)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file-name \&quot;.tar.gz \&quot; file-name)))\n          (assoc x\n            :path (str path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))))&quot; &quot;(defn cetl-gzip-file\n    [x]\n    (if (file-exists? (path-from-map x))\n      (let [path (path-from-map x)\n            file-name (file-name path)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file-name \&quot;.tar.gz \&quot; file-name)))\n          (assoc x\n            :path (str path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists? file-name\n                                                path-from-map abs-file-path]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.util Date)\n           (java.io File LineNumberReader)\n           (java.text SimpleDateFormat)))&quot; &quot;(defn cetl-zip-file [x]\n    [x]\n    (if (file-exists? (path-from-map x))\n      (let [path (path-from-map x)\n            file-path (abs-file-path x)\n            file-name (file-name path)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; file-path \&quot;;\&quot; \&quot; zip \&quot; file-name \&quot;.zip\&quot; \&quot; -r \&quot; file-name))\n          (assoc x\n            :path (str path \&quot;.zip\&quot;)\n            :exec :zip-file)))))&quot; &quot;(abs-file-path \&quot;/Users/gra11/Development/file.txt\&quot;)&quot; &quot;(defn cetl-zip-file [x]\n    [x]\n    (if (file-exists? (path-from-map x))\n      (let [path (path-from-map x)\n            file-path (abs-file-path path)\n            file-name (file-name path)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; file-path \&quot;;\&quot; \&quot; zip \&quot; file-name \&quot;.zip\&quot; \&quot; -r \&quot; file-name))\n          (assoc x\n            :path (str path \&quot;.zip\&quot;)\n            :exec :zip-file)))))&quot; &quot;(abs-file-path (path-from-map \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(defn path-from-map\n  [x]\n  (io/file (:path x)))&quot; &quot;(.getAbsolutePath (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(.getPath (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(.getParent (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists? file-name\n                                                path-from-map parent-path]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.util Date)\n           (java.io File LineNumberReader)\n           (java.text SimpleDateFormat)))&quot; &quot;(parent-path (io/file \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(str (parent-path (io/file \&quot;/Users/gra11/Development/file.txt\&quot;)))&quot; &quot;(file-name (io/file \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;()&quot; &quot;(cetl-zip-file {:path \&quot;/Users/gra11/Development/file.txt\&quot;})&quot; &quot;(cetl-zip-file {:path \&quot;/Users/gra11/Development/file.xt\&quot;})&quot; &quot;(cetl-gzip-file {:path \&quot;/Users/gra11/Development/file.xt\&quot;})&quot; &quot;(cetl-gzip-file {:path \&quot;/Users/gra11/Development/file.txt\&quot;})&quot; &quot;(defn cetl-zip-file [x]\n    [x]\n    (if (file-exists? (path-from-map x))\n      (let [path (path-from-map x)\n            file-path (parent-path path)\n            file-name (file-name path)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; file-path \&quot;;\&quot; \&quot; zip \&quot; file-name \&quot;.zip\&quot; \&quot; -r \&quot; file-name))\n          (assoc x\n            :path (str path \&quot;.zip\&quot;)\n            :exec :zip-file)))))&quot; &quot;(defn cetl-gzip-file\n    [x]\n    (if (file-exists? (path-from-map x))\n      (let [path (path-from-map x)\n            file-path (parent-path path)\n            file-name (file-name path)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file-name \&quot;.tar.gz \&quot; file-name)))\n          (assoc x\n            :path (str path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))))&quot; &quot;(if-let [x  (file-exists? (path-from-map x))]\n  x)&quot; &quot;(if-let [x  (file-exists? (path-from-map {:path \&quot;/Users/gra11/Development/file.txt\&quot;}))]\n  x)&quot;], :remote []}}</component>
</project>