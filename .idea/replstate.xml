<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1448402907434">{:repl-history {:ide [], :local [&quot;(defmethod cetl-delete-file :delete-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (io/delete-file\n          (io/file\n            (str path \&quot;/\&quot; file)))\n        (assoc x\n          :result (str (:path x) \&quot;/\&quot; (:file x))))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-properties-file :file-properties\n  [x]\n  (let [file (File. (str (:path x) \&quot;/\&quot; (:file x)))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (file-exists? (.getAbsolutePath file))\n      (do (assoc x :result {:abs-file-path abs-file-path\n                            :parent-dir parent-dir\n                            :file-name file-name\n                            :read-permissions read-permissions\n                            :write-permissions write-permissions\n                            :execute-permissions execute-permissions\n                            :file-size file-size\n                            :modified-time-millis modified-time-millis\n                            :modified-time-str modified-time-str}))\n      (throw\n        (IllegalArgumentException.\n          (str file \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(cetl-encode-file {:path \&quot;/Users/gregadebesin/Development/untitled.txt\&quot;\n                   :exec :ISO-8859-1})&quot; &quot;(cetl-copy-file {:in-path \&quot;/Users/gregadebesin/Development\&quot;\n                 :out-path \&quot;/Users/gregadebesin\&quot;\n                 :file \&quot;foo.tmp\&quot;\n                 :exec :copy-file})&quot; &quot;(defmulti cetl-file-compare {:argslist '([map])} \n          (fn [x] (:exec x)))&quot; &quot;(defmulti cetl-properties-file {:arglists '([map])} \n          (fn [x] (:exec x)))&quot; &quot;(defmulti cetl-delete-file {:arglists '([map])} \n          (fn [x] (:exec x)))&quot; &quot;(defmulti cetl-copy-file {:arglists '([map])} \n          (fn [x] (:exec x)))&quot; &quot;(defmulti cetl-create-temp-file {:arglists '([map])} \n          (fn [x] (:exec x)))&quot; &quot;(defmulti cetl-encode-file {:arglists '([map])} \n          (fn [x] (:exec x)))&quot; &quot;(defmulti cetl-archive-file  {:arglists '([map])} \n          (fn [x] (:exec x)))&quot; &quot;(defmulti cetl-list-file {:arglists '([map])} \n          (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-file-compare\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]))&quot; &quot;(defmethod cetl-file-compare\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    2))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    2))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (File. (str path \&quot;/\&quot; file))]\n    ))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (FileUtils/contentEquals file-path-one file-path-two)))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond \n      (not (file-exists? file-path-one)) \n          (throw \n            (IllegalArgumentException. \n              (str file-path-one \n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two \n                   \&quot; is not a file (or a directory)\&quot;))) \n      :else\n          (do (assoc x :result\n                     (FileUtils/contentEquals file-path-one file-path-two))))))&quot; &quot;(defmulti cetl-compare-file {:argslist '([map])}\n          (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? file-path-one))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else\n          (do (assoc x :result\n                     (FileUtils/contentEquals file-path-one file-path-two))))))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? file-path-one))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else (assoc x :result\n                    (FileUtils/contentEquals file-path-one file-path-two)))))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? file-path-one))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else \n      (FileUtils/contentEquals file-path-one file-path-two))))&quot; &quot;(symbol ddd)&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? file-path-one))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else\n      (FileUtils/contentEquals file-path-one file-path-two))))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? file-path-one))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else\n      (doto\n        (FileUtils/contentEquals file-path-one file-path-two)))))&quot; &quot;\&quot;/Users/gregadebesin/Development\&quot;&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? file-path-one))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      \n      (FileUtils/contentEquals file-path-one file-path-two))))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? file-path-one))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else  (FileUtils/contentEquals file-path-one file-path-two))))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? file-path-one))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else  (FileUtils/contentEquals  (File. \&quot;/Users/gregadebesin/Development/foo.txt\&quot;) (File. \&quot;/Users/gregadebesin/Development/bar.txt\&quot;)))))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))\n        compare-files (FileUtils/contentEquals file-path-one file-path-two)]\n    (cond\n      (not (file-exists? file-path-one))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else compare-files)))&quot; &quot;(FileUtils/contentEquals (File. \&quot;/Users/gregadebesin/Development/foo.txt\&quot;) (File. \&quot;/Users/gregadebesin/Development/bar.txt\&quot;))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? (.getName file-path-one)))\n          (throw\n            (IllegalArgumentException.\n              (str (.getName file-path-one)\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else (FileUtils/contentEquals file-path-one file-path-two))))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? (.getName file-path-one)))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? (.getName file-path-two)))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else (FileUtils/contentEquals file-path-one file-path-two))))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? (.getAbsolutePath file-path-one)))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? (.getAbsolutePath file-path-two)))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else (FileUtils/contentEquals file-path-one file-path-two))))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? \n             (.getAbsolutePath file-path-one)))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? \n                 (.getAbsolutePath file-path-two)))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else (assoc x :result (FileUtils/contentEquals file-path-one file-path-two)))))&quot; &quot;(cetl-compare-file {:file-one \&quot;foo.txt\&quot;\n                    :path-one \&quot;/Users/gregadebesin/Development\&quot;\n                    :file-two \&quot;bar.txt\&quot;\n                    :path-two \&quot;/Users/gregadebesin/Development\&quot;\n                    :exec :compare-file})&quot; &quot;2&quot; &quot;1&quot; &quot;(slurp \&quot;/Users/gregadebesin/Development/tennis.txt\&quot;)&quot; &quot;(line-seq )&quot; &quot;(line-seq \&quot;/Users/gregadebesin/Development/tennis.txt\&quot;)&quot; &quot;(line-seq (slurp \&quot;/Users/gregadebesin/Development/tennis.txt\&quot;))&quot; &quot;(with-open [rdr (clojure.java.io/reader \&quot;/Users/gregadenesin/Development/tennis.txt\&quot;)]\n  (line-seq rdr))&quot; &quot;(with-open [rdr (clojure.java.io/reader \&quot;/Users/gregadebesin/Development/tennis.txt\&quot;)]\n  (line-seq rdr))&quot; &quot;(with-open [rdr (clojure.java.io/reader \&quot;/Users/gregadebesin/Development/tennis.txt\&quot;)]\n  (count (line-seq rdr)))&quot; &quot;(defmulti cetl-count-row-file {:argslist '([map])} \n          (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  )&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x])&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [line-num-reader (LineNumberReader. (FileReader. (File. x)))])\n  )&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [line-num-reader (LineNumberReader. (FileReader. (File. x)))]\n    (.skip line-num-reader Long/MAX_VALUE)\n    ))&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [line-num-reader (LineNumberReader. (FileReader. (File. x)))]\n    (doto line-num-reader\n      (.skip Long/MAX_VALUE)\n      (+ .getLineNumber 1)\n      (.close))))&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [line-num-reader (LineNumberReader. (FileReader. (File. x)))]\n    (doto line-num-reader\n      (.skip Long/MAX_VALUE)\n      (+ (.getLineNumber) 1)\n      (.close))))&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [line-num-reader (LineNumberReader. (FileReader. (File. x)))]\n    (doto line-num-reader\n      (.skip Long/MAX_VALUE)\n      (.getLineNumber)\n      (+ 1)\n      (.close))))&quot; &quot;(defn cetl-count-row-file \n  [x]\n  (let [line-num-reader (LineNumberReader. (FileReader. (File. x)))]\n    (doto line-num-reader\n      (.skip Long/MAX_VALUE)\n      (.getLineNumber)\n      (+ 1)\n      (.close))))&quot; &quot;(defn cetl-count-row-file \n  [x]\n  (let [line-num-reader (LineNumberReader. (FileReader. (File. x)))]\n    (doto line-num-reader\n      (.skip Long/MAX_VALUE)\n      .getLineNumber\n      (+ 1)\n      (.close))))&quot; &quot;(defn cetl-count-row-file \n  [x]\n  (let [line-num-reader (LineNumberReader. (FileReader. (File. x)))]\n    (doto line-num-reader\n      (.skip Long/MAX_VALUE)\n      (+ 1 .getLineNumber)\n      (.close))))&quot; &quot;(defn cetl-count-row-file \n  [x]\n  (let [line-num-reader (LineNumberReader. (FileReader. (File. x)))]\n    (.getLineNumber (.skip line-num-reader Long/MAX_VALUE) 1)))&quot; &quot;(defn cetl-count-row-file \n  [x]\n  (let [line-num-reader (LineNumberReader. (FileReader. (File. x)))]\n    (do (.skip line-num-reader Long/MAX_VALUE)\n        (.getLineNumber line-num-reader))))&quot; &quot;(defn cetl-count-row-file \n  [x]\n  (let [line-num-reader (-&gt; (LineNumberReader.) (FileReader.) (File. x))]\n    (do (.skip line-num-reader Long/MAX_VALUE)\n        (+ 1 (.getLineNumber line-num-reader)))))&quot; &quot;(defn cetl-count-row-file \n  [x]\n  (let [line-num-reader (-&gt;&gt; (LineNumberReader.) (FileReader.) (File. x))]\n    (do (.skip line-num-reader Long/MAX_VALUE)\n        (+ 1 (.getLineNumber line-num-reader)))))&quot; &quot;(defn cetl-count-row-file \n  [x]\n  (let [line-num-reader (-&gt; LineNumberReader. (FileReader.) (File. x))]\n    (do (.skip line-num-reader Long/MAX_VALUE)\n        (+ 1 (.getLineNumber line-num-reader)))))&quot; &quot;(defn cetl-count-row-file \n  [x]\n  (let [line-num-reader (LineNumberReader. (FileReader. (File. x)))]\n    (do (.skip line-num-reader Long/MAX_VALUE)\n        (+ 1 (.getLineNumber line-num-reader)))))&quot; &quot;(defn cetl-count-row-file\n  [x]\n  (let [line-num-reader (LineNumberReader. \n                          (FileReader. \n                            (File. x)))]\n    (do (.skip line-num-reader Long/MAX_VALUE)\n        (+ 1 (.getLineNumber line-num-reader)))))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists?]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.io File)\n           (java.text SimpleDateFormat)))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists?]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.io File LineNumber)\n           (java.text SimpleDateFormat)))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists?]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.io File LineNumberReader)\n           (java.text SimpleDateFormat)))&quot; &quot;(defn cetl-count-row-file\n  [x]\n  (let [line-num-reader (-&gt; (File. x) (FileReader.) (LineNumberReader.))]\n    (do (.skip line-num-reader Long/MAX_VALUE)\n        (+ 1 (.getLineNumber line-num-reader)))))&quot; &quot;(cetl-count-row-file \&quot;/Users/gregadebesin/Development/Cetl/tennis.txt\&quot;)&quot; &quot;(defn cetl-count-row-file\n  [x]\n  (let [line-num-reader (-&gt; (io/file x) (io/reader) (LineNumberReader.))]\n    (do (.skip line-num-reader Long/MAX_VALUE)\n        (+ 1 (.getLineNumber line-num-reader)))))&quot; &quot;(cetl-count-row-file \&quot;/Users/gregadebesin/Development/tennis.txt\&quot;)&quot; &quot;(defmethod cetl-properties-file :properties-file\n  [x]\n  (let [file (File. (str (:path x) \&quot;/\&quot; (:file x)))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (file-exists? (.getAbsolutePath file))\n      (do (assoc x :result {:abs-file-path abs-file-path\n                            :parent-dir parent-dir\n                            :file-name file-name\n                            :read-permissions read-permissions\n                            :write-permissions write-permissions\n                            :execute-permissions execute-permissions\n                            :file-size file-size\n                            :modified-time-millis modified-time-millis\n                            :modified-time-str modified-time-str}))\n      (throw\n        (IllegalArgumentException.\n          (str file \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmulti cetl-properties-file {:arglists '([map])}\n          (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-properties-file :properties-file\n  [x]\n  (let [file (io/file (str (:path x) \&quot;/\&quot; (:file x)))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (file-exists? (.getAbsolutePath file))\n      (do (assoc x :result {:abs-file-path abs-file-path\n                            :parent-dir parent-dir\n                            :file-name file-name\n                            :read-permissions read-permissions\n                            :write-permissions write-permissions\n                            :execute-permissions execute-permissions\n                            :file-size file-size\n                            :modified-time-millis modified-time-millis\n                            :modified-time-str modified-time-str}))\n      (throw\n        (IllegalArgumentException.\n          (str file \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(cetl-properties-file {:path \&quot;/Users/gregadebesin/Development\&quot;\n                       :file \&quot;foo.tmp\&quot;\n                       :exec :file-properties})&quot; &quot;(cetl-properties-file {:path \&quot;/Users/gregadebesin/Development\&quot;\n                       :file \&quot;foo.tmp\&quot;\n                       :exec :properties-file})&quot; &quot;(defmethod cetl-encode-file :UTF-8\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (FileUtils/write\n          (File. file-path)\n          (FileUtils/readFileToString\n            (File. file-path) \&quot;ISO-8859-1\&quot;) \&quot;UTF-8\&quot;)\n        (assoc x\n          :result (str (:path x) \&quot;/\&quot; (:file x))))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmulti cetl-count-row-file {:argslist '([map])}\n          (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (do (.skip line-num-reader Long/MAX_VALUE)\n        (+ 1 (.getLineNumber line-num-reader))\n        (.close line-num-reader))))&quot; &quot;(ns cetl.core-test\n  (:require [clojure.test :refer :all]\n            [cetl.core :refer :all]\n            [cetl.file.management :refer :all]))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists?]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.io File LineNumberReader FileReader)\n           (java.text SimpleDateFormat)))&quot; &quot;(use '[clojure.java.shell :only [sh]])&quot; &quot;(cetl-count-row-file {:file \&quot;tennnis.txt\&quot;\n                      :path \&quot;/Users/gregadebesin/Development\&quot;})&quot; &quot;(cetl-count-row-file {:file \&quot;tennnis.txt\&quot;\n                      :path \&quot;/Users/gregadebesin/Development\&quot;\n                      :exec :count-row-file})&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (do (.skip line-num-reader Long/MAX_VALUE)\n        (+ 1 (.getLineNumber line-num-reader)))\n    (.close line-num-reader)))&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (doto line-num-reader\n      (.skip Long/MAX_VALUE)\n      (.getLineNumber)  \n      (+ 1))\n      (.close)))&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (doto (line-num-reader)\n      (.skip Long/MAX_VALUE)\n      (.getLineNumber)  \n      (+ 1))\n      (.close)))&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (doto line-num-reader\n      (.skip Long/MAX_VALUE)\n      .getLineNumber  \n      (+ 1))\n      (.close)))&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (doto line-num-reader\n      (.skip Long/MAX_VALUE)\n      (.getLineNumber)\n      (+ 1)\n      (.close))))&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (doto (line-num-reader)\n      (.skip Long/MAX_VALUE)\n      (.getLineNumber)\n      (+ 1)\n      (.close))))&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (doto  line-num-reader\n      (.skip Long/MAX_VALUE)\n      (.getLineNumber)\n      (.close))))&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (.getLineNumber (.skip line-num-reader Long/MAX_VALUE))))&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (do (.skip line-num-reader Long/MAX_VALUE)\n        (+ 1 (.getLineNumber line-num-reader)))\n    (finally (.close line-num-reader))))&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))\n        (.close line-num-reader)]\n    (do (.skip line-num-reader Long/MAX_VALUE)\n        (+ 1 (.getLineNumber line-num-reader)))\n    (finally (.close line-num-reader))))&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (do (.skip line-num-reader Long/MAX_VALUE)\n        (+ 1 (.getLineNumber line-num-reader)))))&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (if (file-exists? file-path)\n      (do (.skip line-num-reader Long/MAX_VALUE)\n          (+ 1 (.getLineNumber line-num-reader)))\n      (throw \n        (IllegalArgumentException. (str file-path \&quot; is not a file (or a directory)\&quot;)))\n      (finally (.close line-num-reader)))))&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (if (file-exists? file-path)\n      (do (.skip line-num-reader Long/MAX_VALUE)\n          (+ 1 (.getLineNumber line-num-reader)))\n      (throw\n        (IllegalArgumentException. (str file-path \&quot; is not a file (or a directory)\&quot;))\n        (finally (.close line-num-reader))))))&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (if (file-exists? file-path)\n      (do (.skip line-num-reader Long/MAX_VALUE)\n          (-&gt; (.getLineNumber line-num-reader) (+ 1)))\n      (throw\n        (IllegalArgumentException. \n          (str file-path \&quot; is not a file (or a directory)\&quot;))\n        (finally \n          (.close line-num-reader))))))&quot; &quot;(defmethod cetl-count-row-file :count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (if (file-exists? file-path)\n      (do (.skip line-num-reader Long/MAX_VALUE)\n          (+ 1 (.getLineNumber line-num-reader)))\n      (throw\n        (IllegalArgumentException. \n          (str file-path \&quot; is not a file (or a directory)\&quot;))\n        (finally \n          (.close line-num-reader))))))&quot; &quot;(cetl-count-row-file {:file \&quot;tennis.txt\&quot;\n                      :path \&quot;/Users/gregadebesin/Development\&quot;\n                      :exec :count-row-file})&quot; &quot;(defmulti cetl-touch-file {:argslist '([map])}\n          (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-touch-file :touch-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path))))&quot;], :remote []}}</component>
</project>