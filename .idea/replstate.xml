<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1451333783238">{:repl-history {:ide [], :local [&quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (map (fn [y] (clojure.java.shell/sh\n                        \&quot;sh\&quot; \&quot;-c\&quot;\n                        (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                             \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                             \&quot; -r \&quot; (file-name y)))) (path-from-map x))\n         {})))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (\n           (map (fn [y] (clojure.java.shell/sh\n                          \&quot;sh\&quot; \&quot;-c\&quot;\n                          (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                               \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                               \&quot; -r \&quot; (file-name y)))) (path-from-map x)) {}))))&quot; &quot;(do (map inc [1]) {})&quot; &quot;(do (print 2) {})&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (do\n           (map (fn [y] (clojure.java.shell/sh\n                          \&quot;sh\&quot; \&quot;-c\&quot;\n                          (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                               \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                               \&quot; -r \&quot; (file-name y)))) (path-from-map x)) {}))))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.file :refer [file-exists? file-name path-from-map isDir? parent-path]])\n  (:import (java.io File LineNumberReader)\n           (org.apache.commons.compress.archivers.zip ZipArchiveEntry)\n           (java.text SimpleDateFormat)))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.file :refer [file-exists? file-name path-from-map isDir? parent-path]])\n  (:import (java.io File LineNumberReader)\n           (org.apache.commons.compress.archivers.zip ZipArchiveEntry)\n           (org.apache.commons.compress.archivers.zip ZipArchiveOutputStream)\n           (java.text SimpleDateFormat)))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.file :refer [file-exists? file-name path-from-map isDir? parent-path]])\n  (:import (java.io File LineNumberReader FileOutputStream)\n           (org.apache.commons.compress.archivers.zip ZipArchiveEntry)\n           (org.apache.commons.compress.archivers.zip ZipArchiveOutputStream)\n           (java.text SimpleDateFormat)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [fos (FileOutputStream. (File. \&quot;/Users/gra11/Development/file.txt\&quot;))\n        zos (ZipArchiveOutputStream. fos)]))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [fos (FileOutputStream. (File. \&quot;/Users/gra11/Development/file.txt\&quot;))\n        zos (ZipArchiveOutputStream. fos)]\n    (.putArchiveEntry zos ZipArchiveOutputStream)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [file (File.\&quot;/Users/gra11/Development/file.txt\&quot;)\n        fos (FileOutputStream. (File. file))\n        zos (ZipArchiveOutputStream. fos)]\n    (.putArchiveEntry (ZipArchiveEntry. (.getName file) (.getCanonicalPath file)) ZipArchiveOutputStream)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [file (File.\&quot;/Users/gra11/Development/file.txt\&quot;)\n        fos (FileOutputStream. (File. file))\n        zos (ZipArchiveOutputStream. fos)]\n    (.putArchiveEntry (ZipArchiveEntry. \n                        (.getName file) \n                        (.getCanonicalPath file)) ZipArchiveOutputStream)))&quot; &quot;(.getCanonicalPath (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [file (File.\&quot;/Users/gra11/Development/file.txt\&quot;)\n        fos (FileOutputStream. (File. file))\n        zos (ZipArchiveOutputStream. fos)]\n    (.putArchiveEntry (ZipArchiveEntry. \n                        file\n                        (.getCanonicalPath file)) ZipArchiveOutputStream)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [file (File.\&quot;/Users/gra11/Development/file.txt\&quot;)\n        fos (FileOutputStream. (File. file))\n        zos (ZipArchiveOutputStream. fos)]\n    (.putArchiveEntry (ZipArchiveEntry. \n                        file\n                        (.getCanonicalPath file)) zos)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [file (File.\&quot;/Users/gra11/Development/file.txt\&quot;)\n        fos (FileOutputStream. file)\n        zos (ZipArchiveOutputStream. fos)]\n    (.putArchiveEntry (ZipArchiveEntry. \n                        file\n                        (.getCanonicalPath file)) zos)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [file (File.\&quot;/Users/gra11/Development/file.txt\&quot;)\n        fos (FileOutputStream. (File. file))\n        zos (ZipArchiveOutputStream. fos)]\n    (.putArchiveEntry (ZipArchiveEntry. file (.getCanonicalPath file)) zos)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [file (File.\&quot;/Users/gra11/Development/file.txt\&quot;)\n        fos (FileOutputStream. file)\n        zos (ZipArchiveOutputStream. fos)]\n    (.putArchiveEntry (ZipArchiveEntry. file (.getCanonicalPath file)) zos)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [file (File.\&quot;/Users/gra11/Development/file.txt\&quot;)\n        fos (FileOutputStream. file)\n        zos (ZipArchiveOutputStream. fos)]\n    (.putArchiveEntry zos (ZipArchiveEntry. file (.getCanonicalPath file)))))&quot; &quot;(cetl-zip-file 3)&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [destination (File.\&quot;/Users/gra11/Development\&quot;)\n        source (File. \&quot;/Users/gra11/Development/file.txt\&quot;)\n        archive-stream (FileOutputStream. destination)]\n    (.createArchiveOutputStream ArchiveStreamFactory/ZIP archive-stream  ArchiveStreamFactory.)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [destination (File.\&quot;/Users/gra11/Development\&quot;)\n        source (File. \&quot;/Users/gra11/Development/file.txt\&quot;)\n        archive-stream (FileOutputStream. destination)]\n    (ArchiveStreamFactory/ZIP archive-stream (.createArchiveOutputStream ArchiveStreamFactory.))))&quot; &quot;.createArchiveOutputStream&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [destination (File.\&quot;/Users/gra11/Development\&quot;)\n        source (File. \&quot;/Users/gra11/Development/file.txt\&quot;)\n        archive-stream (FileOutputStream. destination)]\n    (.createArchiveOutputStream ArchiveStreamFactory/ZIP archive-stream ArchiveStreamFactory.)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [destination (File.\&quot;/Users/gra11/Development\&quot;)\n        source (File. \&quot;/Users/gra11/Development/file.txt\&quot;)\n        archive-stream (FileOutputStream. destination)]\n    ((.createArchiveOutputStream ArchiveStreamFactory/ZIP archive-stream) ArchiveStreamFactory.)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [destination (File.\&quot;/Users/gra11/Development\&quot;)\n        source (File. \&quot;/Users/gra11/Development/file.txt\&quot;)\n        archive-stream (FileOutputStream. destination)]\n    (doto (ArchiveStreamFactory.)\n      (.createArchiveOutputStream ArchiveStreamFactory/ZIP archive-stream))))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [destination (File.\&quot;/Users/gra11/Development\&quot;)\n        source (File. \&quot;/Users/gra11/Development/file.txt\&quot;)\n        archive-stream (FileOutputStream. destination)]\n    (.createArchiveOutputStream ArchiveStreamFactory. ArchiveStreamFactory/ZIP archive-stream)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [destination (File.\&quot;/Users/gra11/Development\&quot;)\n        source (File. \&quot;/Users/gra11/Development/file.txt\&quot;)\n        archive-stream (FileOutputStream. destination)]\n    (.createArchiveOutputStream ArchiveStreamFactory/ZIP archive-stream (ArchiveStreamFactory.))))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [destination (File.\&quot;/Users/gra11/Development\&quot;)\n        source (File. \&quot;/Users/gra11/Development/file.txt\&quot;)\n        archive-stream (FileOutputStream. destination)]\n    (.createArchiveOutputStream (ArchiveStreamFactory.) ArchiveStreamFactory/ZIP archive-stream)))&quot; &quot;(.getCanonicalFile (File. \&quot;\&quot;))&quot; &quot;(.indexOf (String.) \&quot;fee bar\&quot; \&quot;bar\&quot;)&quot; &quot;(.toUpperCase (String.) \&quot;fee bar\&quot;)&quot; &quot;(.toUpperCase String. \&quot;fee bar\&quot;)&quot; &quot;\n(.getName (File. \&quot;\&quot;))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.file :refer [file-exists? file-name path-from-map isDir? parent-path]])\n  (:import (java.io File LineNumberReader FileOutputStream)\n           (org.apache.commons.compress.archivers.zip ZipArchiveEntry)\n           (org.apache.commons.compress.archivers.zip ZipArchiveOutputStream)\n           (org.apache.commons.compress.archivers ArchiveStreamFactory)\n           (java.text SimpleDateFormat)))&quot; &quot;(use '[clojure.java.shell :only [sh]])&quot; &quot;(.getName (File. \&quot;\&quot;))&quot; &quot;(.getName (File. \&quot;/Users/foo.txt\&quot;))&quot; &quot;(.getName  File. \&quot;/Users/foo.txt\&quot;)&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.file :refer [file-exists? file-name path-from-map isDir? parent-path]])\n  (:import (java.io File LineNumberReader FileOutputStream)\n           (org.apache.commons.compress.archivers.zip ZipArchiveEntry)\n           (org.apache.commons.compress.archivers.zip ZipArchiveOutputStream)\n           (org.apache.commons.compress.archivers ArchiveStreamFactory)\n           (org.apache.commons.io FileUtils)\n           (java.text SimpleDateFormat)))&quot; &quot;(defn cetl-zip-file\n  [x]\n  (let [destination (File.\&quot;/Users/gra11/Development\&quot;)\n        source (File. \&quot;/Users/gra11/Development/file.txt\&quot;)\n        archive-stream (FileOutputStream. destination)\n        archive (.createArchiveInputStream (ArchiveStreamFactory.) ArchiveStreamFactory/ZIP archive-stream)]))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (map (fn [y] (clojure.java.shell/sh\n                        \&quot;sh\&quot; \&quot;-c\&quot;\n                        (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                             \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                             \&quot; -r \&quot; (file-name y)))) (path-from-map x)))))&quot; &quot;(defn zip-command\n  ([] nil)\n  ([f] (map (fn [y] (clojure.java.shell/sh \n                      \&quot;sh\&quot; \&quot;-c\&quot; \n                      (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot;\n                           \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot;\n                           \&quot; -r \&quot; (file-name y)))) f)))&quot; &quot;(defn check-files-exist\n  ([] nil)\n  ([x] (nil? (some false?\n                   (map #(file-exists? %) (path-from-map x))))))&quot; &quot;(defn zip-command\n  ([] nil)\n  ([f] (map (fn [y] (clojure.java.shell/sh \n                      \&quot;sh\&quot; \&quot;-c\&quot; \n                      (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot; \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot; \&quot; -r \&quot; (file-name y)))) f)))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (do\n           (zip-command (path-from-map x))\n           {}))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (do\n           (zip-command (path-from-map x))))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (do\n     (zip-command (path-from-map x))\n     {})))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (dorun\n           (zip-command (path-from-map x))))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (dorun\n           (zip-command (path-from-map x))\n           {}))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (doall\n           (zip-command (path-from-map x))\n           {}))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (do\n           (zip-command (path-from-map x))\n           (do {})))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (doall\n           (zip-command (path-from-map x))\n           (do {})))))&quot; &quot;(zip-command (path-from-map {:path \&quot;\&quot;}))&quot; &quot;(zip-command (path-from-map {:path \&quot;/Users/gra11/Development\&quot;}))&quot; &quot;(zip-command (path-from-map {:path [\&quot;/Users/gra11/Developmen\&quot;]}))&quot; &quot;(zip-command (path-from-map {:path [\&quot;/Users/gra11/Developme\&quot;]}))&quot; &quot;(zip-command (path-from-map {:path [\&quot;/Users/gra11/Development\&quot;]}))&quot; &quot;(zip-command (path-from-map {:path []}))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         ((zip-command (path-from-map x))\n           {}))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (when true\n           (zip-command (path-from-map x))\n           {}))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (while true\n           (zip-command (path-from-map x))\n           {}))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (let []\n           (zip-command (path-from-map x))\n           {}))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (let []\n           (zip-command (path-from-map x))))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (zip-command (path-from-map x)))))&quot; &quot;(flatten ({:exit 0, :out \&quot;updating: file.txt (deflated 14%)\\n\&quot;, :err \&quot;\&quot;}))&quot; &quot;(flatten '({:exit 0, :out \&quot;updating: file.txt (deflated 14%)\\n\&quot;, :err \&quot;\&quot;}))&quot; &quot;(into {} '({:exit 0, :out \&quot;updating: file.txt (deflated 14%)\\n\&quot;, :err \&quot;\&quot;}))&quot; &quot;(defn zip-command\n  ([] nil)\n  ([f] (into {} (map (fn [y] (clojure.java.shell/sh\n                       \&quot;sh\&quot; \&quot;-c\&quot;\n                       (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot; \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot; \&quot; -r \&quot; (file-name y)))) f))))&quot; &quot;(defn zip-command\n  ([] nil)\n  ([f] (into {} (map (fn [y] (clojure.java.shell/sh \n                               \&quot;sh\&quot; \&quot;-c\&quot; \n                               (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot; \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot; \&quot; -r \&quot; (file-name y)))) f))))&quot; &quot;(defn build-zip-output-map\n  ([] nil)\n  ([f map] (assoc (empty f) :path map)))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (let [path-from-map (path-from-map x)]\n           (build-zip-output-map\n             (zip-command path-from-map) (map #(str % \&quot;.zip\&quot;) path-from-map))))))&quot; &quot;(defn build-zip-output-map\n  ([] nil)\n  ([f v] (assoc (empty f) :path (map #(str % \&quot;.zip\&quot;) v))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([x]\n   (cond (nil? x) nil\n         (check-files-exist x)\n         (let [path-from-map (path-from-map x)]\n           (build-zip-output-map\n             (zip-command path-from-map) path-from-map)))))&quot; &quot;(empty {:foo \&quot;\&quot;})&quot; &quot;(defn build-zip-output-map\n  ([] nil)\n  ([f v] (assoc (empty f) :path (mapv #(str % \&quot;.zip\&quot;) v))))&quot; &quot;(cetl-zip-file {:path [\&quot;/Users/gra11/Development/file.txt\&quot; \&quot;/Users/gra11/Development/fil2.txt\&quot;]})&quot; &quot;(cetl-zip-file {:path [\&quot;/Users/gra11/Development/file.txt\&quot; \&quot;/Users/gra11/Development/file2.txt\&quot;]})&quot; &quot;(defn cetl-list-files\n    [x]\n    (cond (nil? x) nil\n      (file-exists? (path-from-map x))\n          (let [file-path (path-from-map x)]\n            (assoc x\n              :path (s/split\n                      (get (clojure.java.shell/sh\n                             \&quot;sh\&quot; \&quot;-c\&quot;\n                             (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                  \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n              :exec :cetl-list-files))))&quot; &quot;(cetl-list-files {:path \&quot;/Users/gra11\&quot;})&quot; &quot;(cetl-list-files {:path \&quot;/Users/gra11/Development\&quot;})&quot; &quot;(-&gt; {:path \&quot;/Users/gra11/Development\&quot;}\n    (cetl-list-files)\n    (cetl-zip-file))&quot; &quot;(defn zip-command\n  ([] nil)\n  ([m] (into {} (map (fn [y] \n                       (clojure.java.shell/sh \n                         \&quot;sh\&quot; \&quot;-c\&quot; \n                         (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot; \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot; \&quot; -r \&quot; (file-name y)))) m))))&quot; &quot;(defn zip-command\n  ([] nil)\n  ([v] (into {} (map (fn [s] \n                       (clojure.java.shell/sh \n                         \&quot;sh\&quot; \&quot;-c\&quot; \n                         (str \&quot; cd \&quot; (parent-path s) \&quot;;\&quot; \&quot; zip \&quot; (file-name s) \&quot;.zip\&quot; \&quot; -r \&quot; (file-name s)))) v))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([m]\n   (cond (nil? m) nil\n         (check-files-exist m)\n         (let [path-from-map (path-from-map m)]\n           (build-zip-output-map\n             (zip-command path-from-map) path-from-map)))))&quot; &quot;(defn build-zip-output-map\n  ([] nil)\n  ([f v] (assoc (empty f) :path (mapv #(str % \&quot;.zip\&quot;) v) :exec :cetl-zip-file)))&quot; &quot;(defn zip-command\n  ([] nil)\n  ([v] (into {} (map (fn [s]\n                       (clojure.java.shell/sh\n                         \&quot;sh\&quot; \&quot;-c\&quot;\n                         (str \&quot; cd \&quot; (parent-path s) \&quot;;\&quot; \&quot; zip \&quot; (file-name s) \&quot;.zip\&quot; \&quot; -r \&quot; (file-name s)))) v))))&quot; &quot;(defn check-files-exist\n  ([] nil)\n  ([m] (nil? (some false?\n                   (map #(file-exists? %) (path-from-map m))))))&quot; &quot;(cetl-zip-file {:path [\&quot;/Users/gra11/Development/file.txt\&quot;]})&quot; &quot;(cycle [])&quot; &quot;(take 10 (cycle [1]))&quot; &quot;(take 10 (cycle (reduce + (range 1 20))))&quot; &quot;(take 10 (cycle (into [] (reduce + (range 1 20)))))&quot; &quot;(take 20 (repeat 2))&quot; &quot;(take 20 (repeatedly 2))&quot; &quot;(take 20 (repeatedly (println \&quot;\&quot;)))&quot; &quot;(take 30 (repeatedly (rand-int 2)))&quot; &quot;(take 30 (repeatedly #(rand-int 2)))&quot; &quot;(take 30 (repeatedly #(rand-int 10)))&quot; &quot;(map #(cond (string? %) (read-string %)\n            (integer? %) (str %))\n     [1 \&quot;2\&quot; 3 \&quot;4 5\&quot;])&quot; &quot;(mapv #(cond (string? %) (read-string %)\n            (integer? %) (str %))\n     [1 \&quot;2\&quot; 3 \&quot;4 5\&quot;])&quot;], :remote []}}</component>
</project>