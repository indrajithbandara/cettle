<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1447196220499">{:repl-history {:ide [], :local [&quot;(cetl-file-temp-create {:path \&quot;/Users/gregadebesin/Development\&quot;\n                        :file \&quot;poo.txt\&quot;\n                        :exec :temp-file})&quot; &quot;(defn cetl-file-copy\n  [x]\n  (let [file (:file x)\n        in-path (:in-path x)\n        out-path (:out-path x)\n        exec (:exec x)]\n    (if (= exec :exec)\n      (io/copy\n        (io/file (str in-path \&quot;/\&quot; file))\n        (io/file (str out-path \&quot;/\&quot;file))))\n    (assoc x :result (vector (str (:in-path x) \&quot;/\&quot; (:file x))\n                             (str (:out-path x) \&quot;/\&quot; (:file x))))))&quot; &quot;(defn cetl-file-delete\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:delete x)]\n    (if (= exec :exec)\n      (io/delete-file\n        (io/file\n          (str path \&quot;/\&quot; file))))\n    (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x))))))&quot; &quot;(defn cetl-file-properties\n  [x]\n  (let [file (File. (:path x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)]\n    (assoc x :result (vector abs-file-path parent-dir))))&quot; &quot;(defn cetl-file-delete\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:exec x)]\n    (if (= exec :exec)\n      (io/delete-file\n        (io/file\n          (str path \&quot;/\&quot; file))))\n    (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x))))))&quot; &quot;(cetl-file-properties {:path \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file.txt\&quot;\n                       :exec :file-properties})&quot; &quot;(defn cetl-file-temp-create\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:exec x)]\n    (if (= exec :temp-file-create)\n      (io/writer\n        (io/file\n          (str path \&quot;/\&quot; file))))\n    (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x))))))&quot; &quot;(defn cetl-file-temp-create\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:exec x)]\n    (if (= exec :temp-file-create)\n      (io/writer\n        (io/file\n          (str path \&quot;/\&quot; file)))\n      (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x)))))))&quot; &quot;(defn cetl-file-temp-create\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:exec x)]\n    (if (= exec :temp-file-create)\n      (io/writer\n        (io/file\n          (str path \&quot;/\&quot; file)))\n      (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x)))))\n    nil))&quot; &quot;(defn cetl-file-temp-create\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:exec x)]\n    (if (= exec :temp-file-create)\n      (io/writer\n        (io/file\n          (str path \&quot;/\&quot; file)))\n      (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x))))\n      nil)))&quot; &quot;(defn cetl-file-temp-create\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:exec x)]\n    (if (= exec :temp-file-create)\n      (do\n        (io/writer\n          (io/file\n            (str path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x)))))\n      nil)))&quot; &quot;(cetl-file-temp-create {:path \&quot;/Users/gregadebesin/Development\&quot;\n                        :file \&quot;poo1.txt\&quot;\n                        :exec :temp-file-create})&quot; &quot;(cetl-file-temp-create {:path \&quot;/Users/gregadebesin/Development\&quot;\n                        :file \&quot;poo1.txt\&quot;\n                        :exec :temp-file-creat})&quot; &quot;(cetl-file-temp-create {:path \&quot;/Users/gregadebesin/Development\&quot;\n                        :file \&quot;poo1222.txt\&quot;\n                        :exec :temp-file-create})&quot; &quot;(defn cetl-file-copy\n  [x]\n  (let [file (:file x)\n        in-path (:in-path x)\n        out-path (:out-path x)\n        exec (:exec x)]\n    (if (= exec :file-copy)\n      (do\n        (io/copy\n          (io/file (str in-path \&quot;/\&quot; file))\n          (io/file (str out-path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str (:in-path x) \&quot;/\&quot; (:file x))\n                                 (str (:out-path x) \&quot;/\&quot; (:file x))))) nil)))&quot; &quot;(defn cetl-file-temp-create\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:exec x)]\n    (if (= exec :temp-file-create)\n      (do\n        (io/writer\n          (io/file\n            (str path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x))))) nil)))&quot; &quot;(defn cetl-file-temp-create\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:exec x)]\n    (if (= exec :temp-file-create)\n      (do\n        (io/writer\n          (io/file\n            (str path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x))))))))&quot; &quot;(defn cetl-delete-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:exec x)]\n    (if (= exec :delete-file)\n      (do\n        (io/delete-file\n          (io/file\n            (str path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x))))))))&quot; &quot;(defn cetl-file-copy\n  [x]\n  (let [file (:file x)\n        in-path (:in-path x)\n        out-path (:out-path x)\n        exec (:exec x)]\n    (if (= exec :file-copy)\n      (do\n        (io/copy\n          (io/file (str in-path \&quot;/\&quot; file))\n          (io/file (str out-path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str (:in-path x) \&quot;/\&quot; (:file x))\n                                 (str (:out-path x) \&quot;/\&quot; (:file x))))))))&quot; &quot;(defn cetl-emp-file-create\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:exec x)]\n    (if (= exec :temp-file-create)\n      (do\n        (io/writer\n          (io/file\n            (str path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x))))))))&quot; &quot;(defn cetl-file-delete\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:exec x)]\n    (if (= exec :delete-file)\n      (io/delete-file\n        (io/file\n          (str path \&quot;/\&quot; file))))\n    (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x))))))&quot; &quot;(defn cetl-file-delete\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:exec x)]\n    (if (= exec :delete-file)\n      (do\n        (io/delete-file\n          (io/file\n            (str path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x))))))))&quot; &quot;(cetl-file-temp-create {:path \&quot;/Users/gregadebesin/Development\&quot;\n                        :file \&quot;poo1222.txt\&quot;\n                        :exec :temp-file-creat})&quot; &quot;(cetl-delete-file  {    :path \&quot;/Users/gregadebesin/Development\&quot;\n                        :file \&quot;poo1222.txt\&quot;\n                        :exec :delete-file})&quot; &quot;(cetl-delete-file  {    :path \&quot;/Users/gregadebesin/Development\&quot;\n                        :file \&quot;poo1222.txt\&quot;\n                        :exec :delete-fil})&quot; &quot;(defn cetl-file-properties\n  [x]\n  (let [file (File. (:path x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (= exec :file-properties)\n      (do (assoc x :result (vector file abs-file-path parent-dir file-name read-permissions write-permissions execute-permissions\n                                   file-size modified-time-millis modified-time-str))))))&quot; &quot;(defn cetl-file-properties\n  [x]\n  (let [file (File. (:path x))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (= exec :file-properties)\n      (do (assoc x :result (vector abs-file-path parent-dir file-name read-permissions write-permissions execute-permissions\n                                   file-size modified-time-millis modified-time-str))))))&quot; &quot;(defmethod cetl-file-list :list-files\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command \&quot; find `pwd` -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (assoc path :result\n                (s/split\n                  (get (clojure.java.shell/sh\n                         \&quot;sh\&quot; \&quot;-c\&quot;\n                         (str move-to-dir (:path path)\n                              next-command\n                              command))\n                       :out) #\&quot;\\n\&quot;))))&quot; &quot;(defmethod cetl-file-list :list-dirs-sub-dirs\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command  \&quot; find `pwd` -type d \&quot;\n        next-command \&quot;;\&quot;]\n    (assoc path :result\n                (s/split\n                  (get (clojure.java.shell/sh\n                         \&quot;sh\&quot; \&quot;-c\&quot;\n                         (str move-to-dir (:path path)\n                              next-command\n                              command))\n                       :out) #\&quot;\\n\&quot;))))&quot; &quot;(defmethod cetl-file-archive :zip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        path (:path x)\n        file (:file x)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir (File. path) next-command\n           zip-command (str file file-ext)\n           rec-command file))\n    (assoc x :result\n             (vector\n               (str (:path x) \&quot;/\&quot; (:file x) file-ext)))))&quot; &quot;(defmethod cetl-file-archive :gzip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        gzip-command \&quot; tar -cvzf \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.tar.gz\&quot;\n        path (:path x)\n        file (:file x)]\n    (clojure.java.shell/sh\n      \&quot;sh\&quot; \&quot;-c\&quot;\n      (str move-to-dir  (File. path) next-command\n           gzip-command (str file file-ext\&quot; \&quot;file)))\n    (assoc x :result\n             (vector (str (:path x) \&quot;/\&quot; (:file x) file-ext)))))&quot; &quot;(defmethod cetl-file-encode :encode-UTF-8\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (FileUtils/write\n      (File. file-path)\n      (FileUtils/readFileToString\n        (File. file-path) \&quot;ISO-8859-1\&quot;)\n      (name (:encode x))))\n  (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x)))))&quot; &quot;(defmethod cetl-file-encode :encode-ISO-8859-1\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (FileUtils/write\n      (File. file-path)\n      (FileUtils/readFileToString\n        (File. file-path) \&quot;UTF-8\&quot;)\n      (name (:encode x))))\n  (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x)))))&quot; &quot;(defn cetl-create-temp-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:exec x)]\n    (if (= exec :temp-file-create)\n      (do\n        (io/writer\n          (io/file\n            (str path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x))))))))&quot; &quot;(defn cetl-create-temp-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:exec x)]\n    (if (= exec :create-temp-file)\n      (do\n        (io/writer\n          (io/file\n            (str path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x))))))))&quot; &quot;(defmulti cetl-encode-file (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-encode-file :encode-file-ISO-8859-1\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (FileUtils/write\n      (File. file-path)\n      (FileUtils/readFileToString\n        (File. file-path) \&quot;UTF-8\&quot;) \&quot;ISO-8859-1\&quot;))\n  (assoc x :result (vector (str (:path x) \&quot;/\&quot; (:file x)))))&quot; &quot;(cetl-list-file {:path \&quot;/Users/gregadebesin/Development\&quot;\n                 :exec :list-dirs-files})&quot; &quot;(cetl-list-file {:path \&quot;/Users/gregadebesin/Development\&quot;\n                 :exec :list-dirs-sub-dirs})&quot; &quot;(cetl-list-file {:path \&quot;/Users/gregadebesin/Development\&quot;\n                 :exec :list-dirs})&quot; &quot;(cetl-archive-file {:path \&quot;/Users/gregadebesin/Development/Cetl/archive\&quot;\n                    :exec :zip-file})&quot; &quot;(cetl-archive-file {:path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                    :file \&quot;archive\&quot;\n                    :exec :zip-file})&quot; &quot;(cetl-archive-file {:path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                    :file \&quot;archive\&quot;\n                    :exec :gzip-file})&quot; &quot;(cetl-delete-file {:path \&quot;/Users/gregadebesin/Development\&quot;\n                   :file \&quot;foo.tmp\&quot;\n                   :exec :delete-file})&quot; &quot;(cetl-file-properties {:in-path \&quot;/Users/gregadebesin/Development/Cetl.zip\&quot;\n                       :exec :file-properties})&quot; &quot;(cetl-file-properties {:in-path \&quot;/Users/gregadebesin/Development/datomic-code.txt\&quot;\n                       :exec :file-properties})&quot; &quot;(cetl-file-properties {:path \&quot;/Users/gregadebesin/Development/datomic-code.txt\&quot;\n                       :exec :file-properties})&quot; &quot;(ns cetl.utils.component-utils\n  (:require [clojure.string :as s])\n  (java.io File))&quot; &quot;(ns cetl.utils.component-utils\n  (:require [clojure.string :as s]))&quot; &quot;(ns cetl.utils.component-utils\n  (:require [clojure.string :as s])\n  (import [java.io File]))&quot; &quot;(defn file-exists?\n  [path]\n  (let [file (File. path)]\n    (if\n      (or\n        (and (.exists file) (not (.isDirectory file)))) file)))&quot; &quot;(defn file-exists?\n  [path]\n  (let [file (File. path)]\n    (if\n      (or\n        (and (.exists file) (not (.isDirectory file)))) path)))&quot; &quot;(file-exists? \&quot;/Users/gregadebesin\&quot;)&quot; &quot;(defn file-exists?\n  [path]\n  (let [file (File. path)]\n    (if (or (and (.exists file) \n                 (not (.isDirectory file)))) \n      path)))&quot; &quot;(defn cetl-create-temp-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:exec x)\n        full-path (str (:path x) \&quot;/\&quot; (:file x))]\n    (if (= exec :create-temp-file)\n      (do\n        (io/writer\n          (io/file\n            (str path \&quot;/\&quot; file)))\n        (assoc x :result (vector full-path))))))&quot; &quot;(defn cetl-copy-file\n  [x]\n  (let [file (:file x)\n        in-path (:in-path x)\n        out-path (:out-path x)\n        exec (:exec x)]\n    (if (= exec :copy-file)\n      (do\n        (io/copy\n          (io/file (str in-path \&quot;/\&quot; file))\n          (io/file (str out-path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str (:in-path x) \&quot;/\&quot; (:file x))\n                                 (str (:out-path x) \&quot;/\&quot; (:file x))))))))&quot; &quot;(file-exists? \&quot;/Users/gregadebesin/Development/Cetl.zip\&quot;)&quot; &quot;(defn cetl-copy-file\n  [x]\n  (let [file (:file x)\n        in-path (:in-path x)\n        out-path (:out-path x)\n        exec (:exec x)\n        full-in-path (str (:in-path x) \&quot;/\&quot; (:file x))]\n    (if (and (= exec :copy-file) (file-exists? full-in-path))\n      (do\n        (io/copy\n          (io/file (str in-path \&quot;/\&quot; file))\n          (io/file (str out-path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str full-in-path)\n                                 (str (:out-path x) \&quot;/\&quot; (:file x))))))))&quot; &quot;(cetl-copy-file {:in-path \&quot;/Users/gregadebesin/Development\&quot;\n                 :out-path \&quot;/Users/gregadebesin\&quot;\n                 :file \&quot;foo.tmpa\&quot;\n                 :exec :copy-file})&quot; &quot;(cetl-copy-file {:in-path \&quot;/Users/gregadebesin/Development\&quot;\n                 :out-path \&quot;/Users/gregadebesin\&quot;\n                 :file \&quot;foo.tmp\&quot;\n                 :exec :copy-file})&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [file-exists?]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.io File)\n           (java.text SimpleDateFormat)))&quot; &quot;(mapcat inc [[1 2] [3 4]])&quot; &quot;(mapcat inc [2 1] [1 2])&quot; &quot;(map inc [[2 1] [1 2]])&quot; &quot;(mapcat inc [[2 1] [1 2]])&quot; &quot;(maocat reverse [[1 2 3] [3 4 5]])&quot; &quot;(mapcat reverse [[1 2 3] [3 4 5]])&quot; &quot;((comp inc) [[1 2 3] [3 4 5]])&quot; &quot;((comp flatten) [[1 2 3] [3 4 5]])&quot; &quot;((comp (map inc) flatten) [[1 2 3] [3 4 5]])&quot; &quot;((comp reverse  flatten) [[1 2 3] [3 4 5]])&quot; &quot;((comp #(map inc %) flatten) [[1 2 3] [3 4 5]])&quot; &quot;(cetl-list-file {:path \&quot;/Users/gregadebesin/Developmen\&quot;\n                 :exec :list-files})&quot; &quot;(defmulti cetl-list-file (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-list-file :list-dirs-files\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command \&quot; find `pwd` -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path path))\n      (assoc path :result\n                  (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str move-to-dir (:path path)\n                                next-command\n                                command))\n                         :out) #\&quot;\\n\&quot;))\n      (throw (IllegalArgumentException. (str (:path path) \&quot;is not a directory\&quot;))))))&quot; &quot;(cetl-list-file {:path \&quot;/Users/gregadebesin/Developmen\&quot;\n                 :exec :list-dirs-files})&quot; &quot;(defmethod cetl-list-file :list-dirs-files\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command \&quot; find `pwd` -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path path))\n      (assoc path :result\n                  (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str move-to-dir (:path path)\n                                next-command\n                                command))\n                         :out) #\&quot;\\n\&quot;))\n      (throw (IllegalArgumentException. (str (:path path) \&quot; is not a directory\&quot;))))))&quot; &quot;(defmethod cetl-list-file :list-files\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command  \&quot; find `pwd` -type f -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path path))\n      (assoc path :result\n                  (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str move-to-dir (:path path)\n                                next-command\n                                command))\n                         :out) #\&quot;\\n\&quot;))\n      (throw (IllegalArgumentException. (str (:path path) \&quot; is not a directory\&quot;))))))&quot; &quot;(defmethod cetl-list-file :list-dirs\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command  \&quot; find `pwd` -type d -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (assoc path :result\n                (s/split\n                  (get (clojure.java.shell/sh\n                         \&quot;sh\&quot; \&quot;-c\&quot;\n                         (str move-to-dir (:path path)\n                              next-command\n                              command))\n                       :out) #\&quot;\\n\&quot;))))&quot; &quot;(defmethod cetl-list-file :list-dirs\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command  \&quot; find `pwd` -type d -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path path))\n      (assoc path :result\n                  (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str move-to-dir (:path path)\n                                next-command\n                                command))\n                         :out) #\&quot;\\n\&quot;))\n      (throw (IllegalArgumentException. (:path path) \&quot; is not a directory\&quot;)))))&quot; &quot;(defmethod cetl-list-file :list-dirs\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command  \&quot; find `pwd` -type d -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path path))\n      (assoc path :result\n                  (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str move-to-dir (:path path)\n                                next-command\n                                command))\n                         :out) #\&quot;\\n\&quot;))\n      (throw (IllegalArgumentException. \n               (str (:path path) \&quot; is not a directory\&quot;))))))&quot; &quot;(defmethod cetl-list-file :list-dirs-sub-dirs\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command  \&quot; find `pwd` -type d \&quot;\n        next-command \&quot;;\&quot;]\n    (assoc path :result\n                (s/split\n                  (get (clojure.java.shell/sh\n                         \&quot;sh\&quot; \&quot;-c\&quot;\n                         (str move-to-dir (:path path)\n                              next-command\n                              command))\n                       :out) #\&quot;\\n\&quot;))))&quot; &quot;(defmethod cetl-list-file :list-dirs\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command  \&quot; find `pwd` -type d -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path path))\n      (assoc path :result\n                  (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str move-to-dir (:path path)\n                                next-command\n                                command))\n                         :out) #\&quot;\\n\&quot;))\n      (throw (IllegalArgumentException. (str (:path path) \&quot; is not a directory\&quot;))))))&quot; &quot;(defmethod cetl-list-file :list-dirs-sub-dirs\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command  \&quot; find `pwd` -type d \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path path))\n      (assoc path :result\n                  (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str move-to-dir (:path path)\n                                next-command\n                                command))\n                         :out) #\&quot;\\n\&quot;))\n      (throw (IllegalArgumentException. (str (:path path) \&quot; is not a directory\&quot;))))))&quot; &quot;(cetl-list-file {:path \&quot;/Users/gregadebesin/Developme\&quot;\n                 :exec :list-files})&quot; &quot;(cetl-list-file {:path \&quot;/Users/gregadebesin/Development\&quot;\n                 :exec :list-files})&quot; &quot;(cetl-list-file {:path \&quot;/Users/gregadebesin/Development\&quot;\n                 :exec :list-fils})&quot; &quot;(defmulti cetl-create-temp-file (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-create-temp-file :create-temp-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        exec (:exec x)\n        full-path (str (:path x) \&quot;/\&quot; (:file x))]\n    (do\n      (io/writer\n        (io/file\n          (str path \&quot;/\&quot; file)))\n      (assoc x :result (vector full-path)))))&quot; &quot;(defmethod cetl-create-temp-file :create-temp-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        full-path (str (:path x) \&quot;/\&quot; (:file x))]\n    (do\n      (io/writer\n        (io/file\n          (str path \&quot;/\&quot; file)))\n      (assoc x :result (vector full-path)))))&quot; &quot;(defmethod cetl-create-temp-file :create-temp-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        full-path (str (:path x) \&quot;/\&quot; (:file x))]\n    (if (dir-exists? path)\n      (do\n        (io/writer\n          (io/file\n            (str path \&quot;/\&quot; file)))\n        (assoc x :result (vector full-path)))\n      (throw (IllegalArgumentException. (str path \&quot; is not a directory\&quot;))))))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists?]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.io File)\n           (java.text SimpleDateFormat)))&quot; &quot;(use '[clojure.java.shell :only [sh]])&quot; &quot;(ns cetl.core-test\n  (:require [clojure.test :refer :all]\n            [cetl.core :refer :all]\n            [cetl.file.management :refer :all]))&quot; &quot;(cetl-create-temp-file {:path \&quot;/Uers/gregadebesin/Development\&quot;\n                        :file \&quot;foo.tmp\&quot;\n                        :exec :create-temp-file})&quot; &quot;(cetl-create-temp-file {:path \&quot;/Users/gregadebesin/Development\&quot;\n                        :file \&quot;foo.tmp\&quot;\n                        :exec :create-temp-file})&quot; &quot;(defmulti cetl-copy-file\n  [x]\n  (let [file (:file x)\n        in-path (:in-path x)\n        out-path (:out-path x)\n        exec (:exec x)\n        full-in-path (str (:in-path x) \&quot;/\&quot; (:file x))]\n    (cond (not (file-exists? full-in-path)) \n          (throw \n            (IllegalArgumentException.\n                   (str full-in-path \&quot; file does not exist\&quot;)))\n          (not (dir-exists? in-path))\n          (throw\n            (IllegalArgumentException. \n                   (str in-path \&quot; is not a directory\&quot;)))\n          (not (dir-exists? out-path))\n          (throw \n            (IllegalAccessException. \n                   (str out-path \&quot; is not a directory\&quot;)))\n          :else\n      (do\n        (io/copy\n          (io/file (str in-path \&quot;/\&quot; file))\n          (io/file (str out-path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str full-in-path)\n                                 (str (:out-path x) \&quot;/\&quot; (:file x))))))))&quot; &quot;(defmethod cetl-copy-file\n  [x]\n  (let [file (:file x)\n        in-path (:in-path x)\n        out-path (:out-path x)\n        exec (:exec x)\n        full-in-path (str (:in-path x) \&quot;/\&quot; (:file x))]\n    (cond (not (file-exists? full-in-path)) \n          (throw \n            (IllegalArgumentException.\n                   (str full-in-path \&quot; file does not exist\&quot;)))\n          (not (dir-exists? in-path))\n          (throw\n            (IllegalArgumentException. \n                   (str in-path \&quot; is not a directory\&quot;)))\n          (not (dir-exists? out-path))\n          (throw \n            (IllegalAccessException. \n                   (str out-path \&quot; is not a directory\&quot;)))\n          :else\n      (do\n        (io/copy\n          (io/file (str in-path \&quot;/\&quot; file))\n          (io/file (str out-path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str full-in-path)\n                                 (str (:out-path x) \&quot;/\&quot; (:file x))))))))&quot; &quot;(defmulti cetl-copy-file (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-copy-file :copy-file\n  [x]\n  (let [file (:file x)\n        in-path (:in-path x)\n        out-path (:out-path x)\n        exec (:exec x)\n        full-in-path (str (:in-path x) \&quot;/\&quot; (:file x))]\n    (cond (not (file-exists? full-in-path)) \n          (throw \n            (IllegalArgumentException.\n                   (str full-in-path \&quot; file does not exist\&quot;)))\n          (not (dir-exists? in-path))\n          (throw\n            (IllegalArgumentException. \n                   (str in-path \&quot; is not a directory\&quot;)))\n          (not (dir-exists? out-path))\n          (throw \n            (IllegalAccessException. \n                   (str out-path \&quot; is not a directory\&quot;)))\n          :else\n      (do\n        (io/copy\n          (io/file (str in-path \&quot;/\&quot; file))\n          (io/file (str out-path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str full-in-path)\n                                 (str (:out-path x) \&quot;/\&quot; (:file x))))))))&quot; &quot;(defmethod cetl-copy-file :copy-file\n  [x]\n  (let [file (:file x)\n        in-path (:in-path x)\n        out-path (:out-path x)\n        full-in-path (str (:in-path x) \&quot;/\&quot; (:file x))]\n    (cond (not (file-exists? full-in-path)) \n          (throw \n            (IllegalArgumentException.\n                   (str full-in-path \&quot; file does not exist\&quot;)))\n          (not (dir-exists? in-path))\n          (throw\n            (IllegalArgumentException. \n                   (str in-path \&quot; is not a directory\&quot;)))\n          (not (dir-exists? out-path))\n          (throw \n            (IllegalAccessException. \n                   (str out-path \&quot; is not a directory\&quot;)))\n          :else\n      (do\n        (io/copy\n          (io/file (str in-path \&quot;/\&quot; file))\n          (io/file (str out-path \&quot;/\&quot; file)))\n        (assoc x :result (vector (str full-in-path)\n                                 (str (:out-path x) \&quot;/\&quot; (:file x))))))))&quot;], :remote []}}</component>
</project>