<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1449438990452">{:repl-history {:ide [], :local [&quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists?]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.io File LineNumberReader FileReader)\n           (java.text SimpleDateFormat)))&quot; &quot;(defmethod cetl-touch-file :touch-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      () ())))&quot; &quot;(defmethod cetl-touch-file :touch-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      () )))&quot; &quot;(defmethod cetl-touch-file :touch-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        date (.parse Date. (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;))]\n    (if (file-exists? file-path)\n      (.setLastModified file-path (.getTime date))))) &quot; &quot;(defmethod cetl-touch-file :touch-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        date (Date. (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;))]\n    (if (file-exists? file-path)\n      (.setLastModified file-path (.getTime date))))) &quot; &quot;(defmethod cetl-touch-file :touch-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        date (Date. (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;))]\n    (if (file-exists? file-path)\n      (.setLastModified file-path (.getTime (.parse date)))))) &quot; &quot;(defmulti cetl-touch-file {:argslist '([map])}\n          (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-touch-file :touch-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        date (Date. (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;))]\n    (if (file-exists? file-path)\n      (.setLastModified file-path (.getDate (.parse date)))))) &quot; &quot;(defmethod cetl-touch-file :touch-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;)\n        date (Date.)]\n    (if (file-exists? file-path)\n      (.setLastModified file-path (.format date))))) &quot; &quot;(defmethod cetl-touch-file :touch-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;)\n        date (Date.)]\n    (if (file-exists? file-path)\n      (.setLastModified file-path date)))) &quot; &quot;(defmethod cetl-touch-file :touch-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;)\n        date (Date.)]\n    (if (file-exists? file-path)\n      (.setLastModified io/file file-path date)))) &quot; &quot;(defmethod cetl-touch-file :touch-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;)\n        date (Date.)]\n    (if (file-exists? file-path)\n      (.setLastModified File. file-path date)))) &quot; &quot;(defmethod cetl-touch-file :touch-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;)\n        date (Date.)]\n    (if (file-exists? file-path)\n      (.setLastModified (File. file-path) date)))) &quot; &quot;(defmethod cetl-touch-file :touch-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;)\n        date (Date.)]\n    (if (file-exists? file-path)\n      (.setLastModified (File. file-path) (.getTime date))))) &quot; &quot;(cetl-touch-file {:file \&quot;foo.txt\&quot;\n                  :path \&quot;/Users/gregadebesin/Development\&quot;\n                  :exec :touch-file})&quot; &quot;2&quot; &quot;(map inc (range 200))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists?]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.util Date)\n           (java.io File LineNumberReader FileReader)\n           (java.text SimpleDateFormat)))&quot; &quot;(ns cetl.core-test\n  (:require [clojure.test :refer :all]\n            [cetl.core :refer :all]\n            [cetl.file.management :refer :all]))&quot; &quot;(defrecord Rectangle [length width]\n  Shape\n  (area [t] (* length width))\n  (perimeter [t] (+ (* 2 length)\n                       (* 2 width))))&quot; &quot;(perimeter (-&gt;Rectangle 2 4))&quot; &quot;(ns cetl.core-test\n  (:require [clojure.test :refer :all]\n            [cetl.core :refer :all]\n            [cetl.file.management :refer :all]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists?]]))&quot; &quot;(defmulti cetl-file-management {:arglists '([map])}\n          (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-file-management :delete-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (io/delete-file (io/file (str path \&quot;/\&quot; file)))\n        (assoc x :result (str (:path x) \&quot;/\&quot; (:file x))))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(ns cetl.core-test\n  (:require [clojure.test :refer :all]\n            [cetl.core :refer :all]\n            [clojure.java.io :as io]\n            [cetl.file.management :refer :all]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists?]]))&quot; &quot;(cetl-file-management {:path \&quot;/Users/gra11/Development/file.txt\&quot;\n                       :file \&quot;foo\&quot;\n                       :exec :properties-file})&quot; &quot;(cetl-file-management {:path \&quot;/Users/gra11/Development\&quot;\n                       :file \&quot;file.txt\&quot;\n                       :exec :properties-file})&quot; &quot;(cetl-file-management {:path \&quot;/Users/gra11/Development\&quot;\n                       :file \&quot;file.txt\&quot;\n                       :exec :count-row-file})&quot; &quot;(-&gt;\n  (cetl-file-management {:path \&quot;/Users/gra11/Development\&quot;\n                         :file \&quot;file.txt\&quot;\n                         :exec :count-row-file}) [])&quot; &quot;(-&gt;&gt;\n  (cetl-file-management {:path \&quot;/Users/gra11/Development\&quot;\n                         :file \&quot;file.txt\&quot;\n                         :exec :count-row-file}) [])&quot; &quot;(-&gt;\n  (cetl-file-management {:path \&quot;/Users/gra11/Development\&quot;\n                         :file \&quot;file.txt\&quot;\n                         :exec :count-row-file}) (into {}))&quot; &quot;(-&gt; {:path \&quot;/Users/gra11/Development\&quot;\n     :file \&quot;file.txt\&quot;\n     :exec :count-row-file}\n  (cetl-file-management))&quot; &quot;(-&gt; {:path \&quot;/Users/gra11/Development\&quot;\n     :file \&quot;file.txt\&quot;\n     :exec :count-row-file} \n    (cetl-file-management)\n    (cetl-file-management))&quot; &quot;(-&gt;&gt; {:path \&quot;/Users/gra11/Development\&quot;\n     :file \&quot;file.txt\&quot;\n     :exec :count-row-file} \n    (cetl-file-management)\n    (assoc :exec :properties-file)\n    (cetl-file-management))&quot; &quot;(-&gt; {:path \&quot;/Users/gra11/Development\&quot;\n     :file \&quot;file.txt\&quot;\n     :exec :count-row-file} \n    (cetl-file-management)\n    (assoc :exec :properties-file)\n    (cetl-file-management))&quot; &quot;(-&gt; {:path \&quot;/Users/gra11/Development\&quot;\n     :file \&quot;file.txt\&quot;\n     :exec :count-row-file} \n    (cetl-file-management))&quot; &quot;(defmethod cetl-file-management :zip-file\n  [x]\n  (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n          (dir-exists? (:path x)))\n    (let [path (:path x)\n          file (:file x)\n          file-path (str path \&quot;/\&quot; file)]\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n        (assoc x\n          :result (str file-path \&quot;.zip\&quot;))))\n    (throw\n      (IllegalArgumentException.\n        (str  (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))&quot; &quot;(defprotocol Shape\n  (area [s] \&quot;Calculate the area of a shape\&quot;)\n  (perimeter [s] \&quot;Calculate the perimeter of a shape\&quot;))&quot; &quot;(defrecord Rectangle [length width]\n  Shape\n  (area [this] (* length width))\n  (perimeter [this] (+ (* 2 length)\n                       (* 2 width))))&quot; &quot;(defprotocol file-management-component\n  (zip-file [x] \&quot;Zip's a file\&quot;))&quot; &quot;(defrecord file-management \n  [path file exec result]\n  file-management-component\n  (zip-file [x] (if (or (file-exists? (str (path x) \&quot;/\&quot; (file x)))\n                        (dir-exists? (path x)))\n                  (let [path (path x)\n                        file (file x)\n                        file-path (str path \&quot;/\&quot; file)]\n                    (do\n                      (clojure.java.shell/sh\n                        \&quot;sh\&quot; \&quot;-c\&quot;\n                        (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n                      (assoc x\n                        result (str file-path \&quot;.zip\&quot;))))\n                  (throw\n                    (IllegalArgumentException.\n                      (str  (path x) \&quot;/\&quot; (file x) \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(area (-&gt;Rectangle 2 4))&quot; &quot;(get (-&gt;Rectangle 2 4) :length)&quot; &quot;(defrecord file-management \n  [x]\n  file-management-component\n  (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n          (dir-exists? (:path x)))\n    (let [path (:path x)\n          file (:file x)\n          file-path (str path \&quot;/\&quot; file)]\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n        (assoc x\n          :result (str file-path \&quot;.zip\&quot;))))\n    (throw\n      (IllegalArgumentException.\n        (str  (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))&quot; &quot;(defrecord file-management \n  [x]\n  file-management-component\n  (zip-file [x]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;))))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(-&gt;file-management {:path \&quot;/Users/gra11/Development\&quot;\n                    :file \&quot;file.txt\&quot;\n                    :exec :count-row-file})&quot; &quot;(-&gt;Rectangle 2 4)&quot; &quot;(defrecord file-management \n  [x]\n  file-management-component\n  (zip-file \n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defrecord file-management \n  [x]\n  file-management-component\n  (zip-file []\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(zip-file (-&gt;file-management {:path \&quot;/Users/gra11/Development\&quot;\n                              :file \&quot;file.txt\&quot;}))&quot; &quot;(defmethod cetl-file-management :gzip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        gzip-command \&quot; tar -cvzf \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.tar.gz\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (or (file-exists? file-path) (dir-exists? path))\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               gzip-command (str file file-ext \&quot; \&quot; file)))\n        (assoc x\n          :result (str file-path file-ext)))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-file-management :gzip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        gzip-command \&quot; tar -cvzf \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.tar.gz\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (or (file-exists? file-path) (dir-exists? path))\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir path next-command\n               gzip-command (str file file-ext \&quot; \&quot; file)))\n        (assoc x\n          :result (str file-path file-ext)))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defrecord file-management \n  [x]\n  file-management-component\n  (zip-file [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n  \n  (gzip-file [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz \&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n  \n  (gzip-file [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz \&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defprotocol file-management-component\n  (zip-file [x] \&quot;Zip's a file\&quot;)\n  (gzip-file [x] \&quot;Gzip's a file\&quot;))&quot; &quot;(defrecord file-management \n  [x]\n  file-management-component\n  (zip-file [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n  (gzip-file [this]\n    (let [move-to-dir \&quot; cd \&quot;\n          gzip-command \&quot; tar -cvzf \&quot;\n          next-command \&quot;;\&quot;\n          file-ext \&quot;.tar.gz\&quot;\n          path (:path x)\n          file (:file x)\n          file-path (str path \&quot;/\&quot; file)]\n      (if (or (file-exists? file-path) (dir-exists? path))\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str move-to-dir path next-command\n                 gzip-command (str file file-ext \&quot; \&quot; file)))\n          (assoc x\n            :result (str file-path file-ext)\n            :exec :gzip))\n        (throw\n          (IllegalArgumentException.\n            (str file-path \&quot; is not a file (or a directory)\&quot;)))))))&quot; &quot;(gzip-file (-&gt;file-management {:path \&quot;/Users/gra1/Development\&quot;\n                               :file \&quot;file.txt\&quot;}))&quot; &quot;(gzip-file (-&gt;file-management {:path \&quot;/Users/gra11/Development\&quot;\n                               :file \&quot;file.txt\&quot;}))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (let [j \&quot;\&quot;]\n    (zip-file [this]\n              (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n                      (dir-exists? (:path x)))\n                (let [path (:path x)\n                      file (:file x)\n                      file-path (str path \&quot;/\&quot; file)]\n                  (do\n                    (clojure.java.shell/sh\n                      \&quot;sh\&quot; \&quot;-c\&quot;\n                      (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n                    (assoc x\n                      :result (str file-path \&quot;.zip\&quot;)\n                      :exec :zip-file)))\n                (throw\n                  (IllegalArgumentException.\n                    (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n    (gzip-file [this]\n               (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n                       (dir-exists? (:path x)))\n                 (let [path (:path x)\n                       file (:file x)\n                       file-path (str path \&quot;/\&quot; file)]\n                   (do\n                     (clojure.java.shell/sh\n                       \&quot;sh\&quot; \&quot;-c\&quot;\n                       (str \&quot; cd \&quot; path \&quot;;\&quot;\n                            \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n                     (assoc x\n                       :result (str file-path \&quot;.tar.gz \&quot;)\n                       :exec :gzip)))\n                 (throw\n                   (IllegalArgumentException.\n                     (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz \&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(zip-file (-&gt;file-management {:path \&quot;/Users/gra11/Development\&quot;\n                              :file \&quot;file.txt\&quot;\n                              :exec :count-row-file}))&quot; &quot;(-&gt; {:path \&quot;/Users/gra11/Development\&quot;\n     :file \&quot;file.txt\&quot;\n     :exec :count-row-file}\n  (zip-file (-&gt;file-management)))&quot; &quot;(-&gt;&gt; {:path \&quot;/Users/gra11/Development\&quot;\n     :file \&quot;file.txt\&quot;\n     :exec :count-row-file}\n  (zip-file (-&gt;file-management)))&quot; &quot;(-&gt;&gt; {:path \&quot;/Users/gra11/Development\&quot;\n     :file \&quot;file.txt\&quot;\n     :exec :count-row-file}\n     (-&gt;file-management)\n     (zip-file))&quot; &quot;(-&gt; {:path \&quot;/Users/gra11/Development\&quot;\n     :file \&quot;file.txt\&quot;\n     :exec :count-row-file}\n     (-&gt;file-management)\n     (zip-file))&quot; &quot;(-&gt; {:path \&quot;/Users/gra11/Development\&quot;\n     :file \&quot;file.txt\&quot;\n     :exec :count-row-file}\n    (-&gt;file-management)\n    (zip-file))&quot; &quot;(-&gt; {:path \&quot;/Users/gra11/Development\&quot;\n     :file \&quot;file.txt\&quot;\n     :exec :count-row-file}\n    (-&gt;file-management)\n    (zip-file)\n    (gzip-file))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz\&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz \&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz\&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(-&gt; {:path \&quot;/Users/gra11/Development\&quot;\n     :file \&quot;file.txt\&quot;\n     :exec :count-row-file}\n    (-&gt;file-management)\n    (zip-file)\n    (-&gt;file-management)\n    (gzip-file))&quot; &quot;(-&gt; {:path \&quot;/Users/gra11/Development\&quot;\n     :file \&quot;file.txt\&quot;}\n    (-&gt;file-management)\n    (zip-file)\n    (-&gt;file-management)\n    (gzip-file))&quot; &quot;(macroexpand if)&quot; &quot;(macroexpand 'if)&quot; &quot;(clojure.repl/source if)&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists?]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.util Date)\n           (java.io File LineNumberReader)\n           (java.text SimpleDateFormat)))&quot; &quot;(use '[clojure.java.shell :only [sh]])&quot; &quot;(read-string \&quot;(+ 1 2 3)\&quot;)&quot; &quot;(eval (read-string \&quot;(+ 1 2 3)\&quot;))&quot; &quot;(eval (read-string  '(+ 1 2 3)))&quot; &quot;(cons '+ (1 2 3))&quot; &quot;(cons '+ '(1 2 3))&quot; &quot;(defmacro if-filter-pred\n  [test &amp; body]\n  (list 'if test))&quot; &quot;(macroexpand 'if-filter-pred)&quot; &quot;(macroexpand-1 'if-filter-pred)&quot; &quot;(macroexpand-1 if-filter-pred)&quot; &quot;(macroexpand-1 '(if-filter-pred))&quot; &quot;(macroexpand-1 '(if-filter-pred true))&quot; &quot;(defmacro if-filter-pred\n  [test &amp; body]\n  (list 'if test (cons 'do body)))&quot; &quot;(macroexpand-1 'when)&quot; &quot;(macroexpand-1 '(when))&quot; &quot;(macroexpand-1 '(when true))&quot; &quot;(macroexpand-1 )&quot; &quot;(defmacro if-filter-pred\n  [test &amp; body]\n  (list 'if test ))&quot; &quot;(if true (filter even? '()))&quot; &quot;(defmacro if-filter-pred\n  [test &amp; body]\n  (list 'if test (list 'filter 'even body)))&quot; &quot;(defmacro if-filter-pred\n  [test &amp; body]\n  (list 'if test (cons 'filter 'even? body)))&quot; &quot;(defmacro if-filter-pred\n  [test &amp; body]\n  (list 'if test (cons 'filter (cons 'even? body))))&quot; &quot;(macroexpand-1 '(if-filter-pred 22))&quot; &quot;(if-filter-pred true [1 2 3 4 5])&quot;], :remote []}}</component>
</project>