<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1443043955838">{:repl-history {:ide [], :local [&quot;(dataset [:col0 :col1] (cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.csv\&quot; :delim \\x))&quot; &quot;(dataset [] (cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.csv\&quot; :delim \\x))&quot; &quot;(dataset (cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.csv\&quot; :delim \\x))&quot; &quot;(dataset  (cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.csv\&quot; :delim \\x))&quot; &quot;(def ^:dynamic **datasets**\n  {\n   :iris {:filename \&quot;data/iris.dat\&quot;\n          :delim \\space\n          :header true}})&quot; &quot;(def ^:dynamic **datasets**\n  {\n   :iris {:filename \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.csv\&quot;\n          :delim \\x\n          :header true}})&quot; &quot;(defn get-dataset\n  \&quot;\n  Returns the sample dataset associated with the given key. Most datasets\n  are from R's sample data sets, as are the descriptions below.\n  Options:\n    :incanter-home -- if the incanter.home property is not set when the JVM is\n                      started (using -Dincanter.home) or there is no INCANTER_HOME\n                      environment variable set, use the :incanter-home options to\n                      provide the parent directory of the sample data directory.\n    :from-repo (default false) -- If true, retrieves the dataset from the online repository\n                       instead of locally, it will do this by default if incanter-home is not set.\n  Datasets:\n    :iris -- the Fisher's or Anderson's Iris data set gives the\n             measurements in centimeters of the variables sepal\n             length and width and petal length and width,\n             respectively, for 50 flowers from each of 3 species\n             of iris.\n    :cars -- The data give the speed of cars and the distances taken\n              to stop. Note that the data were recorded in the 1920s.\n    :survey -- survey data used in Scott Lynch's 'Introduction to Applied Bayesian Statistics\n               and Estimation for Social Scientists'\n    :us-arrests -- This data set contains statistics, in arrests per 100,000\n                   residents for assault, murder, and rape in each of the 50 US\n                   states in 1973. Also given is the percent of the population living\n                   in urban areas.\n    :flow-meter -- flow meter data used in Bland Altman Lancet paper.\n    :co2 -- has 84 rows and 5 columns of data from an experiment on the cold tolerance\n            of the grass species _Echinochloa crus-galli_.\n    :chick-weight -- has 578 rows and 4 columns from an experiment on the effect of diet\n                     on early growth of chicks.\n    :plant-growth -- Results from an experiment to compare yields (as measured by dried\n                     weight of plants) obtained under a control and two different\n                     treatment conditions.\n    :pontius -- These data are from a NIST study involving calibration of load cells.\n                The response variable (y) is the deflection and the predictor variable\n                (x) is load.\n                See http://www.itl.nist.gov/div898/strd/lls/data/Pontius.shtml\n    :filip -- NIST data set for linear regression certification,\n              see http://www.itl.nist.gov/div898/strd/lls/data/Filip.shtml\n    :longely -- This classic dataset of labor statistics was one of the first used to\n                test the accuracy of least squares computations. The response variable\n                (y) is the Total Derived Employment and the predictor variables are GNP\n                Implicit Price Deflator with Year 1954 = 100 (x1), Gross National Product\n                (x2), Unemployment (x3), Size of Armed Forces (x4), Non-Institutional\n                Population Age 14 &amp; Over (x5), and Year (x6).\n                See http://www.itl.nist.gov/div898/strd/lls/data/Longley.shtml\n    :Chwirut -- These data are the result of a NIST study involving ultrasonic calibration.\n                The response variable is ultrasonic response, and the predictor variable is\n                metal distance.\n                See http://www.itl.nist.gov/div898/strd/nls/data/LINKS/DATA/Chwirut1.dat\n    :thurstone -- test data for non-linear least squares.\n    :austres -- Quarterly Time Series of the Number of Australian Residents\n    :hair-eye-color -- Hair and eye color of sample of students\n    :airline-passengers -- Monthly Airline Passenger Numbers 1949-1960\n    :math-prog -- Pass/fail results for a high school mathematics assessment test\n                  and a freshmen college programming course.\n    :iran-election -- Vote counts for 30 provinces from the 2009 Iranian election.\n   Examples:\n     (def data (get-dataset :cars))\n     (def data2 (get-dataset :cars :incanter.home \\\&quot;/usr/local/packages/incanter\\\&quot;))\n  \&quot;\n  ([dataset-key &amp; {:keys [incanter-home from-repo]\n                   :or {incanter-home (or (System/getProperty \&quot;incanter.home\&quot;)\n                                          (System/getenv \&quot;INCANTER_HOME\&quot;))\n                        from-repo false}}]\n   (when-let [ds (**datasets** dataset-key)]\n     (let [filename (if (and (not from-repo) (not (nil? incanter-home)))\n                      (str incanter-home \&quot;/\&quot; (ds :filename))\n                      (str **datasets-base-url** (ds :filename)))\n           delim (ds :delim)\n           header (ds :header)]\n       (read-dataset filename :delim delim :header header)))))&quot; &quot;(defn get-dataset\n  \&quot;\n  Returns the sample dataset associated with the given key. Most datasets\n  are from R's sample data sets, as are the descriptions below.\n  Options:\n    :incanter-home -- if the incanter.home property is not set when the JVM is\n                      started (using -Dincanter.home) or there is no INCANTER_HOME\n                      environment variable set, use the :incanter-home options to\n                      provide the parent directory of the sample data directory.\n    :from-repo (default false) -- If true, retrieves the dataset from the online repository\n                       instead of locally, it will do this by default if incanter-home is not set.\n  Datasets:\n    :iris -- the Fisher's or Anderson's Iris data set gives the\n             measurements in centimeters of the variables sepal\n             length and width and petal length and width,\n             respectively, for 50 flowers from each of 3 species\n             of iris.\n    :cars -- The data give the speed of cars and the distances taken\n              to stop. Note that the data were recorded in the 1920s.\n    :survey -- survey data used in Scott Lynch's 'Introduction to Applied Bayesian Statistics\n               and Estimation for Social Scientists'\n    :us-arrests -- This data set contains statistics, in arrests per 100,000\n                   residents for assault, murder, and rape in each of the 50 US\n                   states in 1973. Also given is the percent of the population living\n                   in urban areas.\n    :flow-meter -- flow meter data used in Bland Altman Lancet paper.\n    :co2 -- has 84 rows and 5 columns of data from an experiment on the cold tolerance\n            of the grass species _Echinochloa crus-galli_.\n    :chick-weight -- has 578 rows and 4 columns from an experiment on the effect of diet\n                     on early growth of chicks.\n    :plant-growth -- Results from an experiment to compare yields (as measured by dried\n                     weight of plants) obtained under a control and two different\n                     treatment conditions.\n    :pontius -- These data are from a NIST study involving calibration of load cells.\n                The response variable (y) is the deflection and the predictor variable\n                (x) is load.\n                See http://www.itl.nist.gov/div898/strd/lls/data/Pontius.shtml\n    :filip -- NIST data set for linear regression certification,\n              see http://www.itl.nist.gov/div898/strd/lls/data/Filip.shtml\n    :longely -- This classic dataset of labor statistics was one of the first used to\n                test the accuracy of least squares computations. The response variable\n                (y) is the Total Derived Employment and the predictor variables are GNP\n                Implicit Price Deflator with Year 1954 = 100 (x1), Gross National Product\n                (x2), Unemployment (x3), Size of Armed Forces (x4), Non-Institutional\n                Population Age 14 &amp; Over (x5), and Year (x6).\n                See http://www.itl.nist.gov/div898/strd/lls/data/Longley.shtml\n    :Chwirut -- These data are the result of a NIST study involving ultrasonic calibration.\n                The response variable is ultrasonic response, and the predictor variable is\n                metal distance.\n                See http://www.itl.nist.gov/div898/strd/nls/data/LINKS/DATA/Chwirut1.dat\n    :thurstone -- test data for non-linear least squares.\n    :austres -- Quarterly Time Series of the Number of Australian Residents\n    :hair-eye-color -- Hair and eye color of sample of students\n    :airline-passengers -- Monthly Airline Passenger Numbers 1949-1960\n    :math-prog -- Pass/fail results for a high school mathematics assessment test\n                  and a freshmen college programming course.\n    :iran-election -- Vote counts for 30 provinces from the 2009 Iranian election.\n   Examples:\n     (def data (get-dataset :cars))\n     (def data2 (get-dataset :cars :incanter.home \\\&quot;/usr/local/packages/incanter\\\&quot;))\n  \&quot;\n  ([dataset-key &amp; {:keys [incanter-home from-repo]\n                   :or {incanter-home (or (System/getProperty \&quot;incanter.home\&quot;)\n                                          (System/getenv \&quot;INCANTER_HOME\&quot;))\n                        from-repo false}}]\n   (when-let [ds (**datasets** dataset-key)]\n     (let [filename  (str incanter-home \&quot;/\&quot; (ds :filename))\n           delim (ds :delim)\n           header (ds :header)]\n       (read-dataset filename :delim delim :header header)))))&quot; &quot;(defn get-dataset\n  ([dataset-key &amp; {:keys [incanter-home from-repo]\n                   :or {incanter-home (or (System/getProperty \&quot;incanter.home\&quot;)\n                                          (System/getenv \&quot;INCANTER_HOME\&quot;))\n                        from-repo false}}]\n   (when-let [ds (**datasets** dataset-key)]\n     (let [filename  (str incanter-home \&quot;/\&quot; (ds :filename))\n           delim (ds :delim)\n           header (ds :header)]\n       (cetl-input-file-delimited filename :delim delim :header header)))))&quot; &quot;(get-dataset :iris)&quot; &quot;\n(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs? include-hidden-files?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d \&quot;))\n              :out) #\&quot;\\n\&quot;))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false)\n           (= include-hidden-files? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false)\n           (= include-hidden-files? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false)\n           (= include-hidden-files? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true)\n           (= include-hidden-files? false))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;\n(defn cetl-file-list\n  ([path &amp; {:keys\n                [dirs-only? files-only? dirs-&amp;-files?\n                 include-sub-dirs? include-hidden-files?]\n            :or {include-sub-dirs? false}}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (and (= dirs-&amp;-files? true)\n            (= include-sub-dirs? false)\n            (= include-hidden-files? false))\n       (dirs-&amp;-files path)\n       (and (= files-only? true)\n            (= include-sub-dirs? false)\n            (= include-hidden-files? false))\n       (files-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? false)\n            (= include-hidden-files? false))\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true)\n            (= include-hidden-files? false))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;\n(defn cetl-file-list\n  ([path &amp; {:keys\n                [dirs-only? files-only? dirs-&amp;-files?\n                 include-sub-dirs? include-hidden-files?]\n            :or {include-sub-dirs? false}}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (and (= dirs-&amp;-files? true)\n            (= include-hidden-files? false))\n       (dirs-&amp;-files path)\n       (and (= files-only? true)\n            (= include-hidden-files? false))\n       (files-only path)\n       (and (= dirs-only? true)\n            (= include-hidden-files? false))\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true)\n            (= include-hidden-files? false))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development/Cetl/TestFiles\&quot; :dirs-&amp;-files? true :include-hidden-files? false)&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development/Cetl/TestFiles\&quot; :dirs-&amp;-files? true :include-sub_dirs? false :include-hidden-files? false)&quot; &quot;(defn cetl-file-list\n  ([path &amp; {:keys\n            [dirs-only? files-only? dirs-&amp;-files?\n             include-sub-dirs?]}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (and (= dirs-&amp;-files? true)\n            (= include-sub-dirs? false))\n       (dirs-&amp;-files path)\n       (and (= files-only? true)\n            (= include-sub-dirs? false))\n       (files-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? false))\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;(defn cetl-file-list\n  ([path &amp; {:keys\n            [dirs-only? files-only? dirs-&amp;-files?\n             include-sub-dirs?]\n            :or {include-sub-dirs? false}}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (and (= dirs-&amp;-files? true)\n            (= include-sub-dirs? false))\n       (dirs-&amp;-files path)\n       (and (= files-only? true)\n            (= include-sub-dirs? false))\n       (files-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? false))\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;(defn cetl-file-list\n  ([path &amp; {:keys\n            [dirs-only? files-only? dirs-&amp;-files?\n             include-sub-dirs?]\n            :or {include-sub-dirs? false}}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (and (= dirs-&amp;-files? true))\n       (dirs-&amp;-files path)\n       (and (= files-only? true))\n       (files-only path)\n       (and (= dirs-only? true))\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development/Cetl/TestFiles\&quot; :dirs-&amp;-files? true)&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development/Cetl/TestFiles\&quot; :dirs-only? true :include-sub-dirs? true)&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development/Cetl\&quot; :dirs-only? true :include-sub-dirs? true)&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development\&quot; :dirs-only? true)&quot; &quot;(defn cetl-file-list\n  ([path &amp; {:keys\n            [dirs-only? files-only? dirs-&amp;-files?\n             include-sub-dirs?]\n            :or {include-sub-dirs? false}}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (= dirs-&amp;-files? true)\n       (dirs-&amp;-files path)\n       (= files-only? true)\n       (files-only path)\n       (= dirs-only? true)\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;(defn cetl-file-list\n  ([path &amp; {:keys\n            [dirs-only? files-only? dirs-&amp;-files?\n             include-sub-dirs?]\n        :or {include-sub-dirs? false}}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (= dirs-&amp;-files? true)\n       (dirs-&amp;-files path)\n       (= files-only? true)\n       (files-only path)\n       (= dirs-only? true)\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot; \n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d \&quot;))\n              :out) #\&quot;\\n\&quot;))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development\&quot; :dirs-only? true :include-sub-dirs? true)&quot; &quot;(get (clojure.java.shell/sh\n       \&quot;sh\&quot; \&quot;-c\&quot;\n       (str \&quot; cd \&quot; p \&quot;;\&quot;\n            \&quot; find `pwd` -type d \&quot;))\n     :out) #\&quot;\\n\&quot;)&quot; &quot;(get (clojure.java.shell/sh\n       \&quot;sh\&quot; \&quot;-c\&quot;\n       (str \&quot; cd \&quot; p \&quot;;\&quot;\n            \&quot; find `pwd` -type d \&quot;))\n     :out)&quot; &quot;(get (clojure.java.shell/sh\n       \&quot;sh\&quot; \&quot;-c\&quot;\n       (str \&quot; cd \&quot;  \&quot;/Users/gregadebesin/Development\&quot; \&quot;;\&quot;\n            \&quot; find `pwd` -type d \&quot;))\n     :out)&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d \&quot;))\n              :out) #\&quot;\\n\&quot;))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development\&quot; \n                :dirs-only? true \n                :include-sub-dirs? false)&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d \&quot;))\n              :out) #\&quot;\\n\&quot;))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path)\n      :else nil)))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d \&quot;))\n              :out) #\&quot;\\n\&quot;))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n     \n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development\&quot; \n                :dirs-only? true \n                :include-sub-dirs? true)&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs? include-hidden-files?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d \&quot;))\n              :out) #\&quot;\\n\&quot;))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false)\n           (= include-hidden-files? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false)\n           (= include-hidden-files? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false)\n           (= include-hidden-files? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true)\n           (= include-hidden-files? false))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development\&quot; \n                :dirs-only? true \n                :include-sub-dirs? true\n                :include-hidden-files? false)&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development/\&quot; \n                :dirs-only? true \n                :include-sub-dirs? true\n                :include-hidden-files? false)&quot; &quot;22&quot; &quot;(defn foo \n  ([x &amp; {:keys [baz]\n         :or [baz false]}]))&quot; &quot;(defmulti greeting\n          (fn[x] (x \&quot;language\&quot;)))&quot; &quot;(defmethod greeting \&quot;English\&quot; [params]\n  \&quot;Hello!\&quot;)&quot; &quot;(defmethod greeting \&quot;French\&quot; [params]\n  \&quot;Bonjour!\&quot;)&quot; &quot;(defmethod greeting :default [params]\n  (throw (IllegalArgumentException.\n           (str \&quot;I don't know the \&quot; (params \&quot;language\&quot;) \&quot; language\&quot;))))&quot; &quot;(def  french-map {\&quot;id\&quot; \&quot;2\&quot;, \&quot;language\&quot; \&quot;French\&quot;})&quot; &quot;(def spanish-map {\&quot;id\&quot; \&quot;3\&quot;, \&quot;language\&quot; \&quot;Spanish\&quot;})&quot; &quot;(defmethod greeting \&quot;\&quot; [params]\n  \&quot;Hello!\&quot;)&quot; &quot;(greeting french-map)&quot; &quot;(defmethod greeting \&quot;fff\&quot; [params]\n  \&quot;Hello!\&quot;)&quot; &quot;(def english-map {\&quot;id\&quot; \&quot;1\&quot;, \&quot;language\&quot; \&quot;English\&quot;})&quot; &quot;(defmethod greeting \&quot;French\&quot; [params]\n   \&quot;Bonjour!\&quot;)&quot; &quot;(defmethod greeting :default [params]\n    (throw (IllegalArgumentException.\n             (str \&quot;I don't know the \&quot; (params \&quot;language\&quot;) \&quot; language\&quot;))))&quot; &quot;(greeting spanish-map)&quot; &quot;(greeting english-map)&quot; &quot;(defmulti dirs-only-command (fn [x] (:dirs-only? x)))&quot; &quot;(defmulti execute-command (fn [x] (:command x)))&quot; &quot;(defmethod full-moon-behavior :wolf\n  [were-creature]\n  (str (:name were-creature) \&quot; will howl and murder\&quot;))&quot; &quot;(full-moon-behavior {:were-type :wolf\n                     :name \&quot;Rachel from next door\&quot;})&quot; &quot;2&quot; &quot;(partil + 3)&quot; &quot;(defmulti full-moon-behavior (fn [were-creature] (:were-type were-creature)))&quot; &quot;(defmethod full-moon-behavior :wolf\n  [were-creature]\n  (+ 8 8))&quot; &quot;(defmethod full-moon-behavior :simmons\n  [were-creature]\n  (str (:name were-creature) \&quot; will encourage people and sweat to the oldies\&quot;))&quot; &quot;(full-moon-behavior {:were-type :wolf})&quot; &quot;(full-moon-behavior {:name \&quot;Andy the baker\&quot;\n                     :were-type :simmons})&quot; &quot;(defmethod cetl-file-list :dirs-and-files\n  [path]\n  (clojure.string/split\n    (get (clojure.java.shell/sh\n           \&quot;sh\&quot; \&quot;-c\&quot;\n           (str \&quot; cd \&quot; p \&quot;;\&quot;\n                \&quot; find `pwd` -maxdepth 1 \&quot;))\n         :out) #\&quot;\\n\&quot;))&quot; &quot;(defmethod cetl-file-list :dirs-and-files\n  [path]\n  (clojure.string/split\n    (get (clojure.java.shell/sh\n           \&quot;sh\&quot; \&quot;-c\&quot;\n           (str \&quot; cd \&quot; path \&quot;;\&quot;\n                \&quot; find `pwd` -maxdepth 1 \&quot;))\n         :out) #\&quot;\\n\&quot;))&quot; &quot;(cetl-file-list )&quot; &quot;(defmethod cetl-file-list :dirs-and-files\n  [path]\n  (clojure.string/split\n    (get (clojure.java.shell/sh\n           \&quot;sh\&quot; \&quot;-c\&quot;\n           (str \&quot; cd \&quot; (:list path) \&quot;;\&quot;\n                \&quot; find `pwd` -maxdepth 1 \&quot;))\n         :out) #\&quot;\\n\&quot;))&quot; &quot;(defmulti cetl-file-list (fn [x] (:list x)))&quot; &quot;(defmethod cetl-file-list :dirs-and-files\n  [path]\n  (clojure.string/split\n    (get (clojure.java.shell/sh\n           \&quot;sh\&quot; \&quot;-c\&quot;\n           (str \&quot; cd \&quot; (:path path) \&quot;;\&quot;\n                \&quot; find `pwd` -maxdepth 1 \&quot;))\n         :out) #\&quot;\\n\&quot;))&quot; &quot;(defmethod cetl-file-list :files\n  [path]\n  (clojure.string/split\n    (get (clojure.java.shell/sh\n           \&quot;sh\&quot; \&quot;-c\&quot;\n           (str \&quot; cd \&quot; (:path path) \&quot;;\&quot;\n                \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n         :out) #\&quot;\\n\&quot;))&quot; &quot;(cetl-file-list {:path \&quot;/Users/gregadebesin/Development\&quot;\n                 :list :dirs-and-files})&quot; &quot;(defmethod cetl-file-list :dirs\n  [path]\n  (clojure.string/split\n    (get (clojure.java.shell/sh\n           \&quot;sh\&quot; \&quot;-c\&quot;\n           (str \&quot; cd \&quot; (:path path) \&quot;;\&quot;\n                \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n         :out) #\&quot;\\n\&quot;))&quot; &quot;(cetl-file-list {:path \&quot;/Users/gregadebesin/Development\&quot;\n                 :list :files})&quot; &quot;(cetl-file-list {:path \&quot;/Users/gregadebesin/Development\&quot;\n                 :list :dirs})&quot; &quot;(defmethod cetl-file-list :files-only-sub-dirs\n  []\n  )&quot; &quot;(defmethod cetl-file-list :dirs-only-sub-dirs\n  [path]\n  (clojure.string/split\n    (get (clojure.java.shell/sh\n           \&quot;sh\&quot; \&quot;-c\&quot;\n           (str \&quot; cd \&quot; {:path path} \&quot;;\&quot;\n                \&quot; find `pwd` -type d \&quot;))\n         :out) #\&quot;\\n\&quot;))&quot; &quot;(cetl-file-list {:path \&quot;/Users/gregadebesin/Development\&quot;\n                 :list :dirs-only-sub-dirs})&quot; &quot;(defn cetl-file-archive\n  [path &amp; {:keys [archive-format]}]\n  (letfn\n    [(zip\n       [p]\n       (clojure.java.shell/sh\n         \&quot;sh\&quot; \&quot;-c\&quot;\n         (str \&quot; cd \&quot; (.getParent (File. p)) \&quot;/;\&quot;\n              \&quot; zip \&quot; (last (s/split p #\&quot;/\&quot;)) \&quot;.zip\&quot;\n              \&quot; -r \&quot; (last (s/split p #\&quot;/\&quot;)))))\n     (gzip\n       [p]\n       (clojure.java.shell/sh\n         \&quot;sh\&quot; \&quot;-c\&quot;\n         (str \&quot; cd \&quot; (.getParent (File. p)) \&quot;/;\&quot;\n              \&quot; tar -cvzf \&quot; (last (s/split p #\&quot;/\&quot;)) \&quot;.tar.gz\&quot;\n              \&quot; \&quot; (last (s/split p #\&quot;/\&quot;)))))]\n    (cond\n      (= archive-format :zip) (zip path)\n      (= archive-format :gzip) (gzip path))))&quot; &quot;(defmulti cetl-file-archive (fn [x] (:archive x)))&quot; &quot;(defmethod cetl-file-archive :zip \n  [path]\n  (clojure.java.shell/sh\n    \&quot;sh\&quot; \&quot;-c\&quot;\n    (str \&quot; cd \&quot; (.getParent (File. (:path path))) \&quot;/;\&quot;\n         \&quot; zip \&quot; (last (s/split (:path path) #\&quot;/\&quot;)) \&quot;.zip\&quot;\n         \&quot; -r \&quot; (last (s/split (:path path) #\&quot;/\&quot;)))))&quot; &quot;(cetl-file-archive {:path \&quot;/\&quot;})&quot; &quot;(cetl-file-archive {:path \&quot;/Users/gregadebesin/Development/Cetl/archive\&quot;\n                    :archive :zip})&quot; &quot;(defmethod cetl-file-archive :gzip \n  [path]\n  (clojure.java.shell/sh\n    \&quot;sh\&quot; \&quot;-c\&quot;\n    (str \&quot; cd \&quot; (.getParent (File. (:path path))) \&quot;/;\&quot;\n         \&quot; tar -cvzf \&quot; (last (s/split (:path path) #\&quot;/\&quot;)) \&quot;.tar.gz\&quot;\n         \&quot; \&quot; (last (s/split (:path path) #\&quot;/\&quot;)))))&quot; &quot;(cetl-file-archive)&quot; &quot;(defmethod cetl-file-encode :UTF-8\n  [path]\n  (FileUtils/write\n     (File. (:out-path path))\n     (FileUtils/readFileToString\n       (File. (:in-path path)) (:encode path)) \&quot;ISO-8859-15\&quot;))&quot; &quot;(cetl-file-archive {:path \&quot;/Users/gregadebesin/Development/Cetl/archive\&quot;\n                    :archive :gzip})&quot; &quot;(defmethod cetl-file-encode :UTF-8\n  [path]\n  (FileUtils/write\n     (File. (:path path))\n     (FileUtils/readFileToString\n       (File. (:path path)) (:encode path)) \&quot;ISO-8859-15\&quot;))&quot; &quot;(defmethod cetl-file-encode \&quot;UTF-8\&quot;\n  [path]\n  (FileUtils/write\n     (File. (:path path))\n     (FileUtils/readFileToString\n       (File. (:path path)) (:encode path)) \&quot;ISO-8859-15\&quot;))&quot; &quot;(cetl-file-encode {:path \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file.txt\&quot;\n                   :encode \&quot;UTF-8\&quot;})&quot; &quot;(str :foo)&quot; &quot;(name :foo)&quot; &quot;(defmethod cetl-file-encode :UTF-8\n  [path]\n  (FileUtils/write\n     (File. (:path path))\n     (FileUtils/readFileToString\n       (File. (:path path)) (:encode (name path))) \&quot;ISO-8859-15\&quot;))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s])\n  (:import (org.apache.commons.io FileUtils)\n           (java.io File)))&quot; &quot;(use '[clojure.java.shell :only [sh]])&quot; &quot;(defmulti cetl-file-encode (fn [x] (:encode x)))&quot; &quot;(defmethod cetl-file-encode :UTF-8\n  [path]\n  (FileUtils/write\n     (File. (:path path))\n     (FileUtils/readFileToString\n       (File. (:path path)) (name (:encode path))) \&quot;ISO-8859-15\&quot;))&quot; &quot;(cetl-file-encode {:path \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file.txt\&quot;\n                   :encode :UTF-8})&quot; &quot;(defmethod cetl-file-encode :ISO-8859-15\n  [path]\n  (FileUtils/write\n    (File. (:path path))\n    (FileUtils/readFileToString\n      (File. (:path path)) (name (:encode path))) \&quot;UTF-8\&quot;))&quot; &quot;(defmethod cetl-file-encode :UTF-8\n  [x]\n  (FileUtils/write\n     (File. (:path x))\n     (FileUtils/readFileToString\n       (File. (:path x)) (name (:encode x))) \&quot;ISO-8859-15\&quot;))&quot; &quot;(defmethod cetl-file-encode :ISO-8859-15\n  [x]\n  (FileUtils/write\n    (File. (:path x))\n    (FileUtils/readFileToString\n      (File. (:path x)) (name (:encode x))) \&quot;UTF-8\&quot;))&quot;], :remote []}}</component>
</project>

