<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1442437085326">{:repl-history {:ide [], :local [&quot;(ns cetl.file.management\n  (:require [clojure.core.async :refer [chan &lt;!! &gt;!! &gt;! &lt;! put! take! close!\n                                        sliding-buffer\n                                        dropping-buffer\n                                        thread go]]\n            [clojure.string :as s]\n            [cetl.utils.component-utils :as c-utils])\n  (:import (java.io File FileFilter)))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-sub-dirs\n       [p]\n       (clojure.string/split\n         \&quot;\&quot; \&quot;\&quot;\n         ))]\n    (cond\n      (= dirs-&amp;-files? true) (dirs-&amp;-files path)\n      (= files-only? true)   (files-only path)\n      (= dirs-only? true)    (dirs-only path))))&quot; &quot;(ns cetl.core-test\n  (:require [clojure.test :refer :all]\n            [cetl.core :refer :all]\n            [cetl.file.management :refer :all])\n  (:import (java.io File)))&quot; &quot;(filter #(if (.isDirectory %) (.getPath %) nil) (file-seq (File. \&quot;/Users/gregadebesin/Development/Cetl\&quot;)))&quot; &quot;(map #(if-some (.isDirectory %) (.getPath %)) (file-seq (File. \&quot;/Users/gregadebesin/Development/Cetl\&quot;)))&quot; &quot;(map #(if (.isDirectory %) (.getPath %)) (file-seq (File. \&quot;/Users/gregadebesin/Development/Cetl\&quot;)))&quot; &quot;(filter #(if (.isDirectory %) (.getPath %)) (file-seq (File. \&quot;/Users/gregadebesin/Development/Cetl\&quot;)))&quot; &quot;(map #(.getPath %) (filter #(if (.isDirectory %) (.getPath %)) (file-seq (File. \&quot;/Users/gregadebesin/Development/Cetl\&quot;))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-path-sub-dirs\n       [p]\n       (map #(.getPath %) \n            (filter #(if (.isDirectory %) \n                      (.getPath %)) \n                    (file-seq (File. p)))))]\n    (cond\n      (= dirs-&amp;-files? true) (dirs-&amp;-files path)\n      (= files-only? true)   (files-only path)\n      (= dirs-only? true)    (dirs-only path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-path-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-path-sub-dirs\n       [p]\n       (map #(.getPath %) \n            (filter #(if (.isDirectory %) \n                      (.getPath %)) \n                    (file-seq (File. p)))))]\n    (cond\n      (= dirs-&amp;-files? true) (dirs-&amp;-files path)\n      (= files-only? true)   (files-only path)\n      (= dirs-only? true)    (dirs-only path)\n      (= include-path-sub-dirs? true) (include-path-sub-dirs path))))&quot; &quot;(cetl-file-list\n  \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n  :include-path-sub-dirs? true)&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-sub-dirs\n       [p]\n       (map #(.getPath %)\n            (filter #(if (.isDirectory %)\n                      (.getPath %))\n                    (file-seq (File. p)))))]\n    (cond\n      (= dirs-&amp;-files? true) (dirs-&amp;-files path)\n      (= files-only? true) (files-only path)\n      (= dirs-only? true) (dirs-only path)\n      (= include-sub-dirs? true) (include-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(.getPath %)\n            (filter #(if (.isDirectory %)\n                      (.getPath %))\n                    (file-seq (File. p)))))]\n    (cond\n      (= dirs-&amp;-files? true) (dirs-&amp;-files path)\n      (= files-only? true) (files-only path)\n      (= dirs-only? true) (dirs-only path)\n      (and (= include-sub-dirs? true)\n           (= dirs-only? true)) (include-dirs-only-sub-dirs path))))&quot; &quot;(cetl-file-list\n  \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n  :include-sub-dirs? true\n  :dirs-only true)&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(.getPath %)\n            (filter #(if (.isDirectory %)\n                      (.getPath %))\n                    (file-seq (File. p)))))]\n    (cond\n      (= dirs-&amp;-files? true) (dirs-&amp;-files path)\n      (= files-only? true) (files-only path)\n      (and (= dirs-only? true) (include-sub-dirs? false)) (dirs-only path)\n      (and (= include-sub-dirs? true)\n           (= dirs-only? true)) (include-dirs-only-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(.getPath %)\n            (filter #(if (.isDirectory %)\n                      (.getPath %))\n                    (file-seq (File. p)))))]\n    (cond\n      (= dirs-&amp;-files? true) (dirs-&amp;-files path)\n      (= files-only? true) (files-only path)\n      (and (= dirs-only? true) (= include-sub-dirs? false)) (dirs-only path)\n      (and (= include-sub-dirs? true)\n           (= dirs-only? true)) (include-dirs-only-sub-dirs path))))&quot; &quot;(cetl-file-list\n  \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n  :include-sub-dirs? false\n  :dirs-only? true)&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(.getPath %)\n            (filter #(if (.isDirectory %)\n                      (.getPath %))\n                    (file-seq (File. p)))))]\n    (cond\n      (= dirs-&amp;-files? true) (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false)) (files-only path)\n      (and (= dirs-only? true) \n           (= include-sub-dirs? false)) (dirs-only path)\n      (and (= include-sub-dirs? true)\n           (= dirs-only? true)) (include-dirs-only-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(.getPath %)\n            (filter #(if (.isDirectory %)\n                      (.getPath %))\n                    (file-seq (File. p)))))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false)) \n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false)) \n      (files-only path)\n      (and (= dirs-only? true) \n           (= include-sub-dirs? false)) \n      (dirs-only path)\n      (and (= dirs-only? true) \n           (= include-sub-dirs? true)) \n      (include-dirs-only-sub-dirs path))))&quot; &quot;(cetl-file-list\n  \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n  :include-sub-dirs? false\n  :dirs-&amp;-files? true)&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(.getPath %)\n            (filter #(if (.isDirectory %)\n                      (.getPath %))\n                    (file-seq (File. p)))))\n     (include-files-only-sub-dirs\n       []\n       )]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map (str #(.getPath %)\&quot;/\&quot;)\n            (filter #(if (.isDirectory %)\n                      (.getPath %))\n                    (file-seq (File. p)))))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map (str (fn [x] (.getPath x))\&quot;/\&quot;)\n            (filter #(if (.isDirectory %)\n                      (.getPath %))\n                    (file-seq (File. p)))))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(.getPath %)\n            (filter #(if (.isDirectory %)\n                      (.getPath %))\n                    (file-seq (File. p)))))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; find `pwd` -type d \&quot;))\n              :out) #\&quot;\\n\&quot;))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(str % \&quot;/\&quot;)\n         (clojure.string/split\n           (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                                       (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; find `pwd` -type d \&quot;))\n                :out) #\&quot;\\n\&quot;)))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(cetl-file-list\n  \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n  :include-sub-dirs? true\n  :dirs-only? true)&quot; &quot;(map #(.getPath %) (filter #(if (.isFile %) (.getPath %)) (file-seq (File. \&quot;/Users/gregadebesin/Development/Cetl\&quot;))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(str % \&quot;/\&quot;)\n         (clojure.string/split\n           (get (clojure.java.shell/sh \n                  \&quot;sh\&quot; \&quot;-c\&quot;\n                  (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; find `pwd` -type d \&quot;))\n                :out) #\&quot;\\n\&quot;)))\n     (include-files-only-sub-dirs\n       [p]\n       (map #(.getPath %) \n            (filter #(if (.isFile %) (.getPath %)) \n                    (file-seq (File. p)))))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(str % \&quot;/\&quot;)\n         (clojure.string/split\n           (get (clojure.java.shell/sh \n                  \&quot;sh\&quot; \&quot;-c\&quot;\n                  (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; find `pwd` -type d \&quot;))\n                :out) #\&quot;\\n\&quot;)))\n     (include-files-only-sub-dirs\n       [p]\n       (mapv #(.getPath %) \n            (filter #(if (.isFile %) (.getPath %)) \n                    (file-seq (File. p)))))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(str % \&quot;/\&quot;)\n         (clojure.string/split\n           (get (clojure.java.shell/sh \n                  \&quot;sh\&quot; \&quot;-c\&quot;\n                  (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; find `pwd` -type d \&quot;))\n                :out) #\&quot;\\n\&quot;)))\n     (include-files-only-sub-dirs\n       [p]\n       (mapv #(.getPath %) \n            (filter #(if (.isFile %) (.getPath %)) \n                    (file-seq (File. p)))))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(str % \&quot;/\&quot;)\n         (clojure.string/split\n           (get (clojure.java.shell/sh \n                  \&quot;sh\&quot; \&quot;-c\&quot;\n                  (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; find `pwd` -type d \&quot;))\n                :out) #\&quot;\\n\&quot;)))\n     (include-files-only-sub-dirs\n       [p]\n       (mapv #(.getPath %) \n            (filter #(if (.isFile %) (.getPath %)) \n                    (file-seq (File. p)))))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path)\n      (and (= files-only? true)\n           (= include-sub-dirs? true))\n      (include-files-only-sub-dirs path))))&quot; &quot;(cetl-file-list\n  \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n  :include-sub-dirs? true\n  :files-only? true)&quot; &quot;(cetl-file-list\n  \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n  :include-sub-dirs? true\n  :files-only? false)&quot; &quot;(cetl-file-list\n  \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n  :include-sub-dirs? false\n  :files-only? true)&quot; &quot;2&quot; &quot;(defn cetl-file-archive\n  [path &amp; {:keys [archive-format]}]\n  (letfn\n    [(zip\n       [p]\n       (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot; (zip-command p)))\n     (gzip\n       [p]\n       (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot; (gzip-command p)))]\n    (cond\n      (= archive-format :zip) (zip path)\n      (= archive-format :gzip) (gzip path))))&quot; &quot;(defn gzip-command\n  [p]\n  (str \&quot; cd \&quot; (c-utils/parent-folder p) \&quot;;\&quot;\n       \&quot; tar -cvzf \&quot; (c-utils/path-head p)\&quot;.tar.gz\&quot;\n       \&quot; \&quot; (c-utils/path-head p)))&quot; &quot;(defn zip-command\n  [p]\n  (str \&quot; cd \&quot; (c-utils/parent-folder p) \&quot;;\&quot;\n       \&quot; zip \&quot; (c-utils/path-head p)\&quot;.zip\&quot;\n       \&quot; -r \&quot; (c-utils/path-head p)))&quot; &quot;(defn cetl-file-archive\n  [path &amp; {:keys [archive-format]}]\n  (letfn\n    [(zip\n       [p]\n       (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                              (str \&quot; cd \&quot; (.getParent (File. p)) \&quot;;\&quot;\n                                   \&quot; zip \&quot; (last (s/split p #\&quot;/\&quot;))\&quot;.zip\&quot;\n                                   \&quot; -r \&quot;  (last (s/split p #\&quot;/\&quot;)))))\n     (gzip\n       [p]\n       (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot; (gzip-command p)))]\n    (cond\n      (= archive-format :zip) (zip path)\n      (= archive-format :gzip) (gzip path))))&quot; &quot;(defn cetl-file-archive\n  [path &amp; {:keys [archive-format]}]\n  (letfn\n    [(zip\n       [p]\n       (clojure.java.shell/sh \n         \&quot;sh\&quot; \&quot;-c\&quot;\n          (str \&quot; cd \&quot;  (.getParent (File. p))\&quot;/;\&quot;\n               \&quot; zip \&quot; (last (s/split p #\&quot;/\&quot;))\&quot;.zip\&quot;\n               \&quot; -r \&quot;  (last (s/split p #\&quot;/\&quot;)))))\n     (gzip\n       [p]\n       (clojure.java.shell/sh \n         \&quot;sh\&quot; \&quot;-c\&quot;\n          (str \&quot; cd \&quot; (.getParent (File. p))\&quot;/;\&quot;\n               \&quot; tar -cvzf \&quot; (last (s/split p #\&quot;/\&quot;))\&quot;.tar.gz\&quot;\n               \&quot; \&quot; (last (s/split p #\&quot;/\&quot;)))))]\n    (cond\n      (= archive-format :zip) (zip path)\n      (= archive-format :gzip) (gzip path))))&quot; &quot;(defn cetl-file-archive\n  [path &amp; {:keys [archive-format]}]\n  (letfn\n    [(zip\n       [p]\n       (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                              (str \&quot; cd \&quot;  (.getParent (File. p))\&quot;/;\&quot;\n                                   \&quot; zip \&quot; (last (s/split p #\&quot;/\&quot;))\&quot;.zip\&quot;\n                                   \&quot; -r \&quot;  (last (s/split p #\&quot;/\&quot;)))))\n     (gzip\n       [p]\n       (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot; \n                              (str \&quot; cd \&quot; (.getParent (File. p))\&quot;/;\&quot;\n                                   \&quot; tar -cvzf \&quot; (last (s/split p #\&quot;/\&quot;))\&quot;.tar.gz\&quot;\n                                   \&quot; \&quot; (last (s/split p #\&quot;/\&quot;)))))]\n    (cond\n      (= archive-format :zip) (zip path)\n      (= archive-format :gzip) (gzip path))))&quot; &quot;(cetl-file-archive  \&quot;/Users/gregadebesin/Development/Cetl/archive\&quot;\n                    :archive-format :gzip)&quot; &quot;(cetl-file-archive  \&quot;/Users/gregadebesin/Development/Cetl/archive\&quot;\n                    :archive-format :zip)&quot; &quot;(ns cetl.process.components-process\n  (:require [clojure.core.async :refer [chan &lt;!! &gt;!! &gt;! &lt;! put! take! close!\n                                        sliding-buffer\n                                        dropping-buffer\n                                        thread go]]))&quot; &quot;(ns cetl.process.components-process\n  (:require [clojure.core.async :refer [chan &lt;!! &gt;!! &gt;! &lt;! put! take! close!\n                                        sliding-buffer\n                                        dropping-buffer\n                                        thread go]]\n            [cetl.file.management :refer :all]))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [cetl.utils.component-utils :as c-utils])\n  (:import (java.io File FileFilter)))&quot; &quot;(use '[clojure.java.shell :only [sh]])&quot; &quot;(ns cetl.process.components-process\n  (:require [clojure.core.async :refer [chan &lt;!! &gt;!! &gt;! &lt;! put! take! close!\n                                        sliding-buffer\n                                        dropping-buffer\n                                        thread go]]\n            [cetl.file.management :as fm]))&quot; &quot;(defn process-&gt;\n  [x]\n  ())&quot; &quot;(defn process-&gt;\n  [x]\n  (* x x))&quot; &quot;(process-&gt; 2)&quot; &quot;(do\n  (fm/cetl-file-archive \&quot;\&quot; :zip))&quot; &quot;(do \n  (cetl-file-archive \n    \&quot;/Users/gregadebesin/Development/Cetl/archive\&quot;\n     :archive-format :gzip)\n  (cetl-file-archive \n    \&quot;/Users/gregadebesin/Development/Cetl/archive\&quot;\n     :archive :zip))&quot; &quot;(let [c (chan)]\n  (thread (dotimes [x 3]\n            (&gt;!! c x)\n            (println \&quot;Put:\&quot;\\space x)\n            ))\n  (thread (dotimes [x 3]\n            (println \&quot;Took:\&quot;\\space (&lt;!! c))\n            ))\n  )&quot; &quot;(let [c (chan)]\n  (thread (dotimes [x 3]\n            (&gt;!! c x) ))\n  (thread (dotimes [x 3]\n            (println \&quot;Took:\&quot;\\space (&lt;!! c))\n            )))&quot; &quot;(cetl-file-list\n  \&quot;/Users/gregadebesin/Development/Cetl/archive\&quot;\n  :dirs-&amp;-files? true)&quot; &quot;(cetl-file-list\n  \&quot;/Users/gregadebesin/Development/Cetl/archive\&quot;\n  :dirs-&amp;-files? true\n  :include-hidden-files? false\n  :include-sub-dirs? false)&quot; &quot;(cetl-file-archive\n  \&quot;/Users/gregadebesin/Development/Cetl/archive\&quot;\n  :archive-format :gzip)&quot; &quot;(let [c (chan)]\n  (thread (dotimes [x 3]\n            (&gt;!! c x)))\n  (thread (dotimes [x 3]\n            (println \&quot;Took:\&quot;\\space (&lt;!! c))\n            )))&quot; &quot;(defn add-function\n  []\n  (thread\n    ()))&quot; &quot;(let [c (chan)]\n  (thread (&gt;!! c (cetl-file-archive \&quot;/Users/gregadebesin/Development/\&quot;)))\n  (thread (dotimes [x 3]\n            (println \&quot;Took:\&quot;\\space (&lt;!! c))\n            )))&quot; &quot;(let [c (chan)]\n  (thread (cetl-file-archive \&quot;/Users/gregadebesin/Development/Cetl/archive\&quot; ))\n  (thread (dotimes [x 3]\n            (println \&quot;Took:\&quot;\\space (&lt;!! c))\n            )))&quot; &quot;(let [c (chan)]\n  (thread (&gt;!! c (cetl-file-archive\n                   \&quot;/Users/gregadebesin/Development/Cetl/archive\&quot;\n                   :archive-format :gzip))\n          (&gt;!! c (cetl-file-archive\n                   \&quot;/Users/gregadebesin/Development/Cetl/archive\&quot;\n                   :archive-format :zip)))\n  (thread (dotimes [x 2]\n            (&lt;!! c))))&quot;], :remote []}}</component>
</project>

