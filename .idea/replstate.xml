<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1442345498969">{:repl-history {:ide [], :local [&quot;2&quot; &quot;(ns cetl.file.management\n  (:require [clojure.core.async :refer [chan &lt;!! &gt;!! &gt;! &lt;! put! take! close!\n                                        sliding-buffer\n                                        dropping-buffer\n                                        thread go]]\n            [clojure.string :as s]\n            [cetl.utils.component-utils :as c-utils])\n  (:import (java.io File FileFilter)))&quot; &quot;(use '[clojure.java.shell :only [sh]])&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-sub-dirs\n       [p]\n       (clojure.string/split\n         \&quot;\&quot; \&quot;\&quot;\n         ))]\n    (cond\n      (= dirs-&amp;-files? true) (dirs-&amp;-files path)\n      (= files-only? true)   (files-only path)\n      (= dirs-only? true)    (dirs-only path))))&quot; &quot;(ns cetl.core-test\n  (:require [clojure.test :refer :all]\n            [cetl.core :refer :all]\n            [cetl.file.management :refer :all])\n  (:import (java.io File)))&quot; &quot;(filter #(if (.isDirectory %) (.getPath %) nil) (file-seq (File. \&quot;/Users/gregadebesin/Development/Cetl\&quot;)))&quot; &quot;(map #(if-some (.isDirectory %) (.getPath %)) (file-seq (File. \&quot;/Users/gregadebesin/Development/Cetl\&quot;)))&quot; &quot;(map #(if (.isDirectory %) (.getPath %)) (file-seq (File. \&quot;/Users/gregadebesin/Development/Cetl\&quot;)))&quot; &quot;(filter #(if (.isDirectory %) (.getPath %)) (file-seq (File. \&quot;/Users/gregadebesin/Development/Cetl\&quot;)))&quot; &quot;(map #(.getPath %) (filter #(if (.isDirectory %) (.getPath %)) (file-seq (File. \&quot;/Users/gregadebesin/Development/Cetl\&quot;))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-path-sub-dirs\n       [p]\n       (map #(.getPath %) \n            (filter #(if (.isDirectory %) \n                      (.getPath %)) \n                    (file-seq (File. p)))))]\n    (cond\n      (= dirs-&amp;-files? true) (dirs-&amp;-files path)\n      (= files-only? true)   (files-only path)\n      (= dirs-only? true)    (dirs-only path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-path-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-path-sub-dirs\n       [p]\n       (map #(.getPath %) \n            (filter #(if (.isDirectory %) \n                      (.getPath %)) \n                    (file-seq (File. p)))))]\n    (cond\n      (= dirs-&amp;-files? true) (dirs-&amp;-files path)\n      (= files-only? true)   (files-only path)\n      (= dirs-only? true)    (dirs-only path)\n      (= include-path-sub-dirs? true) (include-path-sub-dirs path))))&quot; &quot;(cetl-file-list\n  \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n  :include-path-sub-dirs? true)&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-sub-dirs\n       [p]\n       (map #(.getPath %)\n            (filter #(if (.isDirectory %)\n                      (.getPath %))\n                    (file-seq (File. p)))))]\n    (cond\n      (= dirs-&amp;-files? true) (dirs-&amp;-files path)\n      (= files-only? true) (files-only path)\n      (= dirs-only? true) (dirs-only path)\n      (= include-sub-dirs? true) (include-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(.getPath %)\n            (filter #(if (.isDirectory %)\n                      (.getPath %))\n                    (file-seq (File. p)))))]\n    (cond\n      (= dirs-&amp;-files? true) (dirs-&amp;-files path)\n      (= files-only? true) (files-only path)\n      (= dirs-only? true) (dirs-only path)\n      (and (= include-sub-dirs? true)\n           (= dirs-only? true)) (include-dirs-only-sub-dirs path))))&quot; &quot;(cetl-file-list\n  \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n  :include-sub-dirs? true\n  :dirs-only true)&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(.getPath %)\n            (filter #(if (.isDirectory %)\n                      (.getPath %))\n                    (file-seq (File. p)))))]\n    (cond\n      (= dirs-&amp;-files? true) (dirs-&amp;-files path)\n      (= files-only? true) (files-only path)\n      (and (= dirs-only? true) (include-sub-dirs? false)) (dirs-only path)\n      (and (= include-sub-dirs? true)\n           (= dirs-only? true)) (include-dirs-only-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(.getPath %)\n            (filter #(if (.isDirectory %)\n                      (.getPath %))\n                    (file-seq (File. p)))))]\n    (cond\n      (= dirs-&amp;-files? true) (dirs-&amp;-files path)\n      (= files-only? true) (files-only path)\n      (and (= dirs-only? true) (= include-sub-dirs? false)) (dirs-only path)\n      (and (= include-sub-dirs? true)\n           (= dirs-only? true)) (include-dirs-only-sub-dirs path))))&quot; &quot;(cetl-file-list\n  \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n  :include-sub-dirs? false\n  :dirs-only? true)&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(.getPath %)\n            (filter #(if (.isDirectory %)\n                      (.getPath %))\n                    (file-seq (File. p)))))]\n    (cond\n      (= dirs-&amp;-files? true) (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false)) (files-only path)\n      (and (= dirs-only? true) \n           (= include-sub-dirs? false)) (dirs-only path)\n      (and (= include-sub-dirs? true)\n           (= dirs-only? true)) (include-dirs-only-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(.getPath %)\n            (filter #(if (.isDirectory %)\n                      (.getPath %))\n                    (file-seq (File. p)))))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false)) \n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false)) \n      (files-only path)\n      (and (= dirs-only? true) \n           (= include-sub-dirs? false)) \n      (dirs-only path)\n      (and (= dirs-only? true) \n           (= include-sub-dirs? true)) \n      (include-dirs-only-sub-dirs path))))&quot; &quot;(cetl-file-list\n  \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n  :include-sub-dirs? false\n  :dirs-&amp;-files? true)&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(.getPath %)\n            (filter #(if (.isDirectory %)\n                      (.getPath %))\n                    (file-seq (File. p)))))\n     (include-files-only-sub-dirs\n       []\n       )]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map (str #(.getPath %)\&quot;/\&quot;)\n            (filter #(if (.isDirectory %)\n                      (.getPath %))\n                    (file-seq (File. p)))))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map (str (fn [x] (.getPath x))\&quot;/\&quot;)\n            (filter #(if (.isDirectory %)\n                      (.getPath %))\n                    (file-seq (File. p)))))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(.getPath %)\n            (filter #(if (.isDirectory %)\n                      (.getPath %))\n                    (file-seq (File. p)))))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; find `pwd` -type d \&quot;))\n              :out) #\&quot;\\n\&quot;))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(str % \&quot;/\&quot;)\n         (clojure.string/split\n           (get (clojure.java.shell/sh \&quot;sh\&quot; \&quot;-c\&quot;\n                                       (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; find `pwd` -type d \&quot;))\n                :out) #\&quot;\\n\&quot;)))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(cetl-file-list\n  \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n  :include-sub-dirs? true\n  :dirs-only? true)&quot; &quot;(map #(.getPath %) (filter #(if (.isFile %) (.getPath %)) (file-seq (File. \&quot;/Users/gregadebesin/Development/Cetl\&quot;))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(str % \&quot;/\&quot;)\n         (clojure.string/split\n           (get (clojure.java.shell/sh \n                  \&quot;sh\&quot; \&quot;-c\&quot;\n                  (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; find `pwd` -type d \&quot;))\n                :out) #\&quot;\\n\&quot;)))\n     (include-files-only-sub-dirs\n       [p]\n       (map #(.getPath %) \n            (filter #(if (.isFile %) (.getPath %)) \n                    (file-seq (File. p)))))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(str % \&quot;/\&quot;)\n         (clojure.string/split\n           (get (clojure.java.shell/sh \n                  \&quot;sh\&quot; \&quot;-c\&quot;\n                  (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; find `pwd` -type d \&quot;))\n                :out) #\&quot;\\n\&quot;)))\n     (include-files-only-sub-dirs\n       [p]\n       (mapv #(.getPath %) \n            (filter #(if (.isFile %) (.getPath %)) \n                    (file-seq (File. p)))))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(str % \&quot;/\&quot;)\n         (clojure.string/split\n           (get (clojure.java.shell/sh \n                  \&quot;sh\&quot; \&quot;-c\&quot;\n                  (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; find `pwd` -type d \&quot;))\n                :out) #\&quot;\\n\&quot;)))\n     (include-files-only-sub-dirs\n       [p]\n       (mapv #(.getPath %) \n            (filter #(if (.isFile %) (.getPath %)) \n                    (file-seq (File. p)))))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot;  ls -d $PWD/*/ \&quot; \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*.* \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh \n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; ls -d -1 $PWD/*/ \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (map #(str % \&quot;/\&quot;)\n         (clojure.string/split\n           (get (clojure.java.shell/sh \n                  \&quot;sh\&quot; \&quot;-c\&quot;\n                  (str \&quot; cd \&quot; p \&quot;;\&quot; \&quot; find `pwd` -type d \&quot;))\n                :out) #\&quot;\\n\&quot;)))\n     (include-files-only-sub-dirs\n       [p]\n       (mapv #(.getPath %) \n            (filter #(if (.isFile %) (.getPath %)) \n                    (file-seq (File. p)))))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path)\n      (and (= files-only? true)\n           (= include-sub-dirs? true))\n      (include-files-only-sub-dirs path))))&quot; &quot;(cetl-file-list\n  \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n  :include-sub-dirs? true\n  :files-only? true)&quot; &quot;(cetl-file-list\n  \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n  :include-sub-dirs? true\n  :files-only? false)&quot; &quot;(cetl-file-list\n  \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n  :include-sub-dirs? false\n  :files-only? true)&quot;], :remote []}}</component>
</project>

