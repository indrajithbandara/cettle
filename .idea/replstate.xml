<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1448226852543">{:repl-history {:ide [], :local [&quot;(def parser (.parse query \&quot;select * from java.lang.String where length=3\&quot;))&quot; &quot;(def results (ArrayList. (.getResults (.execute query animals))))&quot; &quot;(def results (vector (.getResults (.execute query animals))))&quot; &quot;results&quot; &quot;(def results (.getResults (.execute query animals)))&quot; &quot;(defmulti cetl-list-file {:arglists '([map])} (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-list-file :list-dirs-files\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command \&quot; find `pwd` -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path path))\n      (assoc path\n        :result {:path (s/split\n                         (get (clojure.java.shell/sh\n                                \&quot;sh\&quot; \&quot;-c\&quot;\n                                (str move-to-dir (:path path)\n                                     next-command\n                                     command))\n                                  :out) #\&quot;\\n\&quot;)})\n      (throw\n        (IllegalArgumentException.\n          (str (:path path) \&quot; is not a directory\&quot;))))))&quot; &quot;(cetl-list-file {:path \&quot;/Users/gregadebesin/Development\&quot;\n                 :exec :list-fils})&quot; &quot;(defmethod cetl-list-file :list-dirs-files\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command \&quot; find `pwd` -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path path))\n      (assoc path\n        :result {:out (s/split\n                         (get (clojure.java.shell/sh\n                                \&quot;sh\&quot; \&quot;-c\&quot;\n                                (str move-to-dir (:path path)\n                                     next-command\n                                     command))\n                                  :out) #\&quot;\\n\&quot;)})\n      (throw\n        (IllegalArgumentException.\n          (str (:path path) \&quot; is not a directory\&quot;))))))&quot; &quot;(defmethod cetl-list-file :list-dirs-files\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command \&quot; find `pwd` -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path path))\n      (assoc path\n        :result {:&lt;- (s/split\n                         (get (clojure.java.shell/sh\n                                \&quot;sh\&quot; \&quot;-c\&quot;\n                                (str move-to-dir (:path path)\n                                     next-command\n                                     command))\n                                  :out) #\&quot;\\n\&quot;)})\n      (throw\n        (IllegalArgumentException.\n          (str (:path path) \&quot; is not a directory\&quot;))))))&quot; &quot;(defmethod cetl-list-file :list-dirs-files\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command \&quot; find `pwd` -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path path))\n      (assoc path\n        :result {:&lt; (s/split\n                         (get (clojure.java.shell/sh\n                                \&quot;sh\&quot; \&quot;-c\&quot;\n                                (str move-to-dir (:path path)\n                                     next-command\n                                     command))\n                                  :out) #\&quot;\\n\&quot;)})\n      (throw\n        (IllegalArgumentException.\n          (str (:path path) \&quot; is not a directory\&quot;))))))&quot; &quot;(defmethod cetl-list-file :list-dirs-files\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command \&quot; find `pwd` -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path path))\n      (assoc path\n        :result {:&lt;&lt; (s/split\n                         (get (clojure.java.shell/sh\n                                \&quot;sh\&quot; \&quot;-c\&quot;\n                                (str move-to-dir (:path path)\n                                     next-command\n                                     command))\n                                  :out) #\&quot;\\n\&quot;)})\n      (throw\n        (IllegalArgumentException.\n          (str (:path path) \&quot; is not a directory\&quot;))))))&quot; &quot;(defmethod cetl-list-file :list-files\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command  \&quot; find `pwd` -type f -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path path))\n      (assoc path \n        :result {:&lt;&lt; (s/split\n                       (get (clojure.java.shell/sh\n                              \&quot;sh\&quot; \&quot;-c\&quot;\n                              (str move-to-dir (:path path)\n                                   next-command\n                                   command))\n                            :out) #\&quot;\\n\&quot;)})\n      (throw\n        (IllegalArgumentException.\n               (str (:path path) \&quot; is not a directory\&quot;))))))&quot; &quot;(defmethod cetl-list-file :list-dirs-files\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command \&quot; find `pwd` -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path path))\n      (assoc path\n        :result {:val (s/split\n                         (get (clojure.java.shell/sh\n                                \&quot;sh\&quot; \&quot;-c\&quot;\n                                (str move-to-dir (:path path)\n                                     next-command\n                                     command))\n                                  :out) #\&quot;\\n\&quot;)})\n      (throw\n        (IllegalArgumentException.\n          (str (:path path) \&quot; is not a directory\&quot;))))))&quot; &quot;(defmethod cetl-list-file :list-files\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command  \&quot; find `pwd` -type f -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path path))\n      (assoc path \n        :result {:val (s/split\n                       (get (clojure.java.shell/sh\n                              \&quot;sh\&quot; \&quot;-c\&quot;\n                              (str move-to-dir (:path path)\n                                   next-command\n                                   command))\n                            :out) #\&quot;\\n\&quot;)})\n      (throw\n        (IllegalArgumentException.\n               (str (:path path) \&quot; is not a directory\&quot;))))))&quot; &quot;(cetl-list-file {:path \&quot;/Users/gregadebesin/Development\&quot;\n                 :exec :list-files})&quot; &quot;(defmethod cetl-list-file :list-dirs\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command  \&quot; find `pwd` -type d -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path path))\n      (assoc path \n        :result {:val (s/split\n                        (get (clojure.java.shell/sh\n                               \&quot;sh\&quot; \&quot;-c\&quot;\n                               (str move-to-dir (:path path)\n                                    next-command\n                                    command))\n                             :out) #\&quot;\\n\&quot;)})\n      (throw\n        (IllegalArgumentException.\n               (str (:path path) \&quot; is not a directory\&quot;))))))&quot; &quot;(defmethod cetl-list-file :list-dirs-sub-dirs\n  [path]\n  (let [move-to-dir \&quot; cd \&quot;\n        command  \&quot; find `pwd` -type d \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path path))\n      (assoc path \n        :result {:val (s/split\n                        (get (clojure.java.shell/sh\n                               \&quot;sh\&quot; \&quot;-c\&quot;\n                               (str move-to-dir (:path path)\n                                    next-command\n                                    command))\n                             :out) #\&quot;\\n\&quot;)})\n      (throw\n        (IllegalArgumentException.\n               (str (:path path) \&quot; is not a directory\&quot;))))))&quot; &quot;(cetl-list-file {:path \&quot;/Users/gregadebesin/Development\&quot;\n                 :exec :list-dirs-sub-dirs})&quot; &quot;(cetl-list-file {:path \&quot;/Users/gregadebesin/Development\&quot;\n                 :exec :list-dirs})&quot; &quot;(defmethod cetl-archive-file :zip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (not (file-exists? file-path))\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               zip-command (str file file-ext)\n               rec-command file))\n        (assoc x :result\n                 (vector\n                   (str file-path file-ext))))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-archive-file :zip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               zip-command (str file file-ext)\n               rec-command file))\n        (assoc x :result\n                 (vector\n                   (str file-path file-ext))))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(cetl-archive-file {:path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                    :file \&quot;foo.png\&quot;\n                    :exec :zip-file})&quot; &quot;(defmethod cetl-archive-file :gzip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        gzip-command \&quot; tar -cvzf \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.tar.gz\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (not (file-exists? file-path))\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               gzip-command (str file file-ext \&quot; \&quot; file)))\n        (assoc x :result\n                 (vector\n                   (str file-path file-ext))))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-archive-file :gzip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        gzip-command \&quot; tar -cvzf \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.tar.gz\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               gzip-command (str file file-ext \&quot; \&quot; file)))\n        (assoc x :result\n                 (vector\n                   (str file-path file-ext))))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-archive-file :gzip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        gzip-command \&quot; tar -cvzf \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.tar.gz\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (or (file-exists? file-path) (dir-exists? path))\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               gzip-command (str file file-ext \&quot; \&quot; file)))\n        (assoc x :result\n                 (vector\n                   (str file-path file-ext))))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-archive-file :zip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (or (file-exists? file-path) (dir-exists? path))\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               zip-command (str file file-ext)\n               rec-command file))\n        (assoc x :result\n                 (vector\n                   (str file-path file-ext))))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-list-file :list-dirs-files\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        command \&quot; find `pwd` -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path x))\n      (assoc x\n        :result {:val (s/split\n                         (get (clojure.java.shell/sh\n                                \&quot;sh\&quot; \&quot;-c\&quot;\n                                (str move-to-dir (:path x)\n                                     next-command\n                                     command))\n                                  :out) #\&quot;\\n\&quot;)})\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot; is not a directory\&quot;))))))&quot; &quot;(defmethod cetl-list-file :list-files\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        command  \&quot; find `pwd` -type f -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path x))\n      (assoc x\n        :result {:val (s/split\n                       (get (clojure.java.shell/sh\n                              \&quot;sh\&quot; \&quot;-c\&quot;\n                              (str move-to-dir (:path x)\n                                   next-command\n                                   command))\n                            :out) #\&quot;\\n\&quot;)})\n      (throw\n        (IllegalArgumentException.\n               (str (:path path) \&quot; is not a directory\&quot;))))))&quot; &quot;(defmethod cetl-list-file :list-dirs-sub-dirs\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        command  \&quot; find `pwd` -type d \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path x))\n      (assoc x\n        :result {:val (s/split\n                        (get (clojure.java.shell/sh\n                               \&quot;sh\&quot; \&quot;-c\&quot;\n                               (str move-to-dir (:path x)\n                                    next-command\n                                    command))\n                             :out) #\&quot;\\n\&quot;)})\n      (throw\n        (IllegalArgumentException.\n               (str (:path x) \&quot; is not a directory\&quot;))))))&quot; &quot;(defmethod cetl-list-file :list-dirs\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        command  \&quot; find `pwd` -type d -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path x))\n      (assoc x\n        :result {:val (s/split\n                        (get (clojure.java.shell/sh\n                               \&quot;sh\&quot; \&quot;-c\&quot;\n                               (str move-to-dir (:path x)\n                                    next-command\n                                    command))\n                             :out) #\&quot;\\n\&quot;)})\n      (throw\n        (IllegalArgumentException.\n               (str (:path x) \&quot; is not a directory\&quot;))))))&quot; &quot;(defmethod cetl-archive-file :zip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (or (file-exists? file-path) (dir-exists? path))\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               zip-command (str file file-ext)\n               rec-command file))\n        (assoc x \n          :result {:val (vector\n                          (str file-path file-ext))}))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-archive-file :zip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (or (file-exists? file-path) (dir-exists? path))\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               zip-command (str file file-ext)\n               rec-command file))\n        (assoc x \n          :result {:val \n                   (str file-path file-ext)}))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(cetl-archive-file {:path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                    :file \&quot;foo\&quot;\n                    :exec :zip-file})&quot; &quot;(defmethod cetl-archive-file :zip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (or (file-exists? file-path) (dir-exists? path))\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               zip-command (str file file-ext)\n               rec-command file))\n        (assoc x \n          :result {:val (str file-path file-ext)}))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-archive-file :gzip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        gzip-command \&quot; tar -cvzf \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.tar.gz\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (or (file-exists? file-path) (dir-exists? path))\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               gzip-command (str file file-ext \&quot; \&quot; file)))\n        (assoc x \n          :result (str file-path file-ext)))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-archive-file :gzip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        gzip-command \&quot; tar -cvzf \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.tar.gz\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (or (file-exists? file-path) (dir-exists? path))\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               gzip-command (str file file-ext \&quot; \&quot; file)))\n        (assoc x \n          :result {:val (str file-path file-ext)}))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(cetl-archive-file {:path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                    :file \&quot;foo\&quot;\n                    :exec :gzip-file})&quot; &quot;(defmethod cetl-encode-file :ISO-8859-1\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (FileUtils/write\n          (File. file-path)\n          (FileUtils/readFileToString\n            (File. file-path) \&quot;UTF-8\&quot;) \&quot;ISO-8859-1\&quot;)\n        (assoc x :result\n                 {:val (str (:path x) \&quot;/\&quot; (:file x))}))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-encode-file :UTF-8\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (FileUtils/write\n          (File. file-path)\n          (FileUtils/readFileToString\n            (File. file-path) \&quot;ISO-8859-1\&quot;) \&quot;UTF-8\&quot;)\n        (assoc x :result\n                 {:val (str (:path x) \&quot;/\&quot; (:file x))}))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-encode-file :UTF-8\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (FileUtils/write\n          (File. file-path)\n          (FileUtils/readFileToString\n            (File. file-path) \&quot;ISO-8859-1\&quot;) \&quot;UTF-8\&quot;)\n        (assoc x \n          :result {:val (str (:path x) \&quot;/\&quot; (:file x))}))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-create-temp-file :create-temp-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        full-path (str (:path x) \&quot;/\&quot; (:file x))]\n    (if (dir-exists? path)\n      (do\n        (io/writer\n          (io/file\n            (str path \&quot;/\&quot; file)))\n        (assoc x \n          :result {:val full-path}))\n      (throw\n        (IllegalArgumentException.\n          (str path \&quot; is not a directory\&quot;))))))&quot; &quot;(defmethod cetl-copy-file :copy-file\n  [x]\n  (let [file (:file x)\n        in-path (:in-path x)\n        out-path (:out-path x)\n        full-in-path (str (:in-path x) \&quot;/\&quot; (:file x))]\n    (cond (not (file-exists? full-in-path))\n          (throw\n            (IllegalArgumentException.\n              (str full-in-path \&quot; is not a file (or directory)\&quot;)))\n          (not (dir-exists? out-path))\n          (throw\n            (IllegalArgumentException.\n              (str out-path \&quot; is not a directory\&quot;)))\n          :else\n          (do\n            (io/copy\n              (io/file (str in-path \&quot;/\&quot; file))\n              (io/file (str out-path \&quot;/\&quot; file)))\n            (assoc x :result\n                     {:val (str (:out-path x) \&quot;/\&quot; (:file x))})))))&quot; &quot;(defmethod cetl-delete-file :delete-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (io/delete-file\n          (io/file\n            (str path \&quot;/\&quot; file)))\n        (assoc x :result {:val (str (:path x) \&quot;/\&quot; (:file x))}))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-delete-file :delete-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (io/delete-file\n          (io/file\n            (str path \&quot;/\&quot; file)))\n        (assoc x \n          :result {:val (str (:path x) \&quot;/\&quot; (:file x))}))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-properties-file :file-properties\n  [x]\n  (let [file (File. (str (:path x) \&quot;/\&quot; (:file x)))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (file-exists? (.getAbsolutePath file))\n      (do (assoc x :result {:val (vector abs-file-path\n                                         parent-dir\n                                         file-name\n                                         read-permissions\n                                         write-permissions\n                                         execute-permissions\n                                         file-size\n                                         modified-time-millis\n                                         modified-time-str)}))\n      (throw\n        (IllegalArgumentException.\n          (str file \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;2&quot; &quot;(name ddd)&quot; &quot;(defmethod cetl-properties-file :file-properties\n  [x]\n  (let [file (File. (str (:path x) \&quot;/\&quot; (:file x)))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (file-exists? (.getAbsolutePath file))\n      (do (assoc x :result {:val {:abs-file-path abs-file-path\n                                  :parent-dir parent-dir\n                                  :file-name file-name\n                                  :read-permissions read-permissions\n                                  :write-permissions write-permissions\n                                  :execute-permissions execute-permissions\n                                  :file-size file-size\n                                  :modified-time-millis modified-time-millis\n                                  :modified-time-str modified-time-str}}))\n      (throw\n        (IllegalArgumentException.\n          (str file \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-list-file :list-dirs-files\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        command \&quot; find `pwd` -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path x))\n      (assoc x\n        :result  (s/split\n                         (get (clojure.java.shell/sh\n                                \&quot;sh\&quot; \&quot;-c\&quot;\n                                (str move-to-dir (:path x)\n                                     next-command\n                                     command))\n                              :out) #\&quot;\\n\&quot;))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot; is not a directory\&quot;))))))&quot; &quot;(defmethod cetl-list-file :list-dirs-files\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        command \&quot; find `pwd` -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path x))\n      (assoc x\n        :result (s/split \n                  (get (clojure.java.shell/sh \n                         \&quot;sh\&quot; \&quot;-c\&quot; \n                         (str move-to-dir (:path x) \n                              next-command \n                              command)) :out) #\&quot;\\n\&quot;))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot; is not a directory\&quot;))))))&quot; &quot;(cetl-list-file {:path \&quot;/Users/gregadebesin/Development\&quot;\n                 :exec :list-dirs-files})&quot; &quot;(defmethod cetl-list-file :list-dirs\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        command  \&quot; find `pwd` -type d -maxdepth 1 \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path x))\n      (assoc x\n        :result (s/split \n                  (get (clojure.java.shell/sh \n                         \&quot;sh\&quot; \&quot;-c\&quot; \n                         (str move-to-dir (:path x) \n                              next-command \n                              command)) :out) #\&quot;\\n\&quot;))\n      (throw\n        (IllegalArgumentException.\n               (str (:path x) \&quot; is not a directory\&quot;))))))&quot; &quot;(defmethod cetl-list-file :list-dirs-sub-dirs\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        command  \&quot; find `pwd` -type d \&quot;\n        next-command \&quot;;\&quot;]\n    (if (dir-exists? (:path x))\n      (assoc x\n        :result (s/split \n                  (get (clojure.java.shell/sh \n                         \&quot;sh\&quot; \&quot;-c\&quot; \n                         (str move-to-dir (:path x) \n                              next-command \n                              command)) :out) #\&quot;\\n\&quot;))\n      (throw\n        (IllegalArgumentException.\n               (str (:path x) \&quot; is not a directory\&quot;))))))&quot; &quot;(defmethod cetl-archive-file :zip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        zip-command \&quot; zip \&quot;\n        rec-command \&quot; -r \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.zip\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (or (file-exists? file-path) (dir-exists? path))\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               zip-command (str file file-ext)\n               rec-command file))\n        (assoc x\n          :result (str file-path file-ext)))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-archive-file :gzip-file\n  [x]\n  (let [move-to-dir \&quot; cd \&quot;\n        gzip-command \&quot; tar -cvzf \&quot;\n        next-command \&quot;;\&quot;\n        file-ext \&quot;.tar.gz\&quot;\n        path (:path x)\n        file (:file x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (or (file-exists? file-path) (dir-exists? path))\n      (do\n        (clojure.java.shell/sh\n          \&quot;sh\&quot; \&quot;-c\&quot;\n          (str move-to-dir (File. path) next-command\n               gzip-command (str file file-ext \&quot; \&quot; file)))\n        (assoc x\n          :result (str file-path file-ext)))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-encode-file :ISO-8859-1\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (FileUtils/write\n          (File. file-path)\n          (FileUtils/readFileToString\n            (File. file-path) \&quot;UTF-8\&quot;) \&quot;ISO-8859-1\&quot;)\n        (assoc x\n          :result (str (:path x) \&quot;/\&quot; (:file x))))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-encode-file :UTF-8\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (FileUtils/write\n          (File. file-path)\n          (FileUtils/readFileToString\n            (File. file-path) \&quot;ISO-8859-1\&quot;) \&quot;UTF-8\&quot;)\n        (assoc x\n          :result (str (:path x) \&quot;/\&quot; (:file x))))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-create-temp-file :create-temp-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        full-path (str (:path x) \&quot;/\&quot; (:file x))]\n    (if (dir-exists? path)\n      (do\n        (io/writer\n          (io/file\n            (str path \&quot;/\&quot; file)))\n        (assoc x\n          :result full-path))\n      (throw\n        (IllegalArgumentException.\n          (str path \&quot; is not a directory\&quot;))))))&quot; &quot;(defmethod cetl-copy-file :copy-file\n  [x]\n  (let [file (:file x)\n        in-path (:in-path x)\n        out-path (:out-path x)\n        full-in-path (str (:in-path x) \&quot;/\&quot; (:file x))]\n    (cond (not (file-exists? full-in-path))\n          (throw\n            (IllegalArgumentException.\n              (str full-in-path \&quot; is not a file (or directory)\&quot;)))\n          (not (dir-exists? out-path))\n          (throw\n            (IllegalArgumentException.\n              (str out-path \&quot; is not a directory\&quot;)))\n          :else\n          (do\n            (io/copy\n              (io/file (str in-path \&quot;/\&quot; file))\n              (io/file (str out-path \&quot;/\&quot; file)))\n            (assoc x :result\n                      (str (:out-path x) \&quot;/\&quot; (:file x)))))))&quot; &quot;(defmethod cetl-delete-file :delete-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (do\n        (io/delete-file\n          (io/file\n            (str path \&quot;/\&quot; file)))\n        (assoc x\n          :result (str (:path x) \&quot;/\&quot; (:file x))))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-properties-file :file-properties\n  [x]\n  (let [file (File. (str (:path x) \&quot;/\&quot; (:file x)))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (file-exists? (.getAbsolutePath file))\n      (do (assoc x :result {:abs-file-path abs-file-path\n                            :parent-dir parent-dir\n                            :file-name file-name\n                            :read-permissions read-permissions\n                            :write-permissions write-permissions\n                            :execute-permissions execute-permissions\n                            :file-size file-size\n                            :modified-time-millis modified-time-millis\n                            :modified-time-str modified-time-str}))\n      (throw\n        (IllegalArgumentException.\n          (str file \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(cetl-properties-file {:path \&quot;/Users/gregadebesin/Development\&quot;\n                       :file \&quot;foo.tmp\&quot;\n                       :exec :file-properties})&quot; &quot;(cetl-encode-file {:path \&quot;/Users/gregadebesin/Development/untitled.txt\&quot;\n                   :exec :ISO-8859-1})&quot; &quot;(cetl-copy-file {:in-path \&quot;/Users/gregadebesin/Development\&quot;\n                 :out-path \&quot;/Users/gregadebesin\&quot;\n                 :file \&quot;foo.tmp\&quot;\n                 :exec :copy-file})&quot; &quot;(defmulti cetl-file-compare {:argslist '([map])} \n          (fn [x] (:exec x)))&quot; &quot;(defmulti cetl-properties-file {:arglists '([map])} \n          (fn [x] (:exec x)))&quot; &quot;(defmulti cetl-delete-file {:arglists '([map])} \n          (fn [x] (:exec x)))&quot; &quot;(defmulti cetl-copy-file {:arglists '([map])} \n          (fn [x] (:exec x)))&quot; &quot;(defmulti cetl-create-temp-file {:arglists '([map])} \n          (fn [x] (:exec x)))&quot; &quot;(defmulti cetl-encode-file {:arglists '([map])} \n          (fn [x] (:exec x)))&quot; &quot;(defmulti cetl-archive-file  {:arglists '([map])} \n          (fn [x] (:exec x)))&quot; &quot;(defmulti cetl-list-file {:arglists '([map])} \n          (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-file-compare\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]))&quot; &quot;(defmethod cetl-file-compare\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    2))&quot; &quot;(defmethod cetl-properties-file :properties-file\n  [x]\n  (let [file (File. (str (:path x) \&quot;/\&quot; (:file x)))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (file-exists? (.getAbsolutePath file))\n      (do (assoc x :result {:abs-file-path abs-file-path\n                            :parent-dir parent-dir\n                            :file-name file-name\n                            :read-permissions read-permissions\n                            :write-permissions write-permissions\n                            :execute-permissions execute-permissions\n                            :file-size file-size\n                            :modified-time-millis modified-time-millis\n                            :modified-time-str modified-time-str}))\n      (throw\n        (IllegalArgumentException.\n          (str file \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    2))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (File. (str path \&quot;/\&quot; file))]\n    ))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (FileUtils/contentEquals file-path-one file-path-two)))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond \n      (not (file-exists? file-path-one)) \n          (throw \n            (IllegalArgumentException. \n              (str file-path-one \n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two \n                   \&quot; is not a file (or a directory)\&quot;))) \n      :else\n          (do (assoc x :result\n                     (FileUtils/contentEquals file-path-one file-path-two))))))&quot; &quot;(defmulti cetl-compare-file {:argslist '([map])}\n          (fn [x] (:exec x)))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? file-path-one))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else\n          (do (assoc x :result\n                     (FileUtils/contentEquals file-path-one file-path-two))))))&quot; &quot;(ns cetl.core-test\n  (:require [clojure.test :refer :all]\n            [cetl.core :refer :all]\n            [cetl.file.management :refer :all]))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? file-path-one))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else (assoc x :result\n                    (FileUtils/contentEquals file-path-one file-path-two)))))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? file-path-one))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else \n      (FileUtils/contentEquals file-path-one file-path-two))))&quot; &quot;(symbol ddd)&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? file-path-one))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else\n      (FileUtils/contentEquals file-path-one file-path-two))))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? file-path-one))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else\n      (doto\n        (FileUtils/contentEquals file-path-one file-path-two)))))&quot; &quot;\&quot;/Users/gregadebesin/Development\&quot;&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? file-path-one))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      \n      (FileUtils/contentEquals file-path-one file-path-two))))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? file-path-one))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else  (FileUtils/contentEquals file-path-one file-path-two))))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? file-path-one))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else  (FileUtils/contentEquals  (File. \&quot;/Users/gregadebesin/Development/foo.txt\&quot;) (File. \&quot;/Users/gregadebesin/Development/bar.txt\&quot;)))))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists?]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.io File)\n           (java.text SimpleDateFormat)))&quot; &quot;(use '[clojure.java.shell :only [sh]])&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))\n        compare-files (FileUtils/contentEquals file-path-one file-path-two)]\n    (cond\n      (not (file-exists? file-path-one))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else compare-files)))&quot; &quot;(FileUtils/contentEquals (File. \&quot;/Users/gregadebesin/Development/foo.txt\&quot;) (File. \&quot;/Users/gregadebesin/Development/bar.txt\&quot;))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? (.getName file-path-one)))\n          (throw\n            (IllegalArgumentException.\n              (str (.getName file-path-one)\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? file-path-two))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else (FileUtils/contentEquals file-path-one file-path-two))))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? (.getName file-path-one)))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? (.getName file-path-two)))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else (FileUtils/contentEquals file-path-one file-path-two))))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? (.getAbsolutePath file-path-one)))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? (.getAbsolutePath file-path-two)))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else (FileUtils/contentEquals file-path-one file-path-two))))&quot; &quot;(defmethod cetl-compare-file :compare-file\n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists? \n             (.getAbsolutePath file-path-one)))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists? \n                 (.getAbsolutePath file-path-two)))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-two\n                   \&quot; is not a file (or a directory)\&quot;)))\n      :else (assoc x :result (FileUtils/contentEquals file-path-one file-path-two)))))&quot; &quot;(cetl-compare-file {:file-one \&quot;foo.txt\&quot;\n                    :path-one \&quot;/Users/gregadebesin/Development\&quot;\n                    :file-two \&quot;bar.txt\&quot;\n                    :path-two \&quot;/Users/gregadebesin/Development\&quot;\n                    :exec :compare-file})&quot;], :remote []}}</component>
</project>