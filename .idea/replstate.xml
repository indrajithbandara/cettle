<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1452205798767">{:repl-history {:ide [], :local [&quot;(defn build-zip-output-map\n  ([] nil)\n  ([f v] (assoc (empty f) :path (mapv #(str % \&quot;.zip\&quot;) v))))&quot; &quot;(cetl-zip-file {:path [\&quot;/Users/gra11/Development/file.txt\&quot; \&quot;/Users/gra11/Development/fil2.txt\&quot;]})&quot; &quot;(cetl-zip-file {:path [\&quot;/Users/gra11/Development/file.txt\&quot; \&quot;/Users/gra11/Development/file2.txt\&quot;]})&quot; &quot;(defn cetl-list-files\n    [x]\n    (cond (nil? x) nil\n      (file-exists? (path-from-map x))\n          (let [file-path (path-from-map x)]\n            (assoc x\n              :path (s/split\n                      (get (clojure.java.shell/sh\n                             \&quot;sh\&quot; \&quot;-c\&quot;\n                             (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                  \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n              :exec :cetl-list-files))))&quot; &quot;(cetl-list-files {:path \&quot;/Users/gra11\&quot;})&quot; &quot;(cetl-list-files {:path \&quot;/Users/gra11/Development\&quot;})&quot; &quot;(-&gt; {:path \&quot;/Users/gra11/Development\&quot;}\n    (cetl-list-files)\n    (cetl-zip-file))&quot; &quot;(defn zip-command\n  ([] nil)\n  ([m] (into {} (map (fn [y] \n                       (clojure.java.shell/sh \n                         \&quot;sh\&quot; \&quot;-c\&quot; \n                         (str \&quot; cd \&quot; (parent-path y) \&quot;;\&quot; \&quot; zip \&quot; (file-name y) \&quot;.zip\&quot; \&quot; -r \&quot; (file-name y)))) m))))&quot; &quot;(defn zip-command\n  ([] nil)\n  ([v] (into {} (map (fn [s] \n                       (clojure.java.shell/sh \n                         \&quot;sh\&quot; \&quot;-c\&quot; \n                         (str \&quot; cd \&quot; (parent-path s) \&quot;;\&quot; \&quot; zip \&quot; (file-name s) \&quot;.zip\&quot; \&quot; -r \&quot; (file-name s)))) v))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([m]\n   (cond (nil? m) nil\n         (check-files-exist m)\n         (let [path-from-map (path-from-map m)]\n           (build-zip-output-map\n             (zip-command path-from-map) path-from-map)))))&quot; &quot;(cetl-zip-file {:path [\&quot;/Users/gra11/Development/file.txt\&quot;]})&quot; &quot;(cycle [])&quot; &quot;(take 10 (cycle [1]))&quot; &quot;(take 10 (cycle (reduce + (range 1 20))))&quot; &quot;(take 10 (cycle (into [] (reduce + (range 1 20)))))&quot; &quot;(take 20 (repeat 2))&quot; &quot;(take 20 (repeatedly 2))&quot; &quot;(take 20 (repeatedly (println \&quot;\&quot;)))&quot; &quot;(take 30 (repeatedly (rand-int 2)))&quot; &quot;(take 30 (repeatedly #(rand-int 2)))&quot; &quot;(take 30 (repeatedly #(rand-int 10)))&quot; &quot;(map #(cond (string? %) (read-string %)\n            (integer? %) (str %))\n     [1 \&quot;2\&quot; 3 \&quot;4 5\&quot;])&quot; &quot;(mapv #(cond (string? %) (read-string %)\n            (integer? %) (str %))\n     [1 \&quot;2\&quot; 3 \&quot;4 5\&quot;])&quot; &quot;(defn check-files-exist\n  ([] nil)\n  ([m] (nil? (some false?\n                   (map #(file-exists? %) (path-from-map m))))))&quot; &quot;(defn zip-command\n  ([] nil)\n  ([v] (into {} (map (fn [s]\n                       (clojure.java.shell/sh\n                         \&quot;sh\&quot; \&quot;-c\&quot;\n                         (str \&quot; cd \&quot; (parent-path s) \&quot;;\&quot; \&quot; zip \&quot; (file-name s) \&quot;.zip\&quot; \&quot; -r \&quot; (file-name s)))) v))))&quot; &quot;(defn build-zip-output-map\n  ([] nil)\n  ([f v] (assoc (empty f) :path (mapv #(str % \&quot;.zip\&quot;) v) :exec :cetl-zip-file)))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([m]\n   (cond (nil? m) nil\n         (check-files-exist m)\n         (let [path-from-map (path-from-map m)]\n           (build-zip-output-map (zip-command path-from-map) path-from-map)))))&quot; &quot;(defrecord Name [foo bar])&quot; &quot;(map-&gt;Name {:foo 2 :bar 3})&quot; &quot;(defn gzip-command\n  ([] nil)\n  ([v] (into {} (map (fn [s]\n                       (clojure.java.shell/sh\n                         \&quot;sh\&quot; \&quot;-c\&quot;\n                         (str \&quot; cd \&quot; (parent-path s) \&quot;;\&quot;\n                              \&quot; tar -cvzf \&quot; (file-name s) \&quot;.tar.gz \&quot; (file-name s))))))))&quot; &quot;(defn gzip-command\n  ([] nil)\n  ([v] (into {} (map (fn [s]\n                       (clojure.java.shell/sh\n                         \&quot;sh\&quot; \&quot;-c\&quot;\n                         (str \&quot; cd \&quot; (parent-path s) \&quot;;\&quot; \&quot; tar -cvzf \&quot; (file-name s) \&quot;.tar.gz \&quot; (file-name s)))) v))))&quot; &quot;(defn build-gzip-output-map\n  ([] nil)\n  ([f v] (assoc (empty f) :path (mapv #(str % \&quot;.tar.gz\&quot;) v) :exec :cetl-gzip-file)))&quot; &quot;(defn cetl-gzip-file\n  ([] nil)\n  ([m]\n    (cond (nil? m) nil\n          (check-files-exist m)\n          (let [path-from-map (path-from-map m)]\n            (build-gzip-output-map (gzip-command path-from-map) path-from-map)))))&quot; &quot;(cetl-gzip-file {:path [\&quot;/Users/gra11/Development/file.txt\&quot;]})&quot; &quot;(cetl-gzip-file {:path [\&quot;/Users/gra11/Development/file.txt\&quot; \&quot;/Users/gra11/Development/file2.txt\&quot;]})&quot; &quot;(defn files-exist?\n  ([] nil)\n  ([m] (nil? (some false?\n                   (map #(file-exists? %) (path-from-map m))))))&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([m]\n   (cond (nil? m) nil\n         (files-exist? m)\n         (let [path-from-map (path-from-map m)]\n           (build-zip-output-map (zip-command path-from-map) path-from-map)))))&quot; &quot;(defn cetl-gzip-file\n  ([] nil)\n  ([m]\n    (cond (nil? m) nil\n          (files-exist? m)\n          (let [path-from-map (path-from-map m)]\n            (build-gzip-output-map (gzip-command path-from-map) path-from-map)))))&quot; &quot;(defn cetl-list-dirs-files\n    [x]\n    (cond (nil? x) nil\n      (file-exists? (path-from-map x))\n          (let [file-path (path-from-map x)]\n            (assoc x\n              :path (s/split\n                      (get (clojure.java.shell/sh\n                             \&quot;sh\&quot; \&quot;-c\&quot;\n                             (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                  \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n              :exec :cetl-list-dirs-files))))&quot; &quot;(cetl-list-dirs-files {:path [\&quot;/Users/gra11/Development\&quot;]})&quot; &quot;(some #(nil?) [nil 2])&quot; &quot;(some #(nil? %) [nil 2])&quot; &quot;(some #(nil? %) [2])&quot; &quot;(some #(nil? %) [2 nil])&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([m]\n   (if (all-files-exist? m) \n     (let [path-from-map (path-from-map m)]\n       (build-zip-output-map (zip-command path-from-map) path-from-map)))))&quot; &quot;(all-files-exist? nil)&quot; &quot;(cetl-zip-file nil)&quot; &quot;(defn cetl-gzip-file\n  ([] nil)\n  ([m]\n    (if (all-files-exist? m)\n      (let [path-from-map (path-from-map m)] \n        (build-gzip-output-map (gzip-command path-from-map) path-from-map)))))&quot; &quot;(cetl-gzip-file nil)&quot; &quot;(defn cetl-zip-file\n  ([] nil)\n  ([m]\n   (if (all-files-exist? m)\n     (let [path-from-map (path-from-map m)]\n       (build-zip-output-map (zip-command path-from-map) path-from-map)))))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.file :refer [file-exists? file-name path-from-map isDir? parent-path]])\n  (:import (java.io File LineNumberReader)\n           (org.apache.commons.io FileUtils)\n           (java.text SimpleDateFormat)))&quot; &quot;(use '[clojure.java.shell :only [sh]])&quot; &quot;(clojure.repl/source map)&quot; &quot;(map inc [1 2 3 nil])&quot; &quot;(fnil (fn [x] nil) \&quot;fOO\&quot;)&quot; &quot;(fnil nil \&quot;fOO\&quot;)&quot; &quot;(def foo \n  [f]\n  (fnil f \&quot;This is nil\&quot;))&quot; &quot;(defn foo \n  [f]\n  (fnil f \&quot;This is nil\&quot;))&quot; &quot;(foo (fn [] nil))&quot; &quot;(fn [] nil)&quot; &quot;(fn [] (nil))&quot; &quot;(fn  nil)&quot; &quot;(defn foo \n  [f]\n  ((fnil f \&quot;This is nil\&quot;) nil))&quot; &quot;(foo nil)&quot; &quot;(foo \&quot;\&quot;)&quot; &quot;(fnil nil \&quot;facv\&quot;)&quot; &quot;((fnil nil \&quot;facv\&quot;))&quot; &quot;((fnil nil \&quot;facv\&quot;) nil)&quot; &quot;((fnil nil \&quot;facv\&quot;) \&quot;\&quot;)&quot; &quot;(fnil (fn [x] (* x x)) \&quot;facv\&quot;)&quot; &quot;((fnil (fn [x] (* x x)) \&quot;facv\&quot;) 2)&quot; &quot;((fnil (fn [x] (if (nil? x) nil x)) \&quot;facv\&quot;) 2)&quot; &quot;((fnil (fn [x] (if (nil? x) nil x)) \&quot;facv\&quot;) nil)&quot; &quot;((fnil (fn [x] (if (nil? x) nil x)) (IllegalAccessException. \&quot;fasdcsa\&quot;)) nil)&quot; &quot;(IllegalAccessException. \&quot;faccs\&quot;)&quot; &quot;(inc nil)&quot; &quot;(inc [])&quot; &quot;((fnil (fn [x] (if (nil? x) nil x)) (NullPointerException. \&quot;fasdcsa\&quot;)) nil)&quot; &quot;(defn all-files-exist?\n  (identity [])\n  ([nil])\n  ([m] (if (nil? m) nil\n                    (nil? (some false?\n                                (map #(file-exists? %) (path-from-map m)))))))&quot; &quot;(defn all-files-exist?\n  ([] (identity))\n  ([nil])\n  ([m] (if (nil? m) nil\n                    (nil? (some false?\n                                (map #(file-exists? %) (path-from-map m)))))))&quot; &quot;(defn all-files-exist?\n  ([] (. clojure.lang.RT []))\n  ([nil])\n  ([m] (if (nil? m) nil\n                    (nil? (some false?\n                                (map #(file-exists? %) (path-from-map m)))))))&quot; &quot;(defn all-files-exist?\n  ([] ())\n  ([nil])\n  ([m] (if (nil? m) nil\n                    (nil? (some false?\n                                (map #(file-exists? %) (path-from-map m)))))))&quot; &quot;(clojure.repl/source conj)&quot; &quot;()&quot; &quot;(clojure.repl/source cons)&quot; &quot;(clojure.repl/source for)&quot; &quot;(identity [])&quot; &quot;(defn all-files-exist?\n  ([] ([]))\n  ([nil] nil)\n  ([m] (if (nil? m) nil\n                    (nil? (some false?\n                                (map #(file-exists? %) (path-from-map m)))))))&quot; &quot;(defn all-files-exist?\n  ([] [])\n  (nil nil)\n  ([m] (if (nil? m) nil\n                    (nil? (some false?\n                                (map #(file-exists? %) (path-from-map m)))))))&quot; &quot;(defn all-files-exist?\n  ([] [])\n  ([nil] nil)\n  ([m] (if (nil? m) nil\n                    (nil? (some false?\n                                (map #(file-exists? %) (path-from-map m)))))))&quot; &quot;((fnil nil (IllegalAccessException. \&quot;fasdcsa\&quot;)) nil)&quot; &quot;(defn all-files-exist?\n  ([] [])\n  (nil? (some false?\n              (map #(file-exists? %) (path-from-map m)))))&quot; &quot;(defn all-files-exist?\n  ([] [])\n  ([m]\n   (nil? (some false?\n               (map #(file-exists? %) (path-from-map m))))))&quot; &quot;(defn all-files-exist?\n  ([] (identity []))\n  ([m]\n   (nil? (some false?\n               (map #(file-exists? %) (path-from-map m))))))&quot; &quot;(defn all-files-exist?\n  ([] [])\n  ([m] (if (nil? m) nil\n                    (nil? (some false?\n                                (map #(file-exists? %) (path-from-map m)))))))&quot; &quot;(defn all-files-exist?\n  ([] ([]))\n  ([m] (if (nil? m) nil\n                    (nil? (some false?\n                                (map #(file-exists? %) (path-from-map m)))))))&quot; &quot;(all-files-exist? [])&quot; &quot;(defn all-files-exist?\n  (identity [])\n  ([m] (if (nil? m) nil\n                    (nil? (some false?\n                                (map #(file-exists? %) (path-from-map m)))))))&quot; &quot;(defn all-files-exist?\n  ([] nil)\n  ([m] (if (nil? m) nil\n                    (nil? (some false?\n                                (map #(file-exists? %) (path-from-map m)))))))&quot; &quot;(clojure.repl/source vec)&quot; &quot;(clojure.repl/source vector)&quot;], :remote []}}</component>
</project>