<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1449964287007">{:repl-history {:ide [], :local [&quot;(defn cetl-copy-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        full-in-path (str (first path) \&quot;/\&quot; file)\n        in-path (first path)\n        out-path (second path)]\n    (if (and (file-exists? full-in-path) \n             (dir-exists? in-path) \n             (dir-exists? out-path))\n      (do\n        (io/copy\n          (io/file (str in-path \&quot;/\&quot; file))\n          (io/file (str out-path \&quot;/\&quot; file)))\n        (assoc x :result (str (second (:path x)) \&quot;/\&quot; (:file x)))))))&quot; &quot;(cetl-copy-file {:path [\&quot;/Users/gra11/Development\&quot; \&quot;/Users/gra11\&quot;]\n                 :file \&quot;file.tx\&quot;})&quot; &quot;(cetl-copy-file {:path [\&quot;/Users/ra11/Development\&quot; \&quot;/Users/gra11\&quot;]\n                 :file \&quot;file.txt\&quot;})&quot; &quot;(cetl-copy-file {:path [\&quot;/Users/gra11/Development\&quot; \&quot;/Usrs/gra11\&quot;]\n                 :file \&quot;file.txt\&quot;})&quot; &quot;(cetl-copy-file {:path [\&quot;/Users/gra11/Development\&quot; \&quot;/Users/gra11\&quot;]\n                 :file \&quot;fie.txt\&quot;})&quot; &quot;(and true true)&quot; &quot;(and true true false)&quot; &quot;(defn dir-exists?\n  [path]\n  (cond\n    (map? path)\n    (let [file (io/file (:path path))]\n      (if (and (.exists file) (.isDirectory file))\n        path\n        (throw\n          (IllegalArgumentException.\n            (str path \&quot; is not a file\&quot;)))))\n    (string? path)\n    (let [file (io/file path)]\n      (if (and (.exists file) (.isDirectory file))\n        path))))&quot; &quot;(defn dir-exists?\n  [path]\n  (cond\n    (map? path)\n    (let [file (io/file (:path path))]\n      (if (and (.exists file) (.isDirectory file))\n        path\n        (throw\n          (IllegalArgumentException.\n            (str path \&quot; is not a directory\&quot;)))))\n    (string? path)\n    (let [file (io/file path)]\n      (if (and (.exists file) (.isDirectory file))\n        path\n        (throw\n          (IllegalArgumentException.\n            (str path \&quot; is not a directory\&quot;)))))))&quot; &quot;(defn cetl-copy-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        full-in-path (str (first path) \&quot;/\&quot; file)\n        in-path (first path)\n        out-path (second path)]\n    (if (and (file-exists? full-in-path)\n             (dir-exists? in-path)\n             (dir-exists? out-path))\n      (do\n        (io/copy\n          (io/file (str in-path \&quot;/\&quot; file))\n          (io/file (str out-path \&quot;/\&quot; file)))\n        (assoc x :result (str (second (:path x)) \&quot;/\&quot; (:file x)))))))&quot; &quot;(cetl-copy-file {:path [\&quot;/Users/gra11/Development\&quot; \&quot;/Users/ga11\&quot;]\n                 :file \&quot;file.txt\&quot;})&quot; &quot;(defmethod cetl-file-management :count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (if (file-exists? file-path)\n      (do (.skip line-num-reader Long/MAX_VALUE)\n          (assoc x :result (+ 1 (.getLineNumber line-num-reader))))\n      (finally\n        (.close line-num-reader)))))&quot; &quot;(defmethod cetl-file-management :count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (if (file-exists? file-path)\n      (do (.skip line-num-reader Long/MAX_VALUE)\n          (assoc x :result (+ 1 (.getLineNumber line-num-reader)))\n          (.close line-num-reader)))))&quot; &quot;(defmethod cetl-file-management :count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (if (file-exists? file-path)\n      (do (.skip line-num-reader Long/MAX_VALUE)\n          (assoc x :result (+ 1 (.getLineNumber line-num-reader))))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))\n        (finally\n          (.close line-num-reader))))))&quot; &quot;(defn cetl-count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (if (file-exists? file-path)\n      (do (.skip line-num-reader Long/MAX_VALUE)\n          (assoc x :result (+ 1 (.getLineNumber line-num-reader))))\n      (finally\n        (.close line-num-reader)))))&quot; &quot;(defn cetl-count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (if (file-exists? file-path)\n      (do (.skip line-num-reader Long/MAX_VALUE)\n          (assoc x :result (+ 1 (.getLineNumber line-num-reader))))\n      (throw\n        \n        (finally\n          (.close line-num-reader))))))&quot; &quot;(cetl-copy-file {:path [\&quot;/Users/gra11/Development\&quot; \&quot;/Users/gra11\&quot;]\n                 :file \&quot;file.txt\&quot;})&quot; &quot;(defn cetl-properties-file\n  [x]\n  (let [file (io/file (str (:path x) \&quot;/\&quot; (:file x)))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (file-exists? (.getAbsolutePath file))\n      (do (assoc x :result {:abs-file-path abs-file-path\n                            :parent-dir parent-dir\n                            :file-name file-name\n                            :read-permissions read-permissions\n                            :write-permissions write-permissions\n                            :execute-permissions execute-permissions\n                            :file-size file-size\n                            :modified-time-millis modified-time-millis\n                            :modified-time-str modified-time-str}))\n      (throw\n        (IllegalArgumentException.\n          (str file \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defn cetl-properties-file\n  [x]\n  (let [file (io/file (str (:path x) \&quot;/\&quot; (:file x)))\n        abs-file-path (.getAbsolutePath file)\n        parent-dir (.getParent file)\n        file-name (.getName file)\n        read-permissions (.canRead file)\n        write-permissions (.canWrite file)\n        execute-permissions (.canExecute file)\n        file-size (-&gt;&gt; (reduce #(/ %1 %2) [(.length file) 1048576])\n                       double\n                       (format \&quot;%.3f\&quot;)\n                       read-string)\n        modified-time-millis (.lastModified file)\n        modified-time-str (.format (SimpleDateFormat. \&quot;yyyy-MM-dd HH:mm:ss.SSS\&quot;) modified-time-millis)\n        exec (:exec x)]\n    (if (file-exists? (.getAbsolutePath file))\n      (do (assoc x :result {:abs-file-path abs-file-path\n                            :parent-dir parent-dir\n                            :file-name file-name\n                            :read-permissions read-permissions\n                            :write-permissions write-permissions\n                            :execute-permissions execute-permissions\n                            :file-size file-size\n                            :modified-time-millis modified-time-millis\n                            :modified-time-str modified-time-str})))))&quot; &quot;(cetl-properties-file {:path  \&quot;/Users/gra11/Development\&quot; \n                       :file \&quot;file.txt\&quot;})&quot; &quot;(defn cetl-count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (if (file-exists? file-path)\n      (do (.skip line-num-reader Long/MAX_VALUE)\n          (assoc x :result (+ 1 (.getLineNumber line-num-reader))))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))\n        (finally\n          (.close line-num-reader))))))&quot; &quot;(defn cetl-count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (if (file-exists? file-path)\n      (doto (line-num-reader) (.skip Long/MAX_VALUE)\n          (assoc x :result (+ 1 (.getLineNumber line-num-reader))))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))\n        (finally\n          (.close line-num-reader))))))&quot; &quot;(defn cetl-count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (if (file-exists? file-path)\n      (doto (line-num-reader) (.skip Long/MAX_VALUE) \n          (assoc x :result (+ 1 (.getLineNumber line-num-reader)))\n                              (.close))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))\n        (finally\n          (.close line-num-reader))))))&quot; &quot;(defn cetl-count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (if (file-exists? file-path)\n      (doto (line-num-reader) \n        (.skip Long/MAX_VALUE) \n          (assoc x :result (+ 1 (.getLineNumber line-num-reader)))\n                              (.close)))))&quot; &quot;(defn cetl-count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (if (file-exists? file-path)\n      (doto line-num-reader \n        (.skip Long/MAX_VALUE) \n          (assoc x :result (+ 1 (.getLineNumber line-num-reader)))\n                              (.close)))))&quot; &quot;(do)&quot; &quot;(cetl-count-row-file {:path  \&quot;/Users/gra11/Development\&quot; \n                       :file \&quot;file.tx\&quot;})&quot; &quot;(defn compare-file \n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (cond\n      (not (file-exists?\n             (.getAbsolutePath file-path-one)))\n          (throw\n            (IllegalArgumentException.\n              (str file-path-one\n                   \&quot; is not a file (or a directory)\&quot;)))\n          (not (file-exists?\n                 (.getAbsolutePath file-path-two)))\n      :else (assoc x :result (FileUtils/contentEquals file-path-one file-path-two)))))&quot; &quot;(defn compare-file \n  [x]\n  (let [file-one (:file-one x)\n        path-one (:path-one x)\n        file-path-one (File. (str path-one \&quot;/\&quot; file-one))\n        file-two (:file-two x)\n        path-two (:path-two x)\n        file-path-two (File. (str path-two \&quot;/\&quot; file-two))]\n    (if\n      (and (file-exists? (.getAbsolutePath file-path-one))\n           (file-exists? (.getAbsolutePath file-path-two)))\n      (assoc x :result (FileUtils/contentEquals file-path-one file-path-two)))))&quot; &quot;(defmethod cetl-touch-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (assoc x :result\n               (.setLastModified (File. file-path) (.getTime (Date.))))\n      (do\n        (cetl-create-temp-file {:file file :path path})\n        (assoc x :result file-path)))))&quot; &quot;(defn cetl-touch-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)]\n    (if (file-exists? file-path)\n      (assoc x :result\n               (.setLastModified (File. file-path) (.getTime (Date.))))\n      (do\n        (cetl-create-temp-file {:file file :path path})\n        (assoc x :result file-path)))))&quot; &quot;(defn cetl-count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (if (file-exists? file-path)\n      (do (.skip line-num-reader Long/MAX_VALUE)\n          (.close line-num-reader)\n          (assoc x :result (+ 1 (.getLineNumber line-num-reader)))))))&quot; &quot;(cetl-count-row-file {:path  \&quot;/Users/gra1/Development\&quot; \n                       :file \&quot;file.txt\&quot;})&quot; &quot;(defn cetl-count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (if (file-exists? file-path)\n      (do (.skip line-num-reader Long/MAX_VALUE)\n          (.close line-num-reader)\n          (assoc x :result (-1 (.getLineNumber line-num-reader)))))))&quot; &quot;(defn cetl-count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (if (file-exists? file-path)\n      (do (.skip line-num-reader Long/MAX_VALUE)\n          (.close line-num-reader)\n          (assoc x :result (- 1 (.getLineNumber line-num-reader)))))))&quot; &quot;(defn cetl-count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (if (file-exists? file-path)\n      (do (.skip line-num-reader Long/MAX_VALUE)\n          (.close line-num-reader)\n          (assoc x :result (.getLineNumber line-num-reader))))))&quot; &quot;(defn cetl-count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (doto (LineNumberReader.) (io/reader) (io/file file-path) )]\n    (if (file-exists? file-path)\n      (do (.skip line-num-reader Long/MAX_VALUE)\n          (.close line-num-reader)\n          (assoc x :result (.getLineNumber line-num-reader))))))&quot; &quot;(defn cetl-count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (doto  LineNumberReader. (io/reader) (io/file file-path) )]\n    (if (file-exists? file-path)\n      (do (.skip line-num-reader Long/MAX_VALUE)\n          (.close line-num-reader)\n          (assoc x :result (.getLineNumber line-num-reader))))))&quot; &quot;(defn cetl-count-row-file\n  [x]\n  (let [file (:file x)\n        path (:path x)\n        file-path (str path \&quot;/\&quot; file)\n        line-num-reader (-&gt; (io/file file-path) (io/reader) (LineNumberReader.))]\n    (if (file-exists? file-path)\n      (do (.skip line-num-reader Long/MAX_VALUE)\n          (.close line-num-reader)\n          (assoc x :result  (.getLineNumber line-num-reader))))))&quot; &quot;(defn cetl-gpg-encrypt-file\n  [x]\n  (if (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n    (let [recipient (:recipient x)\n          file (:file x)\n          move-to-dir \&quot; cd \&quot;\n          command (str \&quot; gpg --recipient \&quot;recipient\&quot; --encrypt \&quot;file)\n          next-command \&quot;;\&quot;]\n      (do\n        (get (clojure.java.shell/sh\n               \&quot;sh\&quot; \&quot;-c\&quot;\n               (str move-to-dir (:path x)\n                    next-command\n                    command)) :out)\n        (assoc x :result (str (:path x) \&quot;/\&quot; (:file x) \&quot;.gpg\&quot;))))))&quot; &quot;(cetl-count-row-file {:path  \&quot;/Users/gra11/Development\&quot; \n                       :file \&quot;file.txt\&quot;})&quot; &quot;(defn cetl-zip-file [x]\n    [x]\n    (if (or (file-exists? x)\n            (dir-exists? x))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))))&quot; &quot;(File. \&quot;/Users/gra11/Development/file.txt\&quot;)&quot; &quot;\n(.getFileName File. \&quot;/Users/gra11/Development/file.txt\&quot;)&quot; &quot;\n(.getFileName (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(.getAbsoluteFile (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(.getName (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(defprotocol FileLike\n  [x]\n  (^String protocol-of [x]))&quot; &quot;(defprotocol FileLike\n  [x]\n  (protocol-of [x]))&quot; &quot;(defprotocol FileLike\n  (protocol-of [x]))&quot; &quot;(defprotocol FileLike\n  (^String  protocol-of [x]))&quot; &quot;(defprotocol FileLike\n  (^String  protocol-of [x] \&quot;Returns protocol of a given input\&quot;)\n  (^String  file-name-of [x] \&quot;Returns file name of a given input\&quot;))&quot; &quot;(extend-protocol\n  FileLike\n  File)&quot; &quot;(defprotocol FileLike\n  (^String  file-name-of [x] \&quot;Returns file name of a given input\&quot;))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  ())&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name-of [^File file]\n    (.getName file)))&quot; &quot;(defprotocol FileLike\n  (^String  file-name [x] \&quot;Returns file name of a given input\&quot;))&quot; &quot;(defprotocol FileLike\n  (^String  file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  is-dir? [x] \&quot;Returns file name of a given input\&quot;))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (is-file? [^File file] (.getName file)))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file?? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file)))&quot; &quot;(file-name-of (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(defprotocol FileLike\n  (^File  file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (^String  abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;))&quot; &quot;(file-name (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(defprotocol FileLike\n  (^String file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (^String  abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^String file] (.getName file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file?? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file)))&quot; &quot;(defprotocol FileLike\n  (^String  file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (^File  is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (^String  abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file?? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file)))&quot; &quot;(defprotocol FileLike\n  (^String  file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (^String  abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;))&quot; &quot;(ns cetl.utils.component-utils\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io])\n  (import [java.io File]))&quot; &quot;(defprotocol FileLike\n  (^String  file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (^Boolean  is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (^String  abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (is-file? [^Boolean file] (.isFile file))\n  (exists-file? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file)))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file)))&quot; &quot;(is-file? (File. \&quot;/Users/gra11/Development/file.tx\&quot;))&quot; &quot;(is-file? (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(defprotocol FileLike\n  (^String  file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (^Boolean is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^Boolean  is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (^String  abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;))&quot; &quot;(defprotocol FileLike\n  (^String  file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (^Boolean is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^Boolean is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (^String  abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;))&quot; &quot;(defprotocol FileLike\n  (^String  file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (^Boolean is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^Boolean is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (^String  abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;)\n  (^String  abs-file [x] \&quot;Returns the absolute file of a given input\&quot;))&quot; &quot;(defprotocol FileLike\n  (^String  file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (^Boolean is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (^Boolean is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (^String  file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (^String  abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;)\n  (^File  abs-file [x] \&quot;Returns the absolute file of a given input\&quot;))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file))\n  (abs-file [^File file] (.getAbsolutePath file)))&quot; &quot;(abs-file (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file))\n  (abs-file [^String file] (.getAbsoluteFile file)))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file))\n  (abs-file [^File file] (.getAbsoluteFile file)))&quot; &quot;(defprotocol FileLike\n  (file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;)\n  (^String abs-file [x] \&quot;Returns the absolute file of a given input\&quot;))&quot; &quot;(abs-file  \&quot;/Users/gra11/Development/file.txt\&quot;)&quot; &quot;(defprotocol FileLike\n  (file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;)\n  (abs-file [x] \&quot;Returns the absolute file of a given input\&quot;))&quot; &quot;(io/file \&quot;Users/gra11\&quot;)&quot; &quot;(defn dir-exists?\n  [path]\n  (cond\n    (map? path)\n    (let [file (io/file (:path path))]\n      (if (and (exists-file? file) (is-dir? file))\n        path\n        (throw\n          (IllegalArgumentException.\n            (str path \&quot; is not a directory\&quot;)))))\n    (string? path)\n    (let [file (io/file path)]\n      (if (and (exists-file? file) (is-dir? file))\n        path\n        (throw\n          (IllegalArgumentException.\n            (str path \&quot; is not a directory\&quot;)))))))&quot; &quot;(defprotocol FileLike\n  (file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (dir-name [x] \&quot;Returns the directory name of a given input\&quot;)\n  (is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;)\n  (abs-file [x] \&quot;Returns the absolute file of a given input\&quot;))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (dir-name [^File file] (.getParent file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file))\n  (abs-file [^File file] (.getAbsoluteFile file)))&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (dir-name [^File file] (.getParentFile file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file))\n  (abs-file [^File file] (.getAbsoluteFile file)))&quot; &quot;(dir-name (File. \&quot;/Users/gra11/Development/file.txt\&quot;))&quot; &quot;(file-name (File. \&quot;/Users/gra11/Development\&quot;))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists?]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.util Date)\n           (java.io File LineNumberReader)\n           (java.text SimpleDateFormat)))&quot; &quot;(use '[clojure.java.shell :only [sh]])&quot; &quot;(defn cetl-zip-file [x]\n    [x]\n    (if (file-exists? x)\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists? file-name]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.util Date)\n           (java.io File LineNumberReader)\n           (java.text SimpleDateFormat)))&quot; &quot;(defn cetl-zip-file [x]\n    [x]\n    (if (file-exists? x)\n      (let [path (:path x)\n            file-name (file-name path)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file-name \&quot;.zip\&quot; \&quot; -r \&quot; file-name))\n          (assoc x\n            :result (str path \&quot;.zip\&quot;)\n            :exec :zip-file)))))&quot; &quot;(cetl-zip-file {:path \&quot;/Users/gra11/Development/file.txt\&quot;})&quot; &quot;(extend-protocol\n  FileLike\n  File\n  (file-name [^File file] (.getName file))\n  (parent-path [^File file] (.getParentFile file))\n  (is-file? [^File file] (.isFile file))\n  (exists-file? [^File file] (.exists file))\n  (is-dir? [^File file] (.isDirectory file))\n  (abs-file-path [^File file] (.getAbsolutePath file))\n  (abs-file [^File file] (.getAbsoluteFile file)))&quot; &quot;(defprotocol FileLike\n  (file-name [x] \&quot;Returns file name of a given input\&quot;)\n  (parent-path [x] \&quot;Returns the directory name of a given input\&quot;)\n  (is-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (exists-file? [x] \&quot;Returns file name of a given input\&quot;)\n  (is-dir? [x] \&quot;Returns file name of a given input\&quot;)\n  (file-path [x] \&quot;Returns the file path of a given input\&quot;)\n  (abs-file-path [x] \&quot;Returns the absolute file path of a given input\&quot;)\n  (abs-file [x] \&quot;Returns the absolute file of a given input\&quot;))&quot; &quot;(cetl-zip-file {:path (File. \&quot;/Users/gra11/Development/file.txt\&quot;)})&quot;], :remote []}}</component>
</project>