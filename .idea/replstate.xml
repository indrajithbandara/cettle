<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1443132452851">{:repl-history {:ide [], :local [&quot;\n(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs? include-hidden-files?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d \&quot;))\n              :out) #\&quot;\\n\&quot;))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false)\n           (= include-hidden-files? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false)\n           (= include-hidden-files? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false)\n           (= include-hidden-files? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true)\n           (= include-hidden-files? false))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;\n(defn cetl-file-list\n  ([path &amp; {:keys\n                [dirs-only? files-only? dirs-&amp;-files?\n                 include-sub-dirs? include-hidden-files?]\n            :or {include-sub-dirs? false}}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (and (= dirs-&amp;-files? true)\n            (= include-sub-dirs? false)\n            (= include-hidden-files? false))\n       (dirs-&amp;-files path)\n       (and (= files-only? true)\n            (= include-sub-dirs? false)\n            (= include-hidden-files? false))\n       (files-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? false)\n            (= include-hidden-files? false))\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true)\n            (= include-hidden-files? false))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;\n(defn cetl-file-list\n  ([path &amp; {:keys\n                [dirs-only? files-only? dirs-&amp;-files?\n                 include-sub-dirs? include-hidden-files?]\n            :or {include-sub-dirs? false}}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (and (= dirs-&amp;-files? true)\n            (= include-hidden-files? false))\n       (dirs-&amp;-files path)\n       (and (= files-only? true)\n            (= include-hidden-files? false))\n       (files-only path)\n       (and (= dirs-only? true)\n            (= include-hidden-files? false))\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true)\n            (= include-hidden-files? false))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development/Cetl/TestFiles\&quot; :dirs-&amp;-files? true :include-hidden-files? false)&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development/Cetl/TestFiles\&quot; :dirs-&amp;-files? true :include-sub_dirs? false :include-hidden-files? false)&quot; &quot;(defn cetl-file-list\n  ([path &amp; {:keys\n            [dirs-only? files-only? dirs-&amp;-files?\n             include-sub-dirs?]}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (and (= dirs-&amp;-files? true)\n            (= include-sub-dirs? false))\n       (dirs-&amp;-files path)\n       (and (= files-only? true)\n            (= include-sub-dirs? false))\n       (files-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? false))\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;(defn cetl-file-list\n  ([path &amp; {:keys\n            [dirs-only? files-only? dirs-&amp;-files?\n             include-sub-dirs?]\n            :or {include-sub-dirs? false}}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (and (= dirs-&amp;-files? true)\n            (= include-sub-dirs? false))\n       (dirs-&amp;-files path)\n       (and (= files-only? true)\n            (= include-sub-dirs? false))\n       (files-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? false))\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;(defn cetl-file-list\n  ([path &amp; {:keys\n            [dirs-only? files-only? dirs-&amp;-files?\n             include-sub-dirs?]\n            :or {include-sub-dirs? false}}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (and (= dirs-&amp;-files? true))\n       (dirs-&amp;-files path)\n       (and (= files-only? true))\n       (files-only path)\n       (and (= dirs-only? true))\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development/Cetl/TestFiles\&quot; :dirs-&amp;-files? true)&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development/Cetl/TestFiles\&quot; :dirs-only? true :include-sub-dirs? true)&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development/Cetl\&quot; :dirs-only? true :include-sub-dirs? true)&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development\&quot; :dirs-only? true)&quot; &quot;(defn cetl-file-list\n  ([path &amp; {:keys\n            [dirs-only? files-only? dirs-&amp;-files?\n             include-sub-dirs?]\n            :or {include-sub-dirs? false}}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (= dirs-&amp;-files? true)\n       (dirs-&amp;-files path)\n       (= files-only? true)\n       (files-only path)\n       (= dirs-only? true)\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;(defn cetl-file-list\n  ([path &amp; {:keys\n            [dirs-only? files-only? dirs-&amp;-files?\n             include-sub-dirs?]\n        :or {include-sub-dirs? false}}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (= dirs-&amp;-files? true)\n       (dirs-&amp;-files path)\n       (= files-only? true)\n       (files-only path)\n       (= dirs-only? true)\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot; \n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d \&quot;))\n              :out) #\&quot;\\n\&quot;))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development\&quot; :dirs-only? true :include-sub-dirs? true)&quot; &quot;(get (clojure.java.shell/sh\n       \&quot;sh\&quot; \&quot;-c\&quot;\n       (str \&quot; cd \&quot; p \&quot;;\&quot;\n            \&quot; find `pwd` -type d \&quot;))\n     :out) #\&quot;\\n\&quot;)&quot; &quot;(get (clojure.java.shell/sh\n       \&quot;sh\&quot; \&quot;-c\&quot;\n       (str \&quot; cd \&quot; p \&quot;;\&quot;\n            \&quot; find `pwd` -type d \&quot;))\n     :out)&quot; &quot;(get (clojure.java.shell/sh\n       \&quot;sh\&quot; \&quot;-c\&quot;\n       (str \&quot; cd \&quot;  \&quot;/Users/gregadebesin/Development\&quot; \&quot;;\&quot;\n            \&quot; find `pwd` -type d \&quot;))\n     :out)&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d \&quot;))\n              :out) #\&quot;\\n\&quot;))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development\&quot; \n                :dirs-only? true \n                :include-sub-dirs? false)&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d \&quot;))\n              :out) #\&quot;\\n\&quot;))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path)\n      :else nil)))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d \&quot;))\n              :out) #\&quot;\\n\&quot;))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n     \n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development\&quot; \n                :dirs-only? true \n                :include-sub-dirs? true)&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs? include-hidden-files?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d \&quot;))\n              :out) #\&quot;\\n\&quot;))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false)\n           (= include-hidden-files? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false)\n           (= include-hidden-files? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false)\n           (= include-hidden-files? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true)\n           (= include-hidden-files? false))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development\&quot; \n                :dirs-only? true \n                :include-sub-dirs? true\n                :include-hidden-files? false)&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development/\&quot; \n                :dirs-only? true \n                :include-sub-dirs? true\n                :include-hidden-files? false)&quot; &quot;22&quot; &quot;(defn foo \n  ([x &amp; {:keys [baz]\n         :or [baz false]}]))&quot; &quot;(defmulti greeting\n          (fn[x] (x \&quot;language\&quot;)))&quot; &quot;(defmethod greeting \&quot;English\&quot; [params]\n  \&quot;Hello!\&quot;)&quot; &quot;(defmethod greeting \&quot;French\&quot; [params]\n  \&quot;Bonjour!\&quot;)&quot; &quot;(defmethod greeting :default [params]\n  (throw (IllegalArgumentException.\n           (str \&quot;I don't know the \&quot; (params \&quot;language\&quot;) \&quot; language\&quot;))))&quot; &quot;(def  french-map {\&quot;id\&quot; \&quot;2\&quot;, \&quot;language\&quot; \&quot;French\&quot;})&quot; &quot;(def spanish-map {\&quot;id\&quot; \&quot;3\&quot;, \&quot;language\&quot; \&quot;Spanish\&quot;})&quot; &quot;(defmethod greeting \&quot;\&quot; [params]\n  \&quot;Hello!\&quot;)&quot; &quot;(greeting french-map)&quot; &quot;(defmethod greeting \&quot;fff\&quot; [params]\n  \&quot;Hello!\&quot;)&quot; &quot;(def english-map {\&quot;id\&quot; \&quot;1\&quot;, \&quot;language\&quot; \&quot;English\&quot;})&quot; &quot;(defmethod greeting \&quot;French\&quot; [params]\n   \&quot;Bonjour!\&quot;)&quot; &quot;(defmethod greeting :default [params]\n    (throw (IllegalArgumentException.\n             (str \&quot;I don't know the \&quot; (params \&quot;language\&quot;) \&quot; language\&quot;))))&quot; &quot;(greeting spanish-map)&quot; &quot;(greeting english-map)&quot; &quot;(defmulti dirs-only-command (fn [x] (:dirs-only? x)))&quot; &quot;(defmulti execute-command (fn [x] (:command x)))&quot; &quot;(defmethod full-moon-behavior :wolf\n  [were-creature]\n  (str (:name were-creature) \&quot; will howl and murder\&quot;))&quot; &quot;(full-moon-behavior {:were-type :wolf\n                     :name \&quot;Rachel from next door\&quot;})&quot; &quot;(partil + 3)&quot; &quot;(defmulti full-moon-behavior (fn [were-creature] (:were-type were-creature)))&quot; &quot;(defmethod full-moon-behavior :wolf\n  [were-creature]\n  (+ 8 8))&quot; &quot;(defmethod full-moon-behavior :simmons\n  [were-creature]\n  (str (:name were-creature) \&quot; will encourage people and sweat to the oldies\&quot;))&quot; &quot;(full-moon-behavior {:were-type :wolf})&quot; &quot;(full-moon-behavior {:name \&quot;Andy the baker\&quot;\n                     :were-type :simmons})&quot; &quot;(defmethod cetl-file-list :dirs-and-files\n  [path]\n  (clojure.string/split\n    (get (clojure.java.shell/sh\n           \&quot;sh\&quot; \&quot;-c\&quot;\n           (str \&quot; cd \&quot; p \&quot;;\&quot;\n                \&quot; find `pwd` -maxdepth 1 \&quot;))\n         :out) #\&quot;\\n\&quot;))&quot; &quot;(defmethod cetl-file-list :dirs-and-files\n  [path]\n  (clojure.string/split\n    (get (clojure.java.shell/sh\n           \&quot;sh\&quot; \&quot;-c\&quot;\n           (str \&quot; cd \&quot; path \&quot;;\&quot;\n                \&quot; find `pwd` -maxdepth 1 \&quot;))\n         :out) #\&quot;\\n\&quot;))&quot; &quot;(cetl-file-list )&quot; &quot;(defmethod cetl-file-list :dirs-and-files\n  [path]\n  (clojure.string/split\n    (get (clojure.java.shell/sh\n           \&quot;sh\&quot; \&quot;-c\&quot;\n           (str \&quot; cd \&quot; (:list path) \&quot;;\&quot;\n                \&quot; find `pwd` -maxdepth 1 \&quot;))\n         :out) #\&quot;\\n\&quot;))&quot; &quot;(defmulti cetl-file-list (fn [x] (:list x)))&quot; &quot;(defmethod cetl-file-list :dirs-and-files\n  [path]\n  (clojure.string/split\n    (get (clojure.java.shell/sh\n           \&quot;sh\&quot; \&quot;-c\&quot;\n           (str \&quot; cd \&quot; (:path path) \&quot;;\&quot;\n                \&quot; find `pwd` -maxdepth 1 \&quot;))\n         :out) #\&quot;\\n\&quot;))&quot; &quot;(defmethod cetl-file-list :files\n  [path]\n  (clojure.string/split\n    (get (clojure.java.shell/sh\n           \&quot;sh\&quot; \&quot;-c\&quot;\n           (str \&quot; cd \&quot; (:path path) \&quot;;\&quot;\n                \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n         :out) #\&quot;\\n\&quot;))&quot; &quot;(cetl-file-list {:path \&quot;/Users/gregadebesin/Development\&quot;\n                 :list :dirs-and-files})&quot; &quot;(defmethod cetl-file-list :dirs\n  [path]\n  (clojure.string/split\n    (get (clojure.java.shell/sh\n           \&quot;sh\&quot; \&quot;-c\&quot;\n           (str \&quot; cd \&quot; (:path path) \&quot;;\&quot;\n                \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n         :out) #\&quot;\\n\&quot;))&quot; &quot;(cetl-file-list {:path \&quot;/Users/gregadebesin/Development\&quot;\n                 :list :files})&quot; &quot;(cetl-file-list {:path \&quot;/Users/gregadebesin/Development\&quot;\n                 :list :dirs})&quot; &quot;(defmethod cetl-file-list :files-only-sub-dirs\n  []\n  )&quot; &quot;(defmethod cetl-file-list :dirs-only-sub-dirs\n  [path]\n  (clojure.string/split\n    (get (clojure.java.shell/sh\n           \&quot;sh\&quot; \&quot;-c\&quot;\n           (str \&quot; cd \&quot; {:path path} \&quot;;\&quot;\n                \&quot; find `pwd` -type d \&quot;))\n         :out) #\&quot;\\n\&quot;))&quot; &quot;(cetl-file-list {:path \&quot;/Users/gregadebesin/Development\&quot;\n                 :list :dirs-only-sub-dirs})&quot; &quot;(defn cetl-file-archive\n  [path &amp; {:keys [archive-format]}]\n  (letfn\n    [(zip\n       [p]\n       (clojure.java.shell/sh\n         \&quot;sh\&quot; \&quot;-c\&quot;\n         (str \&quot; cd \&quot; (.getParent (File. p)) \&quot;/;\&quot;\n              \&quot; zip \&quot; (last (s/split p #\&quot;/\&quot;)) \&quot;.zip\&quot;\n              \&quot; -r \&quot; (last (s/split p #\&quot;/\&quot;)))))\n     (gzip\n       [p]\n       (clojure.java.shell/sh\n         \&quot;sh\&quot; \&quot;-c\&quot;\n         (str \&quot; cd \&quot; (.getParent (File. p)) \&quot;/;\&quot;\n              \&quot; tar -cvzf \&quot; (last (s/split p #\&quot;/\&quot;)) \&quot;.tar.gz\&quot;\n              \&quot; \&quot; (last (s/split p #\&quot;/\&quot;)))))]\n    (cond\n      (= archive-format :zip) (zip path)\n      (= archive-format :gzip) (gzip path))))&quot; &quot;(defmethod cetl-file-archive :zip \n  [path]\n  (clojure.java.shell/sh\n    \&quot;sh\&quot; \&quot;-c\&quot;\n    (str \&quot; cd \&quot; (.getParent (File. (:path path))) \&quot;/;\&quot;\n         \&quot; zip \&quot; (last (s/split (:path path) #\&quot;/\&quot;)) \&quot;.zip\&quot;\n         \&quot; -r \&quot; (last (s/split (:path path) #\&quot;/\&quot;)))))&quot; &quot;(cetl-file-archive {:path \&quot;/\&quot;})&quot; &quot;(cetl-file-archive {:path \&quot;/Users/gregadebesin/Development/Cetl/archive\&quot;\n                    :archive :zip})&quot; &quot;(defmethod cetl-file-archive :gzip \n  [path]\n  (clojure.java.shell/sh\n    \&quot;sh\&quot; \&quot;-c\&quot;\n    (str \&quot; cd \&quot; (.getParent (File. (:path path))) \&quot;/;\&quot;\n         \&quot; tar -cvzf \&quot; (last (s/split (:path path) #\&quot;/\&quot;)) \&quot;.tar.gz\&quot;\n         \&quot; \&quot; (last (s/split (:path path) #\&quot;/\&quot;)))))&quot; &quot;(cetl-file-archive)&quot; &quot;(defmethod cetl-file-encode :UTF-8\n  [path]\n  (FileUtils/write\n     (File. (:out-path path))\n     (FileUtils/readFileToString\n       (File. (:in-path path)) (:encode path)) \&quot;ISO-8859-15\&quot;))&quot; &quot;(cetl-file-archive {:path \&quot;/Users/gregadebesin/Development/Cetl/archive\&quot;\n                    :archive :gzip})&quot; &quot;(defmethod cetl-file-encode :UTF-8\n  [path]\n  (FileUtils/write\n     (File. (:path path))\n     (FileUtils/readFileToString\n       (File. (:path path)) (:encode path)) \&quot;ISO-8859-15\&quot;))&quot; &quot;(defmethod cetl-file-encode \&quot;UTF-8\&quot;\n  [path]\n  (FileUtils/write\n     (File. (:path path))\n     (FileUtils/readFileToString\n       (File. (:path path)) (:encode path)) \&quot;ISO-8859-15\&quot;))&quot; &quot;(cetl-file-encode {:path \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file.txt\&quot;\n                   :encode \&quot;UTF-8\&quot;})&quot; &quot;(str :foo)&quot; &quot;(name :foo)&quot; &quot;(defmethod cetl-file-encode :UTF-8\n  [path]\n  (FileUtils/write\n     (File. (:path path))\n     (FileUtils/readFileToString\n       (File. (:path path)) (:encode (name path))) \&quot;ISO-8859-15\&quot;))&quot; &quot;(defmethod cetl-file-encode :UTF-8\n  [path]\n  (FileUtils/write\n     (File. (:path path))\n     (FileUtils/readFileToString\n       (File. (:path path)) (name (:encode path))) \&quot;ISO-8859-15\&quot;))&quot; &quot;(defmethod cetl-file-encode :ISO-8859-15\n  [path]\n  (FileUtils/write\n    (File. (:path path))\n    (FileUtils/readFileToString\n      (File. (:path path)) (name (:encode path))) \&quot;UTF-8\&quot;))&quot; &quot;(defmulti cetl-file-archive (fn [x] (:archive x)))&quot; &quot;(defmethod cetl-file-archive :zip\n  [path]\n  (clojure.java.shell/sh\n    \&quot;sh\&quot; \&quot;-c\&quot;\n    (str \&quot; cd \&quot; (.getParent (File. (:path path))) \&quot;/;\&quot;\n         \&quot; zip \&quot; (last (s/split (:path path) #\&quot;/\&quot;)) \&quot;.zip\&quot;\n         \&quot; -r \&quot; (last (s/split (:path path) #\&quot;/\&quot;)))))&quot; &quot;(defmethod cetl-file-archive :gzip\n  [path]\n  (clojure.java.shell/sh\n    \&quot;sh\&quot; \&quot;-c\&quot;\n    (str \&quot; cd \&quot; (.getParent (File. (:path path))) \&quot;/;\&quot;\n         \&quot; tar -cvzf \&quot; (last (s/split (:path path) #\&quot;/\&quot;)) \&quot;.tar.gz\&quot;\n         \&quot; \&quot; (last (s/split (:path path) #\&quot;/\&quot;)))))&quot; &quot;(def list-files (cetl-file-list {:path \&quot;/Users/gregadebesin/Development/Cetl\&quot;\n                                 :list :dirs}))&quot; &quot;list-files&quot; &quot;(map (fn [x] (cetl-file-archive {:path x :archive :zip})) list-files)&quot; &quot;2&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s])\n  (:import (org.apache.commons.io FileUtils)\n           (java.io File FileUtils)))&quot; &quot;(cetl-file-encode {})&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s])\n  (:import (org.apache.commons.io FileUtils)\n           (java.io File)))&quot; &quot;(use '[clojure.java.shell :only [sh]])&quot; &quot;(defmulti cetl-file-encode (fn [x] (:encode x)))&quot; &quot;(defmethod cetl-file-encode :ISO-8859-15\n  [x]\n  (FileUtils/write\n    (File. (:path x))\n    (FileUtils/readFileToString\n      (File. (:path x)) (name (:encode x))) \&quot;UTF-8\&quot;))&quot; &quot;(defmethod cetl-file-encode :UTF-8\n  [x]\n  (FileUtils/write\n     (File. (:path x))\n     (FileUtils/readFileToString\n       (File. (:path x)) (name (:encode x))) \&quot;ISO-8859-15\&quot;))&quot; &quot;(defmethod cetl-file-encode :UTF-8\n  [x]\n  (FileUtils/write\n     (File. (:path x))\n     (FileUtils/readFileToString\n       (File. (:path x)) (name (:encode x))) \&quot;UTF-8\&quot;))&quot; &quot;(defmethod cetl-file-encode :ISO-8859-15\n  [x]\n  (FileUtils/write\n    (File. (:path x))\n    (FileUtils/readFileToString\n      (File. (:path x)) (name (:encode x)))  \&quot;ISO-8859-15\&quot;))&quot; &quot;(cetl-file-encode {:path \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file.txt\&quot;\n                   :encode :ISO-8859-15})&quot; &quot;(cetl-file-encode {:path \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file.txt\&quot;\n                   :encode :UTF-8})&quot;], :remote []}}</component>
</project>

