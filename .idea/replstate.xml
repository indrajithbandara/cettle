<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1442786510864">{:repl-history {:ide [], :local [&quot;(defn baz [x]\n  x)&quot; &quot;(with-new-thread\n  (+ 2 2))&quot; &quot;(with-new-thread\n  (println 2))&quot; &quot;(with-new-thread\n  (println 2)\n  (println 3))&quot; &quot;(defmacro process-&gt;\n  [&amp; body]\n  (let [c (chan)]\n    `(thread (&gt;!! c (fn [] ~@body)))\n    `(thread (&lt;!! c))))&quot; &quot;(process-&gt; )&quot; &quot;(defmacro process-&gt;\n  [&amp; body]\n  (let [c (chan)]\n    `(thread (&gt;!! c (fn [] ~@body)))))&quot; &quot;(process-&gt;\n  (fm/cetl-file-archive\n   \&quot;/Users/gregadebesin/Development/Cetl/archive\&quot;\n   :archive-format :gzip))&quot; &quot;(defmacro process\n  [&amp; body]\n  (let [c (chan)]\n    `(thread (&gt;!! c (fn [] ~@body)))))&quot; &quot;(process\n  (fm/cetl-file-archive\n   \&quot;/Users/gregadebesin/Development/Cetl/archive\&quot;\n   :archive-format :gzip))&quot; &quot;(defmacro process-&gt;\n  [&amp; body]\n  `(.start (Thread. (fn [] ~@body))))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [cetl.utils.component-utils :as c-utils])\n  (:import (java.io File FileFilter)))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s])\n  (:import [org.apache.commons.io FileUtils]))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s])\n  (:import (org.apache.commons.io FileUtils)))&quot; &quot;(defn cetl-change-file-encoding\n  []\n  ())&quot; &quot;(defn cetl-change-file-encoding\n  [in-path out-path]\n  (let [file (File. in-path)\n        file-content (FileUtils/readFileToString file \&quot;ISO8859_1\&quot;)]\n    (FileUtils/write file file-content \&quot;UTF-8\&quot;)))&quot; &quot;(cetl-change-file-encoding \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file.txt\&quot; \&quot; /Users/gregadebesin/IdeaProjects/cetl/resources/test-file.txt/test-file1.txt\&quot;)&quot; &quot;(defn cetl-change-file-encoding\n  [in-path out-path]\n  (let [file-in (File. in-path)\n        file-out (File. out-path)\n        file-content (FileUtils/readFileToString file-in \&quot;ISO8859_1\&quot;)]\n    (FileUtils/write file-out file-content \&quot;UTF-8\&quot;)))&quot; &quot;(defn cetl-change-file-encoding\n  [in-path out-path]\n  (let [file-in (File. in-path)\n        file-out (File. out-path)\n        file-content (FileUtils/readFileToString file-in \&quot;UTF-8\&quot;)]\n    (FileUtils/write file-out file-content  \&quot;ISO8859_1\&quot;)))&quot; &quot;(defn cetl-change-file-encoding\n  [in-path out-path]\n  (let [file-in (File. in-path)\n        file-out (File. out-path)\n        file-content (FileUtils/readFileToString file-in \&quot;UTF-8\&quot;)]\n    (FileUtils/write file-out file-content  \&quot;ISO8859-1\&quot;)))&quot; &quot;(cetl-change-file-encoding \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file.txt\&quot; \&quot; /Users/gregadebesin/IdeaProjects/cetl/resources/test-file1.txt\&quot;)&quot; &quot;(cetl-change-file-encoding \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file.txt\&quot; \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file1.txt\&quot;)&quot; &quot;(cetl-change-file-encoding \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file.txt\&quot;\&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file1.txt\&quot;)&quot; &quot;(defn cetl-change-file-encoding\n  [in-path out-path &amp; {:keys [UTF-8 ISO-8859-15]}]\n  (let [file-in (File. in-path)\n        file-out (File. out-path)\n        file-content (FileUtils/readFileToString file-in \&quot;ISO8859_1\&quot;)]\n    (FileUtils/write file-out file-content \&quot;UTF-8\&quot;)))&quot; &quot;(defn cetl-change-file-encoding\n  [in-path out-path &amp; {:keys [UTF-8 ISO-8859-15]}]\n  (letfn [(encoding \n            [path encode-type]\n            (FileUtils/readFileToString (File. p) encode-type))]))&quot; &quot;(defn cetl-change-file-encoding\n  [in-path out-path &amp; {:keys [UTF-8 ISO-8859-15]}]\n  (letfn [(encoding \n            [in out x xs]\n            (FileUtils/write out (FileUtils/readFileToString (File. in) x) xs))]))&quot; &quot;(defn cetl-change-file-encoding\n  [in-path out-path &amp; {:keys [from-encode to-encode]}]\n  (letfn [(encoding \n            [in out x xs]\n            (FileUtils/write out (FileUtils/readFileToString (File. in) x) xs))]\n    (cond (and (= from-encode :UTF-8) (= to-encode :ISO-8859-15))\n          (encoding in-path out-path \&quot;UTF-8\&quot; \&quot;ISO-8859-15\&quot;)\n          (and (= from-encode :ISO-8859-15) (= to-encode :UTF-8))\n          (encoding in-path out-path \&quot;ISO-8859-15\&quot; \&quot;UTF-8\&quot;))))&quot; &quot;(defn cetl-change-file-encoding\n  [in-path out-path &amp; {:keys [UTF-8 ISO-8859-15]}]\n  (let [file-in (File. in-path)\n        file-out (File. out-path)\n        file-content (FileUtils/readFileToString file-in \&quot;UTF-8\&quot;)]\n    (FileUtils/write file-out file-content \&quot;ISO-8859-15\&quot;)))&quot; &quot;(cetl-change-file-encoding \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file.txt\&quot;\n                           \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file1.txt\&quot;)&quot; &quot;(defn cetl-change-file-encoding\n  [in-path out-path &amp; {:keys [from-encode to-encode]}]\n  (letfn [(encoding \n            [in out x xs]\n            (FileUtils/write (File. out) (FileUtils/readFileToString (File. in) x) xs))]\n    (cond (and (= from-encode :UTF-8) (= to-encode :ISO-8859-15))\n          (encoding in-path out-path \&quot;UTF-8\&quot; \&quot;ISO-8859-15\&quot;)\n          (and (= from-encode :ISO-8859-15) (= to-encode :UTF-8))\n          (encoding in-path out-path \&quot;ISO-8859-15\&quot; \&quot;UTF-8\&quot;))))&quot; &quot;(cetl-change-file-encoding \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file.txt\&quot;\n                           \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file1.txt\&quot;\n                           :UTF-8 :ISO-8859-15)&quot; &quot;(cetl-change-file-encoding \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file.txt\&quot;\n                           \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/test-file1.txt\&quot;\n                           :from-encode :UTF-8 \n                           :to-encode :ISO-8859-15)&quot; &quot;2&quot; &quot;(map inc [1 2])&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s])\n  (:import (org.apache.commons.io FileUtils)\n           (java.io File)))&quot; &quot;(use '[clojure.java.shell :only [sh]])&quot; &quot;(map inc (range 1 20))&quot; &quot;(ns cetl.file.input\n  (:import (au.com.bytecode.opencsv CSVReader)))&quot; &quot;(use 'incanter.io)&quot; &quot;(defn cetl-input-file-delimited\n  [filename &amp; {:keys [delim keyword-headers quote skip header compress-delim empty-field-value]\n               :or {delim \\, quote \\\&quot; skip 0 header false keyword-headers true}}]\n  (letfn [(parse-string [value &amp; [empty-value]]\n                        (if (= value \&quot;\&quot;)\n                          empty-value\n                          (if (re-matches #\&quot;\\d+\&quot; value)\n                            (try (Long/parseLong value)\n                                 (catch NumberFormatException _ value))\n                            (try (Double/parseDouble value)\n                                 (catch NumberFormatException _ value)))))\n          (pad-vector [v new-len value]\n                      (into v (repeat (- new-len (count v)) value)))]\n    (let [compress-delim? (or compress-delim (= delim \\space))\n          compress-delim-fn (if compress-delim?\n                              (fn [line] (filter #(not= % \&quot;\&quot;) line))\n                              identity)\n          remove-empty-fn #(when (some (fn [field] (not= field \&quot;\&quot;)) %) %)\n          parse-data-fn (fn [line]\n                          (vec (map #(parse-string % empty-field-value) line)))\n          [parsed-data column-count]\n          (with-open [reader ^CSVReader (CSVReader. (clojure.java.io/reader filename) delim quote skip)]\n            (loop [lines [] max-column 0]\n              (if-let [line (.readNext reader)]\n                (let [new-line (-&gt; line\n                                   compress-delim-fn\n                                   remove-empty-fn\n                                   parse-data-fn)]\n                  (recur (if-not (empty? new-line) (conj lines new-line) lines)\n                         (max max-column (count new-line))))\n                [lines max-column])))\n          header-row (when header (first parsed-data))\n          dataset-body (if header (rest parsed-data) parsed-data)\n          column-names-strs\n          (map (fn [hr-entry idx]\n                 (or hr-entry (str \&quot;col\&quot; idx)))\n               (concat header-row (repeat nil))\n               (range column-count))\n          column-names (map (if keyword-headers keyword identity) column-names-strs)\n          padded-body\n          (if (not (nil? empty-field-value))\n            (map #(pad-vector % column-count empty-field-value)\n                 dataset-body)\n            dataset-body)]\n      (incanter.core/dataset column-names padded-body))))&quot; &quot;(cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/sample-data.csv\&quot;)&quot; &quot;()&quot; &quot;(get (cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/sample-data.csv\&quot;) :col0)&quot; &quot;($join\n  (cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/sample-data.csv\&quot;))&quot; &quot;(use '(incanter core io charts)\n     '[clojure.set :only (union)])&quot; &quot;($join [:col0 :col1]\n  (cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/sample-data.csv\&quot;)\n  (cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/sample-data.csv\&quot; :delim \&quot;x\&quot;))&quot; &quot;(cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/sample-data.csv\&quot; :delim \&quot;x\&quot;)&quot; &quot;($join [:col0 :col1]\n  (cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/sample-data.csv\&quot;)\n  (cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.txt\&quot; :delim \&quot;x\&quot;))&quot; &quot;($join [:col0 :col1]\n  (cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/sample-data.csv\&quot;)\n  (cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.csv\&quot; :delim \&quot;x\&quot;))&quot; &quot;(cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.csv\&quot; :delim \&quot;x\&quot;)&quot; &quot;(cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.csv\&quot;)&quot; &quot;(cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.csv\&quot; :header false)&quot; &quot;(cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.csv\&quot; :header false :delim \\x)&quot; &quot;($join [:col0 :col1]\n  (cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/sample-data.csv\&quot;)\n  (cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.csv\&quot; :delim \\x))&quot; &quot;(def d3 (dataset [:id :c1 :c2] [[:a 1 2] [:b 3 4] [:c 5 6]]))&quot; &quot;(dataset [:id :c1 :c2] [[:a 1 2] [:b 3 4] [:c 5 6]])&quot; &quot;(cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.csv\&quot; :header false :delim \&quot;x\&quot;)&quot; &quot;(defn data-&gt;maps \&quot;Turns a vector of vectors into a seq of maps\&quot;\n  [keys data]\n  (map #(zipmap keys %) data))&quot; &quot;(defn data-merge\n  \&quot;Merge two data sets on the given key\&quot;\n  [merge-key a b]\n  (let [indexed-b (zipmap (map merge-key b) b)]\n    (map #(into % (indexed-b (merge-key %))) (filter #(contains? indexed-b (merge-key %)) a))))&quot; &quot;(dataset [:col0] \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.csv\&quot; :delim \\x)&quot; &quot;(dataset [:col0] (cetl-input-file-delimited))&quot; &quot;(dataset [:col0] (cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.csv\&quot; :delim \\x))&quot; &quot;(cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.csv\&quot; :delim \\x)&quot; &quot;(dataset [:col0 :col1] (cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.csv\&quot; :delim \\x))&quot; &quot;(dataset [] (cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.csv\&quot; :delim \\x))&quot; &quot;(dataset (cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.csv\&quot; :delim \\x))&quot; &quot;(dataset  (cetl-input-file-delimited \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.csv\&quot; :delim \\x))&quot; &quot;(def ^:dynamic **datasets**\n  {\n   :iris {:filename \&quot;data/iris.dat\&quot;\n          :delim \\space\n          :header true}})&quot; &quot;(def ^:dynamic **datasets**\n  {\n   :iris {:filename \&quot;/Users/gregadebesin/IdeaProjects/cetl/resources/rest2.csv\&quot;\n          :delim \\x\n          :header true}})&quot; &quot;(defn get-dataset\n  \&quot;\n  Returns the sample dataset associated with the given key. Most datasets\n  are from R's sample data sets, as are the descriptions below.\n  Options:\n    :incanter-home -- if the incanter.home property is not set when the JVM is\n                      started (using -Dincanter.home) or there is no INCANTER_HOME\n                      environment variable set, use the :incanter-home options to\n                      provide the parent directory of the sample data directory.\n    :from-repo (default false) -- If true, retrieves the dataset from the online repository\n                       instead of locally, it will do this by default if incanter-home is not set.\n  Datasets:\n    :iris -- the Fisher's or Anderson's Iris data set gives the\n             measurements in centimeters of the variables sepal\n             length and width and petal length and width,\n             respectively, for 50 flowers from each of 3 species\n             of iris.\n    :cars -- The data give the speed of cars and the distances taken\n              to stop. Note that the data were recorded in the 1920s.\n    :survey -- survey data used in Scott Lynch's 'Introduction to Applied Bayesian Statistics\n               and Estimation for Social Scientists'\n    :us-arrests -- This data set contains statistics, in arrests per 100,000\n                   residents for assault, murder, and rape in each of the 50 US\n                   states in 1973. Also given is the percent of the population living\n                   in urban areas.\n    :flow-meter -- flow meter data used in Bland Altman Lancet paper.\n    :co2 -- has 84 rows and 5 columns of data from an experiment on the cold tolerance\n            of the grass species _Echinochloa crus-galli_.\n    :chick-weight -- has 578 rows and 4 columns from an experiment on the effect of diet\n                     on early growth of chicks.\n    :plant-growth -- Results from an experiment to compare yields (as measured by dried\n                     weight of plants) obtained under a control and two different\n                     treatment conditions.\n    :pontius -- These data are from a NIST study involving calibration of load cells.\n                The response variable (y) is the deflection and the predictor variable\n                (x) is load.\n                See http://www.itl.nist.gov/div898/strd/lls/data/Pontius.shtml\n    :filip -- NIST data set for linear regression certification,\n              see http://www.itl.nist.gov/div898/strd/lls/data/Filip.shtml\n    :longely -- This classic dataset of labor statistics was one of the first used to\n                test the accuracy of least squares computations. The response variable\n                (y) is the Total Derived Employment and the predictor variables are GNP\n                Implicit Price Deflator with Year 1954 = 100 (x1), Gross National Product\n                (x2), Unemployment (x3), Size of Armed Forces (x4), Non-Institutional\n                Population Age 14 &amp; Over (x5), and Year (x6).\n                See http://www.itl.nist.gov/div898/strd/lls/data/Longley.shtml\n    :Chwirut -- These data are the result of a NIST study involving ultrasonic calibration.\n                The response variable is ultrasonic response, and the predictor variable is\n                metal distance.\n                See http://www.itl.nist.gov/div898/strd/nls/data/LINKS/DATA/Chwirut1.dat\n    :thurstone -- test data for non-linear least squares.\n    :austres -- Quarterly Time Series of the Number of Australian Residents\n    :hair-eye-color -- Hair and eye color of sample of students\n    :airline-passengers -- Monthly Airline Passenger Numbers 1949-1960\n    :math-prog -- Pass/fail results for a high school mathematics assessment test\n                  and a freshmen college programming course.\n    :iran-election -- Vote counts for 30 provinces from the 2009 Iranian election.\n   Examples:\n     (def data (get-dataset :cars))\n     (def data2 (get-dataset :cars :incanter.home \\\&quot;/usr/local/packages/incanter\\\&quot;))\n  \&quot;\n  ([dataset-key &amp; {:keys [incanter-home from-repo]\n                   :or {incanter-home (or (System/getProperty \&quot;incanter.home\&quot;)\n                                          (System/getenv \&quot;INCANTER_HOME\&quot;))\n                        from-repo false}}]\n   (when-let [ds (**datasets** dataset-key)]\n     (let [filename (if (and (not from-repo) (not (nil? incanter-home)))\n                      (str incanter-home \&quot;/\&quot; (ds :filename))\n                      (str **datasets-base-url** (ds :filename)))\n           delim (ds :delim)\n           header (ds :header)]\n       (read-dataset filename :delim delim :header header)))))&quot; &quot;(defn get-dataset\n  \&quot;\n  Returns the sample dataset associated with the given key. Most datasets\n  are from R's sample data sets, as are the descriptions below.\n  Options:\n    :incanter-home -- if the incanter.home property is not set when the JVM is\n                      started (using -Dincanter.home) or there is no INCANTER_HOME\n                      environment variable set, use the :incanter-home options to\n                      provide the parent directory of the sample data directory.\n    :from-repo (default false) -- If true, retrieves the dataset from the online repository\n                       instead of locally, it will do this by default if incanter-home is not set.\n  Datasets:\n    :iris -- the Fisher's or Anderson's Iris data set gives the\n             measurements in centimeters of the variables sepal\n             length and width and petal length and width,\n             respectively, for 50 flowers from each of 3 species\n             of iris.\n    :cars -- The data give the speed of cars and the distances taken\n              to stop. Note that the data were recorded in the 1920s.\n    :survey -- survey data used in Scott Lynch's 'Introduction to Applied Bayesian Statistics\n               and Estimation for Social Scientists'\n    :us-arrests -- This data set contains statistics, in arrests per 100,000\n                   residents for assault, murder, and rape in each of the 50 US\n                   states in 1973. Also given is the percent of the population living\n                   in urban areas.\n    :flow-meter -- flow meter data used in Bland Altman Lancet paper.\n    :co2 -- has 84 rows and 5 columns of data from an experiment on the cold tolerance\n            of the grass species _Echinochloa crus-galli_.\n    :chick-weight -- has 578 rows and 4 columns from an experiment on the effect of diet\n                     on early growth of chicks.\n    :plant-growth -- Results from an experiment to compare yields (as measured by dried\n                     weight of plants) obtained under a control and two different\n                     treatment conditions.\n    :pontius -- These data are from a NIST study involving calibration of load cells.\n                The response variable (y) is the deflection and the predictor variable\n                (x) is load.\n                See http://www.itl.nist.gov/div898/strd/lls/data/Pontius.shtml\n    :filip -- NIST data set for linear regression certification,\n              see http://www.itl.nist.gov/div898/strd/lls/data/Filip.shtml\n    :longely -- This classic dataset of labor statistics was one of the first used to\n                test the accuracy of least squares computations. The response variable\n                (y) is the Total Derived Employment and the predictor variables are GNP\n                Implicit Price Deflator with Year 1954 = 100 (x1), Gross National Product\n                (x2), Unemployment (x3), Size of Armed Forces (x4), Non-Institutional\n                Population Age 14 &amp; Over (x5), and Year (x6).\n                See http://www.itl.nist.gov/div898/strd/lls/data/Longley.shtml\n    :Chwirut -- These data are the result of a NIST study involving ultrasonic calibration.\n                The response variable is ultrasonic response, and the predictor variable is\n                metal distance.\n                See http://www.itl.nist.gov/div898/strd/nls/data/LINKS/DATA/Chwirut1.dat\n    :thurstone -- test data for non-linear least squares.\n    :austres -- Quarterly Time Series of the Number of Australian Residents\n    :hair-eye-color -- Hair and eye color of sample of students\n    :airline-passengers -- Monthly Airline Passenger Numbers 1949-1960\n    :math-prog -- Pass/fail results for a high school mathematics assessment test\n                  and a freshmen college programming course.\n    :iran-election -- Vote counts for 30 provinces from the 2009 Iranian election.\n   Examples:\n     (def data (get-dataset :cars))\n     (def data2 (get-dataset :cars :incanter.home \\\&quot;/usr/local/packages/incanter\\\&quot;))\n  \&quot;\n  ([dataset-key &amp; {:keys [incanter-home from-repo]\n                   :or {incanter-home (or (System/getProperty \&quot;incanter.home\&quot;)\n                                          (System/getenv \&quot;INCANTER_HOME\&quot;))\n                        from-repo false}}]\n   (when-let [ds (**datasets** dataset-key)]\n     (let [filename  (str incanter-home \&quot;/\&quot; (ds :filename))\n           delim (ds :delim)\n           header (ds :header)]\n       (read-dataset filename :delim delim :header header)))))&quot; &quot;(defn get-dataset\n  ([dataset-key &amp; {:keys [incanter-home from-repo]\n                   :or {incanter-home (or (System/getProperty \&quot;incanter.home\&quot;)\n                                          (System/getenv \&quot;INCANTER_HOME\&quot;))\n                        from-repo false}}]\n   (when-let [ds (**datasets** dataset-key)]\n     (let [filename  (str incanter-home \&quot;/\&quot; (ds :filename))\n           delim (ds :delim)\n           header (ds :header)]\n       (cetl-input-file-delimited filename :delim delim :header header)))))&quot; &quot;(get-dataset :iris)&quot; &quot;\n(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs? include-hidden-files?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d \&quot;))\n              :out) #\&quot;\\n\&quot;))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false)\n           (= include-hidden-files? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false)\n           (= include-hidden-files? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false)\n           (= include-hidden-files? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true)\n           (= include-hidden-files? false))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;\n(defn cetl-file-list\n  ([path &amp; {:keys\n                [dirs-only? files-only? dirs-&amp;-files?\n                 include-sub-dirs? include-hidden-files?]\n            :or {include-sub-dirs? false}}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (and (= dirs-&amp;-files? true)\n            (= include-sub-dirs? false)\n            (= include-hidden-files? false))\n       (dirs-&amp;-files path)\n       (and (= files-only? true)\n            (= include-sub-dirs? false)\n            (= include-hidden-files? false))\n       (files-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? false)\n            (= include-hidden-files? false))\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true)\n            (= include-hidden-files? false))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;\n(defn cetl-file-list\n  ([path &amp; {:keys\n                [dirs-only? files-only? dirs-&amp;-files?\n                 include-sub-dirs? include-hidden-files?]\n            :or {include-sub-dirs? false}}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (and (= dirs-&amp;-files? true)\n            (= include-hidden-files? false))\n       (dirs-&amp;-files path)\n       (and (= files-only? true)\n            (= include-hidden-files? false))\n       (files-only path)\n       (and (= dirs-only? true)\n            (= include-hidden-files? false))\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true)\n            (= include-hidden-files? false))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development/Cetl/TestFiles\&quot; :dirs-&amp;-files? true :include-hidden-files? false)&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development/Cetl/TestFiles\&quot; :dirs-&amp;-files? true :include-sub_dirs? false :include-hidden-files? false)&quot; &quot;(defn cetl-file-list\n  ([path &amp; {:keys\n            [dirs-only? files-only? dirs-&amp;-files?\n             include-sub-dirs?]}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (and (= dirs-&amp;-files? true)\n            (= include-sub-dirs? false))\n       (dirs-&amp;-files path)\n       (and (= files-only? true)\n            (= include-sub-dirs? false))\n       (files-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? false))\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;(defn cetl-file-list\n  ([path &amp; {:keys\n            [dirs-only? files-only? dirs-&amp;-files?\n             include-sub-dirs?]\n            :or {include-sub-dirs? false}}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (and (= dirs-&amp;-files? true)\n            (= include-sub-dirs? false))\n       (dirs-&amp;-files path)\n       (and (= files-only? true)\n            (= include-sub-dirs? false))\n       (files-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? false))\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;(defn cetl-file-list\n  ([path &amp; {:keys\n            [dirs-only? files-only? dirs-&amp;-files?\n             include-sub-dirs?]\n            :or {include-sub-dirs? false}}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (and (= dirs-&amp;-files? true))\n       (dirs-&amp;-files path)\n       (and (= files-only? true))\n       (files-only path)\n       (and (= dirs-only? true))\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development/Cetl/TestFiles\&quot; :dirs-&amp;-files? true)&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development/Cetl/TestFiles\&quot; :dirs-only? true :include-sub-dirs? true)&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development/Cetl\&quot; :dirs-only? true :include-sub-dirs? true)&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development\&quot; :dirs-only? true)&quot; &quot;(defn cetl-file-list\n  ([path &amp; {:keys\n            [dirs-only? files-only? dirs-&amp;-files?\n             include-sub-dirs?]\n            :or {include-sub-dirs? false}}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (= dirs-&amp;-files? true)\n       (dirs-&amp;-files path)\n       (= files-only? true)\n       (files-only path)\n       (= dirs-only? true)\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;(defn cetl-file-list\n  ([path &amp; {:keys\n            [dirs-only? files-only? dirs-&amp;-files?\n             include-sub-dirs?]\n        :or {include-sub-dirs? false}}]\n   (letfn\n     [(dirs-&amp;-files\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (files-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (dirs-only\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n               :out) #\&quot;\\n\&quot;))\n      (include-dirs-only-sub-dirs\n        [p]\n        (clojure.string/split\n          (get (clojure.java.shell/sh\n                 \&quot;sh\&quot; \&quot;-c\&quot;\n                 (str \&quot; cd \&quot; p \&quot;;\&quot;\n                      \&quot; find `pwd` -type d \&quot;))\n               :out) #\&quot;\\n\&quot;))]\n     (cond\n       (= dirs-&amp;-files? true)\n       (dirs-&amp;-files path)\n       (= files-only? true)\n       (files-only path)\n       (= dirs-only? true)\n       (dirs-only path)\n       (and (= dirs-only? true)\n            (= include-sub-dirs? true))\n       (include-dirs-only-sub-dirs path)))))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot; \n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d \&quot;))\n              :out) #\&quot;\\n\&quot;))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development\&quot; :dirs-only? true :include-sub-dirs? true)&quot; &quot;(get (clojure.java.shell/sh\n       \&quot;sh\&quot; \&quot;-c\&quot;\n       (str \&quot; cd \&quot; p \&quot;;\&quot;\n            \&quot; find `pwd` -type d \&quot;))\n     :out) #\&quot;\\n\&quot;)&quot; &quot;(get (clojure.java.shell/sh\n       \&quot;sh\&quot; \&quot;-c\&quot;\n       (str \&quot; cd \&quot; p \&quot;;\&quot;\n            \&quot; find `pwd` -type d \&quot;))\n     :out)&quot; &quot;(get (clojure.java.shell/sh\n       \&quot;sh\&quot; \&quot;-c\&quot;\n       (str \&quot; cd \&quot;  \&quot;/Users/gregadebesin/Development\&quot; \&quot;;\&quot;\n            \&quot; find `pwd` -type d \&quot;))\n     :out)&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d \&quot;))\n              :out) #\&quot;\\n\&quot;))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development\&quot; \n                :dirs-only? true \n                :include-sub-dirs? false)&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d \&quot;))\n              :out) #\&quot;\\n\&quot;))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path)\n      :else nil)))&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d \&quot;))\n              :out) #\&quot;\\n\&quot;))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false))\n      (files-only path)\n     \n      (and (= dirs-only? true)\n           (= include-sub-dirs? true))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development\&quot; \n                :dirs-only? true \n                :include-sub-dirs? true)&quot; &quot;(defn cetl-file-list\n  [path &amp; {:keys\n           [dirs-only? files-only? dirs-&amp;-files?\n            include-sub-dirs? include-hidden-files?]}]\n  (letfn\n    [(dirs-&amp;-files\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (files-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type f -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (dirs-only\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d -maxdepth 1 \&quot;))\n              :out) #\&quot;\\n\&quot;))\n     (include-dirs-only-sub-dirs\n       [p]\n       (clojure.string/split\n         (get (clojure.java.shell/sh\n                \&quot;sh\&quot; \&quot;-c\&quot;\n                (str \&quot; cd \&quot; p \&quot;;\&quot;\n                     \&quot; find `pwd` -type d \&quot;))\n              :out) #\&quot;\\n\&quot;))]\n    (cond\n      (and (= dirs-&amp;-files? true)\n           (= include-sub-dirs? false)\n           (= include-hidden-files? false))\n      (dirs-&amp;-files path)\n      (and (= files-only? true)\n           (= include-sub-dirs? false)\n           (= include-hidden-files? false))\n      (files-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? false)\n           (= include-hidden-files? false))\n      (dirs-only path)\n      (and (= dirs-only? true)\n           (= include-sub-dirs? true)\n           (= include-hidden-files? false))\n      (include-dirs-only-sub-dirs path))))&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development\&quot; \n                :dirs-only? true \n                :include-sub-dirs? true\n                :include-hidden-files? false)&quot; &quot;(cetl-file-list \&quot;/Users/gregadebesin/Development/\&quot; \n                :dirs-only? true \n                :include-sub-dirs? true\n                :include-hidden-files? false)&quot;], :remote []}}</component>
</project>

