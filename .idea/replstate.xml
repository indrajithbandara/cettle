<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1449534497495">{:repl-history {:ide [], :local [&quot;(macroexpand-1 )&quot; &quot;(defmacro if-filter-pred\n  [test &amp; body]\n  (list 'if test ))&quot; &quot;(if true (filter even? '()))&quot; &quot;(defmacro if-filter-pred\n  [test &amp; body]\n  (list 'if test (list 'filter 'even body)))&quot; &quot;(defmacro if-filter-pred\n  [test &amp; body]\n  (list 'if test (cons 'filter 'even? body)))&quot; &quot;(macroexpand-1 '(if-filter-pred 22))&quot; &quot;(if-filter-pred true [1 2 3 4 5])&quot; &quot;(defprotocol file-management-component\n  (zip-file [x] \&quot;Zip's a file\&quot;)\n  (gzip-file [x] \&quot;Gzip's a file\&quot;)\n  (list-dirs-files [x] \&quot;List dirs files\&quot;))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n  (list-dirs-files\n    [this])\n  )&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n  \n  (list-dirs-files\n    [this]\n    (if (dir-exists? (:path x))\n      (let [path (:path x)]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot; is not a directory\&quot;))))))&quot; &quot;(list-dirs-files (-&gt;file-management) {})&quot; &quot;(list-dirs-files  {} (-&gt;file-management))&quot; &quot;(defprotocol file-management-component\n  (zip-file [x] \&quot;Zip's a file\&quot;)\n  (gzip-file [x] \&quot;Gzip's a file\&quot;)\n  (list-dirs-files [x] \&quot;List the directories and files of a given path\&quot;))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (:path x))\n      (let [path (:path x)]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot; is not a directory\&quot;))))))&quot; &quot;(list-dirs-files (-&gt;file-management))&quot; &quot;(list-dirs-files (-&gt;file-management {}))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (:path x))\n      (let [path (:path x)]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot; is not a directory\&quot;))))))&quot; &quot;(list-dirs-files (-&gt;file-management {:path \&quot;/Users/gra11/Development\&quot;}))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (:path x))\n      (let [path (:path x)\n            file (:file x)]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; path \&quot;/\&quot; file \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;))))))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [path (:path x)\n            file (:file x)]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; path \&quot;/\&quot; file \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;))))))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;))))))&quot; &quot;(list-dirs-files (-&gt;file-management {:path \&quot;/Users/gra11\&quot;\n                                     :file \&quot;Developmen\&quot;}))&quot; &quot;(list-dirs-files (-&gt;file-management {:path \&quot;/Users/gra1\&quot;\n                                     :file \&quot;Development\&quot;}))&quot; &quot;(list-dirs-files (-&gt;file-management {:path \&quot;/Users/gra11\&quot;\n                                     :file \&quot;Development\&quot;}))&quot; &quot;(defprotocol file-management-component\n  (zip-file [x] \&quot;Zip's a file\&quot;)\n  (gzip-file [x] \&quot;Gzip's a file\&quot;)\n  (list-dirs-files [x] \&quot;List the directories and files of a given path\&quot;)\n  (list-files [x] \&quot;List the files of a given path\&quot;))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n  (list-files\n    [this]\n    (if (dir-exists? (:path x))\n      (let [move-to-dir \&quot; cd \&quot;\n            command  \&quot; find `pwd` -type f -maxdepth 1 \&quot;\n            next-command \&quot;;\&quot;]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str move-to-dir (:path x)\n                                next-command\n                                command)) :out) #\&quot;\\n\&quot;)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot; is not a directory\&quot;))))))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n  (list-files\n    [this]\n    (if (dir-exists? (:path x))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot; is not a directory\&quot;))))))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot; is not a directory\&quot;))))))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;))))))&quot; &quot;(list-files (-&gt;file-management {:path \&quot;/Users/gra11\&quot; \n                                :file \&quot;Developmen\&quot;}))&quot; &quot;(list-files (-&gt;file-management {:path \&quot;/Users/gra11\&quot; \n                                :file \&quot;Development\&quot;}))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;))))))&quot; &quot;(list-files (-&gt;file-management {:path \&quot;/Users\&quot; \n                                :file \&quot;gra11\&quot;}))&quot; &quot;(defprotocol file-management-component\n  (zip-file [x] \&quot;Zip's a file\&quot;)\n  (gzip-file [x] \&quot;Gzip's a file\&quot;)\n  (list-dirs-files [x] \&quot;List the directories and files of a given path\&quot;)\n  (list-files [x] \&quot;List the files of a given path\&quot;)\n  (list-dirs [x] \&quot;List the directories of a given path\&quot;))&quot; &quot;(defrecord file-management {:arglists '([map])}\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;))))))&quot; &quot;(defprotocol file-management-component\n  (zip-file [x] \&quot;Zip's a file\&quot;)\n  (gzip-file [x] \&quot;Gzip's a file\&quot;)\n  (list-dirs-files {:arglists '([map])} [x] \&quot;List the directories and files of a given path\&quot;)\n  (list-files [x] \&quot;List the files of a given path\&quot;)\n  (list-dirs [x] \&quot;List the directories of a given path\&quot;))&quot; &quot;(defprotocol file-management-component\n  (zip-file [x] \&quot;Zip's a file\&quot;)\n  (gzip-file [x] \&quot;Gzip's a file\&quot;)\n  (list-dirs-files  [x] \&quot;List the directories and files of a given path\&quot;)\n  (list-files [x] \&quot;List the files of a given path\&quot;)\n  (list-dirs [x] \&quot;List the directories of a given path\&quot;))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n  (list-dirs\n    [this]\n    (if (dir-exists? (:path x))\n      (let [move-to-dir \&quot; cd \&quot;\n            command  \&quot; find `pwd` -type d -maxdepth 1 \&quot;\n            next-command \&quot;;\&quot;]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str move-to-dir (:path x)\n                                next-command\n                                command)) :out) #\&quot;\\n\&quot;)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot; is not a directory\&quot;))))))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n  \n  (list-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot; is not a directory\&quot;))))))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)))\n      (throw\n        (IllegalArgumentException.\n          (str (str (:path x) \&quot;/\&quot; (:file x)) \&quot; is not a directory\&quot;))))))&quot; &quot;(list-dirs (-&gt;file-management {:path \&quot;/Users/gra11\&quot; \n                                :file \&quot;Development\&quot;}))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d -not -path '*/\\\\.*' -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)))\n      (throw\n        (IllegalArgumentException.\n          (str (str (:path x) \&quot;/\&quot; (:file x)) \&quot; is not a directory\&quot;))))))&quot; &quot;(list-dirs (-&gt;file-management {:path \&quot;/Users\&quot; \n                                :file \&quot;gra11\&quot;}))&quot; &quot;(defprotocol file-management-component\n  (zip-file [x] \&quot;Zip's a file\&quot;)\n  (gzip-file [x] \&quot;Gzip's a file\&quot;)\n  (list-dirs-files  [x] \&quot;List the directories and files of a given path\&quot;)\n  (list-files [x] \&quot;List the files of a given path\&quot;)\n  (list-dirs [x] \&quot;List the directories of a given path\&quot;)\n  (list-dirs-sub-dirs [x] \&quot;List the dirs, inc sub-dirs of a given path\&quot;))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d -not -path '*/\\\\.*' -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)))\n      (throw\n        (IllegalArgumentException.\n          (str (str (:path x) \&quot;/\&quot; (:file x)) \&quot; is not a directory\&quot;)))))\n  (list-dirs-sub-dirs\n    [this]\n    (if (dir-exists? (:path x))\n      (let [move-to-dir \&quot; cd \&quot;\n            command  \&quot; find `pwd` -type d \&quot;\n            next-command \&quot;;\&quot;]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str move-to-dir (:path x)\n                                next-command\n                                command)) :out) #\&quot;\\n\&quot;)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot; is not a directory\&quot;))))))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d -not -path '*/\\\\.*' -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)))\n      (throw\n        (IllegalArgumentException.\n          (str (str (:path x) \&quot;/\&quot; (:file x)) \&quot; is not a directory\&quot;)))))\n  (list-dirs-sub-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d \&quot;)) :out) #\&quot;\\n\&quot;)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;))))))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d -not -path '*/\\\\.*' -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)))\n      (throw\n        (IllegalArgumentException.\n          (str (str (:path x) \&quot;/\&quot; (:file x)) \&quot; is not a directory\&quot;)))))\n  \n  (list-dirs-sub-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d \&quot;)) :out) #\&quot;\\n\&quot;)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;))))))&quot; &quot;(list-dirs-sub-dirs (-&gt;file-management {:path \&quot;/Users/gra11\&quot; \n                                        :file \&quot;Development\&quot;}))&quot; &quot;(list-dirs-sub-dirs (-&gt;file-management {:path \&quot;/Users\&quot; \n                                        :file \&quot;gra11\&quot;}))&quot; &quot;2&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d -not -path '*/\\\\.*' -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)))\n      (throw\n        (IllegalArgumentException.\n          (str (str (:path x) \&quot;/\&quot; (:file x)) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs-sub-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d \&quot;)) :out) #\&quot;\\n\&quot;)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n  (encode-ISO8859-1\n    [this]\n    (let [file (:file x)\n          path (:path x)\n          file-path (str path \&quot;/\&quot; file)]\n      (if (file-exists? file-path)\n        (do\n          (FileUtils/write (File. file-path)\n                           (FileUtils/readFileToString\n                             (File. file-path) \&quot;UTF-8\&quot;) \&quot;ISO-8859-1\&quot;)\n          (assoc x\n            :result (str (:path x) \&quot;/\&quot; (:file x))))\n        (throw\n          (IllegalArgumentException.\n            (str file-path \&quot; is not a file (or a directory)\&quot;)))))))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d -not -path '*/\\\\.*' -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (str (:path x) \&quot;/\&quot; (:file x)) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs-sub-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-sub-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (encode-ISO8859-1\n    [this]\n    (if (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str path \&quot;/\&quot; file)]\n        (do\n          (FileUtils/write (File. file-path)\n                           (FileUtils/readFileToString\n                             (File. file-path) \&quot;UTF-8\&quot;) \&quot;ISO-8859-1\&quot;)\n          (assoc x\n            :result file-path\n            :exec :encode-ISO8859-1)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;'(list 1)&quot; &quot;(defmacro file-path\n  '(list '+))&quot; &quot;(defmacro file-path\n  (list '+))&quot; &quot;(defmacro if-filter-pred\n  []\n  (list 'str test (cons 'filter 'even?)))&quot; &quot;(defmacro if-filter-pred\n  [x]\n  (list 'str (list ':path x) \&quot;/\&quot; (list ':path x)))&quot; &quot;(defmacro file-path\n  [x]\n  (list 'str (list ':path x) '\&quot;/\&quot; (list ':path x)))&quot; &quot;(macroexpand (file-path \&quot;\&quot;))&quot; &quot;(macroexpand (if-filter-pred true [1 2 3]))&quot; &quot;(macroexpand-1 (if-filter-pred true [1 2 3]))&quot; &quot;(macroexpand-1 '(if-filter-pred true [1 2 3]))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d -not -path '*/\\\\.*' -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (str (:path x) \&quot;/\&quot; (:file x)) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs-sub-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-sub-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (encode-ISO8859-1\n    [this]\n    (if (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (do\n          (FileUtils/write (File. file-path)\n                           (FileUtils/readFileToString\n                             (File. file-path) \&quot;UTF-8\&quot;) \&quot;ISO-8859-1\&quot;)\n          (assoc x\n            :result file-path\n            :exec :encode-ISO8859-1)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defmulti cetl-file-management (fn [x] (:exec x)))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (file-path x))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d -not -path '*/\\\\.*' -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (str (:path x) \&quot;/\&quot; (:file x)) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs-sub-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-sub-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (encode-ISO8859-1\n    [this]\n    (if (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (do\n          (FileUtils/write (File. file-path)\n                           (FileUtils/readFileToString\n                             (File. file-path) \&quot;UTF-8\&quot;) \&quot;ISO-8859-1\&quot;)\n          (assoc x\n            :result file-path\n            :exec :encode-ISO8859-1)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defprotocol file-management-component\n  (zip-file [x] \&quot;Zip's a file\&quot;)\n  (gzip-file [x] \&quot;Gzip's a file\&quot;)\n  (list-dirs-files  [x] \&quot;List the directories and files of a given path\&quot;)\n  (list-files [x] \&quot;List the files of a given path\&quot;)\n  (list-dirs [x] \&quot;List the directories of a given path\&quot;)\n  (list-dirs-sub-dirs [x] \&quot;List the dirs, inc sub-dirs of a given path\&quot;)\n  (encode-ISO8859-1 [X] \&quot;Encodes a file to ISO8859-1 format\&quot;))&quot; &quot;(zip-file {} (-&gt;file-management-component))&quot; &quot;(defmacro file-path\n  [x]\n  (list 'str (list ':path x) \&quot;/\&quot; (list ':path x)))&quot; &quot;(zip-file {:path \&quot;\&quot; :file \&quot;\&quot;} (-&gt;file-management))&quot; &quot;(ns cetl.file.management\n  (:require [clojure.string :as s]\n            [clojure.java.io :as io]\n            [clojure.set :refer [rename-keys]]\n            [cetl.utils.component-utils :refer [file-exists? dir-exists?]])\n  (:import (org.apache.commons.io FileUtils)\n           (java.util Date)\n           (java.io File LineNumberReader)\n           (java.text SimpleDateFormat)))&quot; &quot;(use '[clojure.java.shell :only [sh]])&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  \n  (zip-file\n    [this]\n    (if (or (file-exists? (file-path x))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d -not -path '*/\\\\.*' -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (str (:path x) \&quot;/\&quot; (:file x)) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs-sub-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-sub-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (encode-ISO8859-1\n    [this]\n    (if (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (do\n          (FileUtils/write (File. file-path)\n                           (FileUtils/readFileToString\n                             (File. file-path) \&quot;UTF-8\&quot;) \&quot;ISO-8859-1\&quot;)\n          (assoc x\n            :result file-path\n            :exec :encode-ISO8859-1)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(zip-file  (-&gt;file-management {:path \&quot;\&quot; :file \&quot;\&quot;}))&quot; &quot;(defmacro if-filter-pred\n  [test &amp; body]\n  (list 'if test (cons 'filter (cons 'even? body))))&quot; &quot;(macroexpand (if-filter-pred true (range 1 5)))&quot; &quot;(macroexpand '(if-filter-pred true (range 1 5)))&quot; &quot;(macroexpand '(file-path \&quot;grv\&quot;))&quot; &quot;(defmacro file-path\n  [x]\n  (list 'str (list ':path 'x) \&quot;/\&quot; (list ':path 'x)))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n\n  (zip-file\n    [this]\n    (if (or (file-exists? (file-path x))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d -not -path '*/\\\\.*' -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (str (:path x) \&quot;/\&quot; (:file x)) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs-sub-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-sub-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (encode-ISO8859-1\n    [this]\n    (if (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (do\n          (FileUtils/write (File. file-path)\n                           (FileUtils/readFileToString\n                             (File. file-path) \&quot;UTF-8\&quot;) \&quot;ISO-8859-1\&quot;)\n          (assoc x\n            :result file-path\n            :exec :encode-ISO8859-1)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n  \n  (encode-UTF-8\n    [this]\n    (if (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file (:file x)\n            path (:path x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (FileUtils/write (File. file-path)\n                           (FileUtils/readFileToString\n                             (File. file-path) \&quot;ISO-8859-1\&quot;) \&quot;UTF-8\&quot;)\n          (assoc x :result (str (:path x) \&quot;/\&quot; (:file x)))))\n      (throw\n        (IllegalArgumentException.\n          (str file-path \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defprotocol file-management-component\n  (zip-file [x] \&quot;Zip's a file\&quot;)\n  (gzip-file [x] \&quot;Gzip's a file\&quot;)\n  (list-dirs-files  [x] \&quot;List the directories and files of a given path\&quot;)\n  (list-files [x] \&quot;List the files of a given path\&quot;)\n  (list-dirs [x] \&quot;List the directories of a given path\&quot;)\n  (list-dirs-sub-dirs [x] \&quot;List the dirs, inc sub-dirs of a given path\&quot;)\n  (encode-ISO8859-1 [X] \&quot;Encodes a file to ISO8859-1 format\&quot;)\n  (encode-UTF-8 [x] \&quot;Encodes a file to UTF-8 format\&quot;))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d -not -path '*/\\\\.*' -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (str (:path x) \&quot;/\&quot; (:file x)) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs-sub-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-sub-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (encode-ISO8859-1\n    [this]\n    (if (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (do\n          (FileUtils/write (File. file-path)\n                           (FileUtils/readFileToString\n                             (File. file-path) \&quot;UTF-8\&quot;) \&quot;ISO-8859-1\&quot;)\n          (assoc x\n            :result file-path\n            :exec :encode-ISO8859-1)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (encode-UTF-8\n    [this]\n    (if (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file (:file x)\n            path (:path x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (FileUtils/write (File. file-path)\n                           (FileUtils/readFileToString\n                             (File. file-path) \&quot;ISO-8859-1\&quot;) \&quot;UTF-8\&quot;)\n          (assoc x :result (str (:path x) \&quot;/\&quot; (:file x)))))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d -not -path '*/\\\\.*' -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (str (:path x) \&quot;/\&quot; (:file x)) \&quot; is not a directory\&quot;)))))\n\n  (list-dirs-sub-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-sub-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n  (encode-ISO8859-1\n    [this]\n    (if (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (do\n          (FileUtils/write (File. file-path)\n                           (FileUtils/readFileToString\n                             (File. file-path) \&quot;UTF-8\&quot;) \&quot;ISO-8859-1\&quot;)\n          (assoc x\n            :result file-path\n            :exec :encode-ISO8859-1)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n  (encode-UTF-8\n    [this]\n    (if (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file (:file x)\n            path (:path x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (FileUtils/write (File. file-path)\n                           (FileUtils/readFileToString\n                             (File. file-path) \&quot;ISO-8859-1\&quot;) \&quot;UTF-8\&quot;)\n          (assoc x :result file-path)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defn file-exists?\n  [path]\n  (let [file (File. (:path path))]\n    (if (or (and (.exists (:file path))\n                 (not (.isDirectory (:file x)))))\n      path)))&quot; &quot;(defn file-exists?\n  [path]\n  (let [file (File. (:path path))]\n    (if (or (and (.exists (:file path))\n                 (not (.isDirectory (:file path)))))\n      path)))&quot; &quot;(defrecord file-management\n  [x]\n  file-management-component\n  (zip-file\n    [this]\n    (if (or (file-exists? x)\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n\n  (list-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d -not -path '*/\\\\.*' -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (str (:path x) \&quot;/\&quot; (:file x)) \&quot; is not a directory\&quot;)))))\n\n\n  (list-dirs-sub-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-sub-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n\n  (encode-ISO8859-1\n    [this]\n    (if (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (do\n          (FileUtils/write (File. file-path)\n                           (FileUtils/readFileToString\n                             (File. file-path) \&quot;UTF-8\&quot;) \&quot;ISO-8859-1\&quot;)\n          (assoc x\n            :result file-path\n            :exec :encode-ISO8859-1)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n\n  (encode-UTF-8\n    [this]\n    (if (file-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file (:file x)\n            path (:path x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (FileUtils/write (File. file-path)\n                           (FileUtils/readFileToString\n                             (File. file-path) \&quot;ISO-8859-1\&quot;) \&quot;UTF-8\&quot;)\n          (assoc x :result file-path\n                   :exec :encode-UTF-8)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defn file-exists?\n  [path]\n  (let [file (File. (:path path))]\n    (if (or (and (.exists (:file path))\n                 (not (.isDirectory (:file path)))))\n      (:path path))))&quot; &quot;(ns cetl.utils.component-utils\n  (:require [clojure.string :as s])\n  (import [java.io File]))&quot; &quot;(defn file-exists?\n  [path]\n  (let [file (File. (str (:file path) \&quot;/\&quot; (:path x)))]\n    (if (or (and (.exists file)\n                 (not (.isDirectory file))))\n      path)))&quot; &quot;(defn file-exists?\n  [path]\n  (let [file (File. (str (:file path) \&quot;/\&quot; (:path path)))]\n    (if (or (and (.exists file)\n                 (not (.isDirectory file))))\n      path)))&quot; &quot;(zip-file (-&gt;file-management {:path \&quot;\&quot; :file \&quot;\&quot;}))&quot; &quot;(zip-file (-&gt;file-management {:path \&quot;/Users/gra11\&quot; :file \&quot;Development\&quot;}))&quot; &quot;(extend-protocol file-management-component)&quot; &quot;(extend-protocol \n  file-management\n  (zip-file {}))&quot; &quot;(extend-protocol \n  file-management-component\n  (-&gt;zip-file {}))&quot; &quot;(extend-protocol \n  file-management-component\n  (zip-file {}))&quot; &quot;(extend-protocol\n  file-management-component\n  file-management\n  (zip-file {}))&quot; &quot;(defprotocol FileManagementComp\n  (zip-file [x] \&quot;Zip's a file\&quot;)\n  (gzip-file [x] \&quot;Gzip's a file\&quot;)\n  (list-dirs-files  [x] \&quot;List the directories and files of a given path\&quot;)\n  (list-files [x] \&quot;List the files of a given path\&quot;)\n  (list-dirs [x] \&quot;List the directories of a given path\&quot;)\n  (list-dirs-sub-dirs [x] \&quot;List the dirs, inc sub-dirs of a given path\&quot;)\n  (encode-ISO8859-1 [X] \&quot;Encodes a file to ISO8859-1 format\&quot;)\n  (encode-UTF-8 [x] \&quot;Encodes a file to UTF-8 format\&quot;))&quot; &quot;(defrecord file-management\n  [x]\n  ManagementCompomponent\n  (zip-file\n    [this]\n    (if (or (file-exists? x)\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? x)\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n\n  (list-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d -not -path '*/\\\\.*' -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (str (:path x) \&quot;/\&quot; (:file x)) \&quot; is not a directory\&quot;)))))\n\n\n  (list-dirs-sub-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-sub-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n\n  (encode-ISO8859-1\n    [this]\n    (if (file-exists? x)\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (do\n          (FileUtils/write (File. file-path)\n                           (FileUtils/readFileToString\n                             (File. file-path) \&quot;UTF-8\&quot;) \&quot;ISO-8859-1\&quot;)\n          (assoc x\n            :result file-path\n            :exec :encode-ISO8859-1)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n\n  (encode-UTF-8\n    [this]\n    (if (file-exists? x)\n      (let [file (:file x)\n            path (:path x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (FileUtils/write (File. file-path)\n                           (FileUtils/readFileToString\n                             (File. file-path) \&quot;ISO-8859-1\&quot;) \&quot;UTF-8\&quot;)\n          (assoc x :result file-path\n                   :exec :encode-UTF-8)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defrecord file-management\n  [x]\n  FileManagementComp\n  (zip-file\n    [this]\n    (if (or (file-exists? x)\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? x)\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n\n  (list-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d -not -path '*/\\\\.*' -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (str (:path x) \&quot;/\&quot; (:file x)) \&quot; is not a directory\&quot;)))))\n\n\n  (list-dirs-sub-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-sub-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n\n  (encode-ISO8859-1\n    [this]\n    (if (file-exists? x)\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (do\n          (FileUtils/write (File. file-path)\n                           (FileUtils/readFileToString\n                             (File. file-path) \&quot;UTF-8\&quot;) \&quot;ISO-8859-1\&quot;)\n          (assoc x\n            :result file-path\n            :exec :encode-ISO8859-1)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n\n  (encode-UTF-8\n    [this]\n    (if (file-exists? x)\n      (let [file (:file x)\n            path (:path x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (FileUtils/write (File. file-path)\n                           (FileUtils/readFileToString\n                             (File. file-path) \&quot;ISO-8859-1\&quot;) \&quot;UTF-8\&quot;)\n          (assoc x :result file-path\n                   :exec :encode-UTF-8)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;(defrecord FileManagement\n  [x]\n  FileManagementComp\n  (zip-file\n    [this]\n    (if (or (file-exists? x)\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot; \&quot; zip \&quot; file \&quot;.zip\&quot; \&quot; -r \&quot; file))\n          (assoc x\n            :result (str file-path \&quot;.zip\&quot;)\n            :exec :zip-file)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n\n  (gzip-file\n    [this]\n    (if (or (file-exists? x)\n            (dir-exists? (:path x)))\n      (let [path (:path x)\n            file (:file x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (clojure.java.shell/sh\n            \&quot;sh\&quot; \&quot;-c\&quot;\n            (str \&quot; cd \&quot; path \&quot;;\&quot;\n                 \&quot; tar -cvzf \&quot; (str file \&quot;.tar.gz \&quot; file)))\n          (assoc x\n            :result (str file-path \&quot;.tar.gz\&quot;)\n            :exec :gzip)))\n      (throw\n        (IllegalArgumentException.\n          (str (:file x) \&quot;/\&quot; (:path x) \&quot; is not a file (or a directory)\&quot;)))))\n\n\n  (list-dirs-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n\n  (list-files\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type f -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-files))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n\n  (list-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d -not -path '*/\\\\.*' -maxdepth 1 \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (str (:path x) \&quot;/\&quot; (:file x)) \&quot; is not a directory\&quot;)))))\n\n\n  (list-dirs-sub-dirs\n    [this]\n    (if (dir-exists? (str (:path x) \&quot;/\&quot; (:file x)))\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (assoc x\n          :result (s/split\n                    (get (clojure.java.shell/sh\n                           \&quot;sh\&quot; \&quot;-c\&quot;\n                           (str \&quot; cd \&quot; file-path \&quot;;\&quot;\n                                \&quot; find `pwd` -type d \&quot;)) :out) #\&quot;\\n\&quot;)\n          :exec :list-dirs-sub-dirs))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a directory\&quot;)))))\n\n\n  (encode-ISO8859-1\n    [this]\n    (if (file-exists? x)\n      (let [file-path (str (:path x) \&quot;/\&quot; (:file x))]\n        (do\n          (FileUtils/write (File. file-path)\n                           (FileUtils/readFileToString\n                             (File. file-path) \&quot;UTF-8\&quot;) \&quot;ISO-8859-1\&quot;)\n          (assoc x\n            :result file-path\n            :exec :encode-ISO8859-1)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;)))))\n\n\n  (encode-UTF-8\n    [this]\n    (if (file-exists? x)\n      (let [file (:file x)\n            path (:path x)\n            file-path (str path \&quot;/\&quot; file)]\n        (do\n          (FileUtils/write (File. file-path)\n                           (FileUtils/readFileToString\n                             (File. file-path) \&quot;ISO-8859-1\&quot;) \&quot;UTF-8\&quot;)\n          (assoc x :result file-path\n                   :exec :encode-UTF-8)))\n      (throw\n        (IllegalArgumentException.\n          (str (:path x) \&quot;/\&quot; (:file x) \&quot; is not a file (or a directory)\&quot;))))))&quot; &quot;&quot;], :remote []}}</component>
</project>